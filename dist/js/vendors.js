!function(t){var n=window.webpackJsonp;window.webpackJsonp=function(g,B,c){for(var l,a,i,b=0,d=[];b<g.length;b++)a=g[b],I[a]&&d.push(I[a][0]),I[a]=0;for(l in B)Object.prototype.hasOwnProperty.call(B,l)&&(t[l]=B[l]);for(n&&n(g,B,c);d.length;)d.shift()();if(c)for(b=0;b<c.length;b++)i=e(e.s=c[b]);return i};var g={},I={2:0};function e(n){if(g[n])return g[n].exports;var I=g[n]={i:n,l:!1,exports:{}};return t[n].call(I.exports,I,I.exports,e),I.l=!0,I.exports}e.e=function(t){var n=I[t];if(0===n)return new Promise(function(t){t()});if(n)return n[2];var g=new Promise(function(g,e){n=I[t]=[g,e]});n[2]=g;var B=document.getElementsByTagName("head")[0],c=document.createElement("script");c.type="text/javascript",c.charset="utf-8",c.async=!0,c.timeout=12e4,e.nc&&c.setAttribute("nonce",e.nc),c.src=e.p+"js/"+t+".js";var l=setTimeout(a,12e4);function a(){c.onerror=c.onload=null,clearTimeout(l);var n=I[t];0!==n&&(n&&n[1](new Error("Loading chunk "+t+" failed.")),I[t]=void 0)}return c.onerror=c.onload=a,B.appendChild(c),g},e.m=t,e.c=g,e.d=function(t,n,g){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:g})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="/",e.oe=function(t){throw console.error(t),t},e(e.s=28)}({0:function(module,exports,__webpack_require__){eval("/* Riot v3.9.4, @license MIT */\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.riot = {})));\n}(this, (function (exports) { 'use strict';\n\n  /**\n   * Shorter and fast way to select a single node in the DOM\n   * @param   { String } selector - unique dom selector\n   * @param   { Object } ctx - DOM node where the target of our search will is located\n   * @returns { Object } dom node found\n   */\n  function $(selector, ctx) {\n    return (ctx || document).querySelector(selector)\n  }\n\n  var\n    // be aware, internal usage\n    // ATTENTION: prefix the global dynamic variables with `__`\n    // tags instances cache\n    __TAGS_CACHE = [],\n    // tags implementation cache\n    __TAG_IMPL = {},\n    YIELD_TAG = 'yield',\n\n    /**\n     * Const\n     */\n    GLOBAL_MIXIN = '__global_mixin',\n\n    // riot specific prefixes or attributes\n    ATTRS_PREFIX = 'riot-',\n\n    // Riot Directives\n    REF_DIRECTIVES = ['ref', 'data-ref'],\n    IS_DIRECTIVE = 'data-is',\n    CONDITIONAL_DIRECTIVE = 'if',\n    LOOP_DIRECTIVE = 'each',\n    LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n    SHOW_DIRECTIVE = 'show',\n    HIDE_DIRECTIVE = 'hide',\n    KEY_DIRECTIVE = 'key',\n    RIOT_EVENTS_KEY = '__riot-events__',\n\n    // for typeof == '' comparisons\n    T_STRING = 'string',\n    T_OBJECT = 'object',\n    T_UNDEF  = 'undefined',\n    T_FUNCTION = 'function',\n\n    XLINK_NS = 'http://www.w3.org/1999/xlink',\n    SVG_NS = 'http://www.w3.org/2000/svg',\n    XLINK_REGEX = /^xlink:(\\w+)/,\n\n    WIN = typeof window === T_UNDEF ? undefined : window,\n\n    // special native tags that cannot be treated like the others\n    RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n    RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n    RE_EVENTS_PREFIX = /^on/,\n    RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n    // some DOM attributes must be normalized\n    CASE_SENSITIVE_ATTRIBUTES = {\n      'viewbox': 'viewBox',\n      'preserveaspectratio': 'preserveAspectRatio'\n    },\n    /**\n     * Matches boolean HTML attributes in the riot tag definition.\n     * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n     * @const {RegExp}\n     * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n     */\n    RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n    // version# for IE 8-11, 0 for others\n    IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n  /**\n   * Create a generic DOM node\n   * @param   { String } name - name of the DOM node we want to create\n   * @returns { Object } DOM node just created\n   */\n  function makeElement(name) {\n    return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n  }\n\n  /**\n   * Set any DOM attribute\n   * @param { Object } dom - DOM node we want to update\n   * @param { String } name - name of the property we want to set\n   * @param { String } val - value of the property we want to set\n   */\n  function setAttribute(dom, name, val) {\n    var xlink = XLINK_REGEX.exec(name);\n    if (xlink && xlink[1])\n      { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n    else\n      { dom.setAttribute(name, val); }\n  }\n\n  var styleNode;\n  // Create cache and shortcut to the correct property\n  var cssTextProp;\n  var byName = {};\n  var needsInject = false;\n\n  // skip the following code on the server\n  if (WIN) {\n    styleNode = ((function () {\n      // create a new style element with the correct type\n      var newNode = makeElement('style');\n      // replace any user node or insert the new one into the head\n      var userNode = $('style[type=riot]');\n\n      setAttribute(newNode, 'type', 'text/css');\n      /* istanbul ignore next */\n      if (userNode) {\n        if (userNode.id) { newNode.id = userNode.id; }\n        userNode.parentNode.replaceChild(newNode, userNode);\n      } else { document.head.appendChild(newNode); }\n\n      return newNode\n    }))();\n    cssTextProp = styleNode.styleSheet;\n  }\n\n  /**\n   * Object that will be used to inject and manage the css of every tag instance\n   */\n  var styleManager = {\n    styleNode: styleNode,\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param { String } css - css string\n     * @param { String } name - if it's passed we will map the css to a tagname\n     */\n    add: function add(css, name) {\n      byName[name] = css;\n      needsInject = true;\n    },\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function inject() {\n      if (!WIN || !needsInject) { return }\n      needsInject = false;\n      var style = Object.keys(byName)\n        .map(function (k) { return byName[k]; })\n        .join('\\n');\n      /* istanbul ignore next */\n      if (cssTextProp) { cssTextProp.cssText = style; }\n      else { styleNode.innerHTML = style; }\n    },\n\n    /**\n     * Remove a tag style of injected DOM later.\n     * @param {String} name a registered tagname\n     */\n    remove: function remove(name) {\n      delete byName[name];\n      needsInject = true;\n    }\n  }\n\n  /**\n   * The riot template engine\n   * @version v3.0.8\n   */\n\n  var skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n    var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n    var beforeReWords = [\n      'case',\n      'default',\n      'do',\n      'else',\n      'in',\n      'instanceof',\n      'prefix',\n      'return',\n      'typeof',\n      'void',\n      'yield'\n    ];\n\n    var wordsLastChar = beforeReWords.reduce(function (s, w) {\n      return s + w.slice(-1)\n    }, '');\n\n    var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n    var RE_VN_CHAR = /[$\\w]/;\n\n    function prev (code, pos) {\n      while (--pos >= 0 && /\\s/.test(code[pos])){ }\n      return pos\n    }\n\n    function _skipRegex (code, start) {\n\n      var re = /.*/g;\n      var pos = re.lastIndex = start++;\n      var match = re.exec(code)[0].match(RE_REGEX);\n\n      if (match) {\n        var next = pos + match[0].length;\n\n        pos = prev(code, pos);\n        var c = code[pos];\n\n        if (pos < 0 || ~beforeReChars.indexOf(c)) {\n          return next\n        }\n\n        if (c === '.') {\n\n          if (code[pos - 1] === '.') {\n            start = next;\n          }\n\n        } else if (c === '+' || c === '-') {\n\n          if (code[--pos] !== c ||\n              (pos = prev(code, pos)) < 0 ||\n              !RE_VN_CHAR.test(code[pos])) {\n            start = next;\n          }\n\n        } else if (~wordsLastChar.indexOf(c)) {\n\n          var end = pos + 1;\n\n          while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){ }\n          if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n            start = next;\n          }\n        }\n      }\n\n      return start\n    }\n\n    return _skipRegex\n\n  })();\n\n  /**\n   * riot.util.brackets\n   *\n   * - `brackets    ` - Returns a string or regex based on its parameter\n   * - `brackets.set` - Change the current riot brackets\n   *\n   * @module\n   */\n\n  /* global riot */\n\n  /* istanbul ignore next */\n  var brackets = (function (UNDEF) {\n\n    var\n      REGLOB = 'g',\n\n      R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n      R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n      S_QBLOCKS = R_STRINGS.source + '|' +\n        /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n        /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n      UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n      NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n      S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n      FINDBRACES = {\n        '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n        '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n        '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n      },\n\n      DEFAULT = '{ }';\n\n    var _pairs = [\n      '{', '}',\n      '{', '}',\n      /{[^}]*}/,\n      /\\\\([{}])/g,\n      /\\\\({)|{/g,\n      RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n      DEFAULT,\n      /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n      /(^|[^\\\\]){=[\\S\\s]*?}/\n    ];\n\n    var\n      cachedBrackets = UNDEF,\n      _regex,\n      _cache = [],\n      _settings;\n\n    function _loopback (re) { return re }\n\n    function _rewrite (re, bp) {\n      if (!bp) { bp = _cache; }\n      return new RegExp(\n        re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n      )\n    }\n\n    function _create (pair) {\n      if (pair === DEFAULT) { return _pairs }\n\n      var arr = pair.split(' ');\n\n      if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"')\n      }\n      arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n      arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n      arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n      arr[6] = _rewrite(_pairs[6], arr);\n      arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n      arr[8] = pair;\n      return arr\n    }\n\n    function _brackets (reOrIdx) {\n      return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n    }\n\n    _brackets.split = function split (str, tmpl, _bp) {\n      // istanbul ignore next: _bp is for the compiler\n      if (!_bp) { _bp = _cache; }\n\n      var\n        parts = [],\n        match,\n        isexpr,\n        start,\n        pos,\n        re = _bp[6];\n\n      var qblocks = [];\n      var prevStr = '';\n      var mark, lastIndex;\n\n      isexpr = start = re.lastIndex = 0;\n\n      while ((match = re.exec(str))) {\n\n        lastIndex = re.lastIndex;\n        pos = match.index;\n\n        if (isexpr) {\n\n          if (match[2]) {\n\n            var ch = match[2];\n            var rech = FINDBRACES[ch];\n            var ix = 1;\n\n            rech.lastIndex = lastIndex;\n            while ((match = rech.exec(str))) {\n              if (match[1]) {\n                if (match[1] === ch) { ++ix; }\n                else if (!--ix) { break }\n              } else {\n                rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n              }\n            }\n            re.lastIndex = ix ? str.length : rech.lastIndex;\n            continue\n          }\n\n          if (!match[3]) {\n            re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n            continue\n          }\n        }\n\n        if (!match[1]) {\n          unescapeStr(str.slice(start, pos));\n          start = re.lastIndex;\n          re = _bp[6 + (isexpr ^= 1)];\n          re.lastIndex = start;\n        }\n      }\n\n      if (str && start < str.length) {\n        unescapeStr(str.slice(start));\n      }\n\n      parts.qblocks = qblocks;\n\n      return parts\n\n      function unescapeStr (s) {\n        if (prevStr) {\n          s = prevStr + s;\n          prevStr = '';\n        }\n        if (tmpl || isexpr) {\n          parts.push(s && s.replace(_bp[5], '$1'));\n        } else {\n          parts.push(s);\n        }\n      }\n\n      function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n        if (slash) {\n          _lastIndex = skipRegex(str, _pos);\n        }\n\n        if (tmpl && _lastIndex > _pos + 2) {\n          mark = '\\u2057' + qblocks.length + '~';\n          qblocks.push(str.slice(_pos, _lastIndex));\n          prevStr += str.slice(start, _pos) + mark;\n          start = _lastIndex;\n        }\n        return _lastIndex\n      }\n    };\n\n    _brackets.hasExpr = function hasExpr (str) {\n      return _cache[4].test(str)\n    };\n\n    _brackets.loopKeys = function loopKeys (expr) {\n      var m = expr.match(_cache[9]);\n\n      return m\n        ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n        : { val: expr.trim() }\n    };\n\n    _brackets.array = function array (pair) {\n      return pair ? _create(pair) : _cache\n    };\n\n    function _reset (pair) {\n      if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n        _cache = _create(pair);\n        _regex = pair === DEFAULT ? _loopback : _rewrite;\n        _cache[9] = _regex(_pairs[9]);\n      }\n      cachedBrackets = pair;\n    }\n\n    function _setSettings (o) {\n      var b;\n\n      o = o || {};\n      b = o.brackets;\n      Object.defineProperty(o, 'brackets', {\n        set: _reset,\n        get: function () { return cachedBrackets },\n        enumerable: true\n      });\n      _settings = o;\n      _reset(b);\n    }\n\n    Object.defineProperty(_brackets, 'settings', {\n      set: _setSettings,\n      get: function () { return _settings }\n    });\n\n    /* istanbul ignore next: in the browser riot is always in the scope */\n    _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n    _brackets.set = _reset;\n    _brackets.skipRegex = skipRegex;\n\n    _brackets.R_STRINGS = R_STRINGS;\n    _brackets.R_MLCOMMS = R_MLCOMMS;\n    _brackets.S_QBLOCKS = S_QBLOCKS;\n    _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n    return _brackets\n\n  })();\n\n  /**\n   * @module tmpl\n   *\n   * tmpl          - Root function, returns the template value, render with data\n   * tmpl.hasExpr  - Test the existence of a expression inside a string\n   * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n   */\n\n  /* istanbul ignore next */\n  var tmpl = (function () {\n\n    var _cache = {};\n\n    function _tmpl (str, data) {\n      if (!str) { return str }\n\n      return (_cache[str] || (_cache[str] = _create(str))).call(\n        data, _logErr.bind({\n          data: data,\n          tmpl: str\n        })\n      )\n    }\n\n    _tmpl.hasExpr = brackets.hasExpr;\n\n    _tmpl.loopKeys = brackets.loopKeys;\n\n    // istanbul ignore next\n    _tmpl.clearCache = function () { _cache = {}; };\n\n    _tmpl.errorHandler = null;\n\n    function _logErr (err, ctx) {\n\n      err.riotData = {\n        tagName: ctx && ctx.__ && ctx.__.tagName,\n        _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n      };\n\n      if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n      else if (\n        typeof console !== 'undefined' &&\n        typeof console.error === 'function'\n      ) {\n        console.error(err.message);\n        console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n        console.log(this.data); // eslint-disable-line\n      }\n    }\n\n    function _create (str) {\n      var expr = _getTmpl(str);\n\n      if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n      return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n    }\n\n    var RE_DQUOTE = /\\u2057/g;\n    var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n    function _getTmpl (str) {\n      var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n      var qstr = parts.qblocks;\n      var expr;\n\n      if (parts.length > 2 || parts[0]) {\n        var i, j, list = [];\n\n        for (i = j = 0; i < parts.length; ++i) {\n\n          expr = parts[i];\n\n          if (expr && (expr = i & 1\n\n              ? _parseExpr(expr, 1, qstr)\n\n              : '\"' + expr\n                  .replace(/\\\\/g, '\\\\\\\\')\n                  .replace(/\\r\\n?|\\n/g, '\\\\n')\n                  .replace(/\"/g, '\\\\\"') +\n                '\"'\n\n            )) { list[j++] = expr; }\n\n        }\n\n        expr = j < 2 ? list[0]\n             : '[' + list.join(',') + '].join(\"\")';\n\n      } else {\n\n        expr = _parseExpr(parts[1], 0, qstr);\n      }\n\n      if (qstr.length) {\n        expr = expr.replace(RE_QBMARK, function (_, pos) {\n          return qstr[pos]\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\n/g, '\\\\n')\n        });\n      }\n      return expr\n    }\n\n    var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n    var\n      RE_BREND = {\n        '(': /[()]/g,\n        '[': /[[\\]]/g,\n        '{': /[{}]/g\n      };\n\n    function _parseExpr (expr, asText, qstr) {\n\n      expr = expr\n        .replace(/\\s+/g, ' ').trim()\n        .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n      if (expr) {\n        var\n          list = [],\n          cnt = 0,\n          match;\n\n        while (expr &&\n              (match = expr.match(RE_CSNAME)) &&\n              !match.index\n          ) {\n          var\n            key,\n            jsb,\n            re = /,|([[{(])|$/g;\n\n          expr = RegExp.rightContext;\n          key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n          while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n          jsb  = expr.slice(0, match.index);\n          expr = RegExp.rightContext;\n\n          list[cnt++] = _wrapExpr(jsb, 1, key);\n        }\n\n        expr = !cnt ? _wrapExpr(expr, asText)\n             : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n      }\n      return expr\n\n      function skipBraces (ch, re) {\n        var\n          mm,\n          lv = 1,\n          ir = RE_BREND[ch];\n\n        ir.lastIndex = re.lastIndex;\n        while (mm = ir.exec(expr)) {\n          if (mm[0] === ch) { ++lv; }\n          else if (!--lv) { break }\n        }\n        re.lastIndex = lv ? expr.length : ir.lastIndex;\n      }\n    }\n\n    // istanbul ignore next: not both\n    var // eslint-disable-next-line max-len\n      JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n      JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n      JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n    function _wrapExpr (expr, asText, key) {\n      var tb;\n\n      expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n        if (mvar) {\n          pos = tb ? 0 : pos + match.length;\n\n          if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n            match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n            if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n          } else if (pos) {\n            tb = !JS_NOPROPS.test(s.slice(pos));\n          }\n        }\n        return match\n      });\n\n      if (tb) {\n        expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n      }\n\n      if (key) {\n\n        expr = (tb\n            ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n          ) + '?\"' + key + '\":\"\"';\n\n      } else if (asText) {\n\n        expr = 'function(v){' + (tb\n            ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n          ) + ';return v||v===0?v:\"\"}.call(this)';\n      }\n\n      return expr\n    }\n\n    _tmpl.version = brackets.version = 'v3.0.8';\n\n    return _tmpl\n\n  })();\n\n  /* istanbul ignore next */\n  var observable = function(el) {\n\n    /**\n     * Extend the original object or create a new empty one\n     * @type { Object }\n     */\n\n    el = el || {};\n\n    /**\n     * Private variables\n     */\n    var callbacks = {},\n      slice = Array.prototype.slice;\n\n    /**\n     * Public Api\n     */\n\n    // extend the el object adding the observable methods\n    Object.defineProperties(el, {\n      /**\n       * Listen to the given `event` ands\n       * execute the `callback` each time an event is triggered.\n       * @param  { String } event - event id\n       * @param  { Function } fn - callback function\n       * @returns { Object } el\n       */\n      on: {\n        value: function(event, fn) {\n          if (typeof fn == 'function')\n            { (callbacks[event] = callbacks[event] || []).push(fn); }\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Removes the given `event` listeners\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      off: {\n        value: function(event, fn) {\n          if (event == '*' && !fn) { callbacks = {}; }\n          else {\n            if (fn) {\n              var arr = callbacks[event];\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) { arr.splice(i--, 1); }\n              }\n            } else { delete callbacks[event]; }\n          }\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Listen to the given `event` and\n       * execute the `callback` at most once\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      one: {\n        value: function(event, fn) {\n          function on() {\n            el.off(event, on);\n            fn.apply(el, arguments);\n          }\n          return el.on(event, on)\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Execute all callback functions that listen to\n       * the given `event`\n       * @param   { String } event - event id\n       * @returns { Object } el\n       */\n      trigger: {\n        value: function(event) {\n          var arguments$1 = arguments;\n\n\n          // getting the arguments\n          var arglen = arguments.length - 1,\n            args = new Array(arglen),\n            fns,\n            fn,\n            i;\n\n          for (i = 0; i < arglen; i++) {\n            args[i] = arguments$1[i + 1]; // skip first argument\n          }\n\n          fns = slice.call(callbacks[event] || [], 0);\n\n          for (i = 0; fn = fns[i]; ++i) {\n            fn.apply(el, args);\n          }\n\n          if (callbacks['*'] && event != '*')\n            { el.trigger.apply(el, ['*', event].concat(args)); }\n\n          return el\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n    });\n\n    return el\n\n  };\n\n  /**\n   * Short alias for Object.getOwnPropertyDescriptor\n   */\n  function getPropDescriptor (o, k) {\n    return Object.getOwnPropertyDescriptor(o, k)\n  }\n\n  /**\n   * Check if passed argument is undefined\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isUndefined(value) {\n    return typeof value === T_UNDEF\n  }\n\n  /**\n   * Check whether object's property could be overridden\n   * @param   { Object }  obj - source object\n   * @param   { String }  key - object property\n   * @returns { Boolean } true if writable\n   */\n  function isWritable(obj, key) {\n    var descriptor = getPropDescriptor(obj, key);\n    return isUndefined(obj[key]) || descriptor && descriptor.writable\n  }\n\n  /**\n   * Extend any object with other properties\n   * @param   { Object } src - source object\n   * @returns { Object } the resulting extended object\n   *\n   * var obj = { foo: 'baz' }\n   * extend(obj, {bar: 'bar', foo: 'bar'})\n   * console.log(obj) => {bar: 'bar', foo: 'bar'}\n   *\n   */\n  function extend(src) {\n    var obj;\n    var i = 1;\n    var args = arguments;\n    var l = args.length;\n\n    for (; i < l; i++) {\n      if (obj = args[i]) {\n        for (var key in obj) {\n          // check if this property of the source object could be overridden\n          if (isWritable(src, key))\n            { src[key] = obj[key]; }\n        }\n      }\n    }\n    return src\n  }\n\n  /**\n   * Alias for Object.create\n   */\n  function create(src) {\n    return Object.create(src)\n  }\n\n  var settings = extend(create(brackets.settings), {\n    skipAnonymousTags: true,\n    // handle the auto updates on any DOM event\n    autoUpdate: true\n  })\n\n  /**\n   * Shorter and fast way to select multiple nodes in the DOM\n   * @param   { String } selector - DOM selector\n   * @param   { Object } ctx - DOM node where the targets of our search will is located\n   * @returns { Object } dom nodes found\n   */\n  function $$(selector, ctx) {\n    return [].slice.call((ctx || document).querySelectorAll(selector))\n  }\n\n  /**\n   * Create a document text node\n   * @returns { Object } create a text node to use as placeholder\n   */\n  function createDOMPlaceholder() {\n    return document.createTextNode('')\n  }\n\n  /**\n   * Toggle the visibility of any DOM node\n   * @param   { Object }  dom - DOM node we want to hide\n   * @param   { Boolean } show - do we want to show it?\n   */\n\n  function toggleVisibility(dom, show) {\n    dom.style.display = show ? '' : 'none';\n    dom.hidden = show ? false : true;\n  }\n\n  /**\n   * Get the value of any DOM attribute on a node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { String } name - name of the attribute we want to get\n   * @returns { String | undefined } name of the node attribute whether it exists\n   */\n  function getAttribute(dom, name) {\n    return dom.getAttribute(name)\n  }\n\n  /**\n   * Remove any DOM attribute from a node\n   * @param   { Object } dom - DOM node we want to update\n   * @param   { String } name - name of the property we want to remove\n   */\n  function removeAttribute(dom, name) {\n    dom.removeAttribute(name);\n  }\n\n  /**\n   * Set the inner html of any DOM node SVGs included\n   * @param { Object } container - DOM node where we'll inject new html\n   * @param { String } html - html to inject\n   * @param { Boolean } isSvg - svg tags should be treated a bit differently\n   */\n  /* istanbul ignore next */\n  function setInnerHTML(container, html, isSvg) {\n    // innerHTML is not supported on svg tags so we neet to treat them differently\n    if (isSvg) {\n      var node = container.ownerDocument.importNode(\n        new DOMParser()\n          .parseFromString((\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\"), 'application/xml')\n          .documentElement,\n        true\n      );\n\n      container.appendChild(node);\n    } else {\n      container.innerHTML = html;\n    }\n  }\n\n  /**\n   * Minimize risk: only zero or one _space_ between attr & value\n   * @param   { String }   html - html string we want to parse\n   * @param   { Function } fn - callback function to apply on any attribute found\n   */\n  function walkAttributes(html, fn) {\n    if (!html) { return }\n    var m;\n    while (m = RE_HTML_ATTRS.exec(html))\n      { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n  }\n\n  /**\n   * Create a document fragment\n   * @returns { Object } document fragment\n   */\n  function createFragment() {\n    return document.createDocumentFragment()\n  }\n\n  /**\n   * Insert safely a tag to fix #1962 #1649\n   * @param   { HTMLElement } root - children container\n   * @param   { HTMLElement } curr - node to insert\n   * @param   { HTMLElement } next - node that should preceed the current node inserted\n   */\n  function safeInsert(root, curr, next) {\n    root.insertBefore(curr, next.parentNode && next);\n  }\n\n  /**\n   * Convert a style object to a string\n   * @param   { Object } style - style object we need to parse\n   * @returns { String } resulting css string\n   * @example\n   * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n   */\n  function styleObjectToString(style) {\n    return Object.keys(style).reduce(function (acc, prop) {\n      return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n    }, '')\n  }\n\n  /**\n   * Walk down recursively all the children tags starting dom node\n   * @param   { Object }   dom - starting node where we will start the recursion\n   * @param   { Function } fn - callback to transform the child node just found\n   * @param   { Object }   context - fn can optionally return an object, which is passed to children\n   */\n  function walkNodes(dom, fn, context) {\n    if (dom) {\n      var res = fn(dom, context);\n      var next;\n      // stop the recursion\n      if (res === false) { return }\n\n      dom = dom.firstChild;\n\n      while (dom) {\n        next = dom.nextSibling;\n        walkNodes(dom, fn, res);\n        dom = next;\n      }\n    }\n  }\n\n\n\n  var dom = /*#__PURE__*/Object.freeze({\n    $$: $$,\n    $: $,\n    createDOMPlaceholder: createDOMPlaceholder,\n    mkEl: makeElement,\n    setAttr: setAttribute,\n    toggleVisibility: toggleVisibility,\n    getAttr: getAttribute,\n    remAttr: removeAttribute,\n    setInnerHTML: setInnerHTML,\n    walkAttrs: walkAttributes,\n    createFrag: createFragment,\n    safeInsert: safeInsert,\n    styleObjectToString: styleObjectToString,\n    walkNodes: walkNodes\n  });\n\n  /**\n   * Check against the null and undefined values\n   * @param   { * }  value -\n   * @returns {Boolean} -\n   */\n  function isNil(value) {\n    return isUndefined(value) || value === null\n  }\n\n  /**\n   * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n   * @param { * } value -\n   * @returns { Boolean } -\n   */\n  function isBlank(value) {\n    return isNil(value) || value === ''\n  }\n\n  /**\n   * Check if passed argument is a function\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isFunction(value) {\n    return typeof value === T_FUNCTION\n  }\n\n  /**\n   * Check if passed argument is an object, exclude null\n   * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isObject(value) {\n    return value && typeof value === T_OBJECT // typeof null is 'object'\n  }\n\n  /**\n   * Check if a DOM node is an svg tag or part of an svg\n   * @param   { HTMLElement }  el - node we want to test\n   * @returns {Boolean} true if it's an svg node\n   */\n  function isSvg(el) {\n    var owner = el.ownerSVGElement;\n    return !!owner || owner === null\n  }\n\n  /**\n   * Check if passed argument is a kind of array\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isArray(value) {\n    return Array.isArray(value) || value instanceof Array\n  }\n\n  /**\n   * Check if the passed argument is a boolean attribute\n   * @param   { String } value -\n   * @returns { Boolean } -\n   */\n  function isBoolAttr(value) {\n    return RE_BOOL_ATTRS.test(value)\n  }\n\n  /**\n   * Check if passed argument is a string\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n  function isString(value) {\n    return typeof value === T_STRING\n  }\n\n\n\n  var check = /*#__PURE__*/Object.freeze({\n    isBlank: isBlank,\n    isFunction: isFunction,\n    isObject: isObject,\n    isSvg: isSvg,\n    isWritable: isWritable,\n    isArray: isArray,\n    isBoolAttr: isBoolAttr,\n    isNil: isNil,\n    isString: isString,\n    isUndefined: isUndefined\n  });\n\n  /**\n   * Check whether an array contains an item\n   * @param   { Array } array - target array\n   * @param   { * } item - item to test\n   * @returns { Boolean } -\n   */\n  function contains(array, item) {\n    return array.indexOf(item) !== -1\n  }\n\n  /**\n   * Specialized function for looping an array-like collection with `each={}`\n   * @param   { Array } list - collection of items\n   * @param   {Function} fn - callback function\n   * @returns { Array } the array looped\n   */\n  function each(list, fn) {\n    var len = list ? list.length : 0;\n    var i = 0;\n    for (; i < len; i++) { fn(list[i], i); }\n    return list\n  }\n\n  /**\n   * Faster String startsWith alternative\n   * @param   { String } str - source string\n   * @param   { String } value - test string\n   * @returns { Boolean } -\n   */\n  function startsWith(str, value) {\n    return str.slice(0, value.length) === value\n  }\n\n  /**\n   * Function returning always a unique identifier\n   * @returns { Number } - number from 0...n\n   */\n  var uid = (function uid() {\n    var i = -1;\n    return function () { return ++i; }\n  })()\n\n  /**\n   * Helper function to set an immutable property\n   * @param   { Object } el - object where the new property will be set\n   * @param   { String } key - object key where the new property will be stored\n   * @param   { * } value - value of the new property\n   * @param   { Object } options - set the propery overriding the default options\n   * @returns { Object } - the initial object\n   */\n  function define(el, key, value, options) {\n    Object.defineProperty(el, key, extend({\n      value: value,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }, options));\n    return el\n  }\n\n  /**\n   * Convert a string containing dashes to camel case\n   * @param   { String } str - input string\n   * @returns { String } my-string -> myString\n   */\n  function toCamel(str) {\n    return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n  }\n\n  /**\n   * Warn a message via console\n   * @param   {String} message - warning message\n   */\n  function warn(message) {\n    if (console && console.warn) { console.warn(message); }\n  }\n\n\n\n  var misc = /*#__PURE__*/Object.freeze({\n    contains: contains,\n    each: each,\n    getPropDescriptor: getPropDescriptor,\n    startsWith: startsWith,\n    uid: uid,\n    defineProperty: define,\n    objectCreate: create,\n    extend: extend,\n    toCamel: toCamel,\n    warn: warn\n  });\n\n  /**\n   * Set the property of an object for a given key. If something already\n   * exists there, then it becomes an array containing both the old and new value.\n   * @param { Object } obj - object on which to set the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be set\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n   * @param { Number } index - add the new item in a certain array position\n   */\n  function arrayishAdd(obj, key, value, ensureArray, index) {\n    var dest = obj[key];\n    var isArr = isArray(dest);\n    var hasIndex = !isUndefined(index);\n\n    if (dest && dest === value) { return }\n\n    // if the key was never set, set it once\n    if (!dest && ensureArray) { obj[key] = [value]; }\n    else if (!dest) { obj[key] = value; }\n    // if it was an array and not yet set\n    else {\n      if (isArr) {\n        var oldIndex = dest.indexOf(value);\n        // this item never changed its position\n        if (oldIndex === index) { return }\n        // remove the item from its old position\n        if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n        // move or add the item\n        if (hasIndex) {\n          dest.splice(index, 0, value);\n        } else {\n          dest.push(value);\n        }\n      } else { obj[key] = [dest, value]; }\n    }\n  }\n\n  /**\n   * Detect the tag implementation by a DOM node\n   * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n   * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n   */\n  function get(dom) {\n    return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) ||\n      getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n  }\n\n  /**\n   * Get the tag name of any DOM node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n   * @returns { String } name to identify this dom node in riot\n   */\n  function getName(dom, skipDataIs) {\n    var child = get(dom);\n    var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n    return namedTag && !tmpl.hasExpr(namedTag) ?\n      namedTag : child ? child.name : dom.tagName.toLowerCase()\n  }\n\n  /**\n   * Return a temporary context containing also the parent properties\n   * @this Tag\n   * @param { Tag } - temporary tag context containing all the parent properties\n   */\n  function inheritParentProps() {\n    if (this.parent) { return extend(create(this), this.parent) }\n    return this\n  }\n\n  /*\n    Includes hacks needed for the Internet Explorer version 9 and below\n    See: http://kangax.github.io/compat-table/es5/#ie8\n         http://codeplanet.io/dropping-ie8/\n  */\n\n  var\n    reHasYield  = /<yield\\b/i,\n    reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n    reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n    reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n    rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n    tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n    GENERIC = 'div',\n    SVG = 'svg';\n\n\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n  function specialTags(el, tmpl, tagName) {\n\n    var\n      select = tagName[0] === 'o',\n      parent = select ? 'select>' : 'table>';\n\n    // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n    el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n    parent = el.firstChild;\n\n    // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n    /* istanbul ignore next */\n    if (select) {\n      parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName];\n      if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n    }\n    return parent\n  }\n\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n  function replaceYield(tmpl, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(tmpl)) { return tmpl }\n\n    // be careful with #1343 - string on the source having `$1`\n    var src = {};\n\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text;   // preserve first definition\n      return ''\n    }).trim();\n\n    return tmpl\n      .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n        return src[ref] || def || ''\n      })\n      .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n        return html || def || ''\n      })\n  }\n\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   { String } tmpl  - The template coming from the custom tag definition\n   * @param   { String } html - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @param   { Boolean } isSvg - true if the root node is an svg\n   * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n   */\n  function mkdom(tmpl, html, isSvg) {\n    var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n    var  tagName = match && match[1].toLowerCase();\n    var el = makeElement(isSvg ? SVG : GENERIC);\n\n    // replace all the yield tags with the tag inner html\n    tmpl = replaceYield(tmpl, html);\n\n    /* istanbul ignore next */\n    if (tblTags.test(tagName))\n      { el = specialTags(el, tmpl, tagName); }\n    else\n      { setInnerHTML(el, tmpl, isSvg); }\n\n    return el\n  }\n\n  /**\n   * Loop backward all the parents tree to detect the first custom parent tag\n   * @param   { Object } tag - a Tag instance\n   * @returns { Object } the instance of the first custom parent tag found\n   */\n  function getImmediateCustomParent(tag) {\n    var ptag = tag;\n    while (ptag.__.isAnonymous) {\n      if (!ptag.parent) { break }\n      ptag = ptag.parent;\n    }\n    return ptag\n  }\n\n  /**\n   * Trigger DOM events\n   * @param   { HTMLElement } dom - dom element target of the event\n   * @param   { Function } handler - user function\n   * @param   { Object } e - event object\n   */\n  function handleEvent(dom, handler, e) {\n    var ptag = this.__.parent;\n    var item = this.__.item;\n\n    if (!item)\n      { while (ptag && !item) {\n        item = ptag.__.item;\n        ptag = ptag.__.parent;\n      } }\n\n    // override the event properties\n    /* istanbul ignore next */\n    if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n    /* istanbul ignore next */\n    if (isWritable(e, 'target')) { e.target = e.srcElement; }\n    /* istanbul ignore next */\n    if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n    e.item = item;\n\n    handler.call(this, e);\n\n    // avoid auto updates\n    if (!settings.autoUpdate) { return }\n\n    if (!e.preventUpdate) {\n      var p = getImmediateCustomParent(this);\n      // fixes #2083\n      if (p.isMounted) { p.update(); }\n    }\n  }\n\n  /**\n   * Attach an event to a DOM node\n   * @param { String } name - event name\n   * @param { Function } handler - event callback\n   * @param { Object } dom - dom node\n   * @param { Tag } tag - tag instance\n   */\n  function setEventHandler(name, handler, dom, tag) {\n    var eventName;\n    var cb = handleEvent.bind(tag, dom, handler);\n\n    // avoid to bind twice the same event\n    // possible fix for #2332\n    dom[name] = null;\n\n    // normalize event name\n    eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n    // cache the listener into the listeners array\n    if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n    if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n    if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n    dom[RIOT_EVENTS_KEY][name] = cb;\n    dom.addEventListener(eventName, cb, false);\n  }\n\n  /**\n   * Create a new child tag including it correctly into its parent\n   * @param   { Object } child - child tag implementation\n   * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n   * @param   { String } innerHTML - inner html of the child node\n   * @param   { Object } parent - instance of the parent tag including the child custom tag\n   * @returns { Object } instance of the new child tag just created\n   */\n  function initChild(child, opts, innerHTML, parent) {\n    var tag = createTag(child, opts, innerHTML);\n    var tagName = opts.tagName || getName(opts.root, true);\n    var ptag = getImmediateCustomParent(parent);\n    // fix for the parent attribute in the looped elements\n    define(tag, 'parent', ptag);\n    // store the real parent tag\n    // in some cases this could be different from the custom parent tag\n    // for example in nested loops\n    tag.__.parent = parent;\n\n    // add this tag to the custom parent tag\n    arrayishAdd(ptag.tags, tagName, tag);\n\n    // and also to the real parent tag\n    if (ptag !== parent)\n      { arrayishAdd(parent.tags, tagName, tag); }\n\n    return tag\n  }\n\n  /**\n   * Removes an item from an object at a given key. If the key points to an array,\n   * then the item is just removed from the array.\n   * @param { Object } obj - object on which to remove the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be removed\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n  */\n  function arrayishRemove(obj, key, value, ensureArray) {\n    if (isArray(obj[key])) {\n      var index = obj[key].indexOf(value);\n      if (index !== -1) { obj[key].splice(index, 1); }\n      if (!obj[key].length) { delete obj[key]; }\n      else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n    } else if (obj[key] === value)\n      { delete obj[key]; } // otherwise just delete the key\n  }\n\n  /**\n   * Adds the elements for a virtual tag\n   * @this Tag\n   * @param { Node } src - the node that will do the inserting or appending\n   * @param { Tag } target - only if inserting, insert before this tag's first child\n   */\n  function makeVirtual(src, target) {\n    var this$1 = this;\n\n    var head = createDOMPlaceholder();\n    var tail = createDOMPlaceholder();\n    var frag = createFragment();\n    var sib;\n    var el;\n\n    this.root.insertBefore(head, this.root.firstChild);\n    this.root.appendChild(tail);\n\n    this.__.head = el = head;\n    this.__.tail = tail;\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      this$1.__.virts.push(el); // hold for unmounting\n      el = sib;\n    }\n\n    if (target)\n      { src.insertBefore(frag, target.__.head); }\n    else\n      { src.appendChild(frag); }\n  }\n\n  /**\n   * makes a tag virtual and replaces a reference in the dom\n   * @this Tag\n   * @param { tag } the tag to make virtual\n   * @param { ref } the dom reference location\n   */\n  function makeReplaceVirtual(tag, ref) {\n    var frag = createFragment();\n    makeVirtual.call(tag, frag);\n    ref.parentNode.replaceChild(frag, ref);\n  }\n\n  /**\n   * Update dynamically created data-is tags with changing expressions\n   * @param { Object } expr - expression tag and expression info\n   * @param { Tag }    parent - parent for tag creation\n   * @param { String } tagName - tag implementation we want to use\n   */\n  function updateDataIs(expr, parent, tagName) {\n    var tag = expr.tag || expr.dom._tag;\n    var ref;\n\n    var ref$1 = tag ? tag.__ : {};\n    var head = ref$1.head;\n    var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n    if (tag && expr.tagName === tagName) {\n      tag.update();\n      return\n    }\n\n    // sync _parent to accommodate changing tagnames\n    if (tag) {\n      // need placeholder before unmount\n      if(isVirtual) {\n        ref = createDOMPlaceholder();\n        head.parentNode.insertBefore(ref, head);\n      }\n\n      tag.unmount(true);\n    }\n\n    // unable to get the tag name\n    if (!isString(tagName)) { return }\n\n    expr.impl = __TAG_IMPL[tagName];\n\n    // unknown implementation\n    if (!expr.impl) { return }\n\n    expr.tag = tag = initChild(\n      expr.impl, {\n        root: expr.dom,\n        parent: parent,\n        tagName: tagName\n      },\n      expr.dom.innerHTML,\n      parent\n    );\n\n    each(expr.attrs, function (a) { return setAttribute(tag.root, a.name, a.value); });\n    expr.tagName = tagName;\n    tag.mount();\n\n    // root exist first time, after use placeholder\n    if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n    // parent is the placeholder tag, not the dynamic tag so clean up\n    parent.__.onUnmount = function () {\n      var delName = tag.opts.dataIs;\n      arrayishRemove(tag.parent.tags, delName, tag);\n      arrayishRemove(tag.__.parent.tags, delName, tag);\n      tag.unmount();\n    };\n  }\n\n  /**\n   * Nomalize any attribute removing the \"riot-\" prefix\n   * @param   { String } attrName - original attribute name\n   * @returns { String } valid html attribute name\n   */\n  function normalizeAttrName(attrName) {\n    if (!attrName) { return null }\n    attrName = attrName.replace(ATTRS_PREFIX, '');\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n    return attrName\n  }\n\n  /**\n   * Update on single tag expression\n   * @this Tag\n   * @param { Object } expr - expression logic\n   * @returns { undefined }\n   */\n  function updateExpression(expr) {\n    if (this.root && getAttribute(this.root,'virtualized')) { return }\n\n    var dom = expr.dom;\n    // remove the riot- prefix\n    var attrName = normalizeAttrName(expr.attr);\n    var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n    var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n    var parent = dom && (expr.parent || dom.parentNode);\n    // detect the style attributes\n    var isStyleAttr = attrName === 'style';\n    var isClassAttr = attrName === 'class';\n\n    var value;\n\n    // if it's a tag we could totally skip the rest\n    if (expr._riot_id) {\n      if (expr.__.wasCreated) {\n        expr.update();\n      // if it hasn't been mounted yet, do that now.\n      } else {\n        expr.mount();\n        if (isVirtual) {\n          makeReplaceVirtual(expr, expr.root);\n        }\n      }\n      return\n    }\n\n    // if this expression has the update method it means it can handle the DOM changes by itself\n    if (expr.update) { return expr.update() }\n\n    var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this;\n\n    // ...it seems to be a simple expression so we try to calculate its value\n    value = tmpl(expr.expr, context);\n\n    var hasValue = !isBlank(value);\n    var isObj = isObject(value);\n\n    // convert the style/class objects to strings\n    if (isObj) {\n      if (isClassAttr) {\n        value = tmpl(JSON.stringify(value), this);\n      } else if (isStyleAttr) {\n        value = styleObjectToString(value);\n      }\n    }\n\n    // remove original attribute\n    if (expr.attr && (!expr.wasParsedOnce || !hasValue || value === false)) {\n      // remove either riot-* attributes or just the attribute name\n      removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n    }\n\n    // for the boolean attributes we don't need the value\n    // we can convert it to checked=true to checked=checked\n    if (expr.bool) { value = value ? attrName : false; }\n    if (expr.isRtag) { return updateDataIs(expr, this, value) }\n    if (expr.wasParsedOnce && expr.value === value) { return }\n\n    // update the expression value\n    expr.value = value;\n    expr.wasParsedOnce = true;\n\n    // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n    if (isObj && !isClassAttr && !isStyleAttr && !isToggle) { return }\n    // avoid to render undefined/null values\n    if (!hasValue) { value = ''; }\n\n    // textarea and text nodes have no attribute name\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += '';\n      // test for parent avoids error with invalid assignment to nodeValue\n      if (parent) {\n        // cache the parent node because somehow it will become null on IE\n        // on the next iteration\n        expr.parent = parent;\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value;                    // #1113\n          if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n        }                                         // will be available on 'updated'\n        else { dom.nodeValue = value; }\n      }\n      return\n    }\n\n\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, this);\n    // show / hide\n    } else if (isToggle) {\n      toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n    // handle attributes\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value;\n      }\n\n      if (attrName === 'value' && dom.value !== value) {\n        dom.value = value;\n      } else if (hasValue && value !== false) {\n        setAttribute(dom, attrName, value);\n      }\n\n      // make sure that in case of style changes\n      // the element stays hidden\n      if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n    }\n  }\n\n  /**\n   * Update all the expressions in a Tag instance\n   * @this Tag\n   * @param { Array } expressions - expression that must be re evaluated\n   */\n  function update(expressions) {\n    each(expressions, updateExpression.bind(this));\n  }\n\n  /**\n   * We need to update opts for this tag. That requires updating the expressions\n   * in any attributes on the tag, and then copying the result onto opts.\n   * @this Tag\n   * @param   {Boolean} isLoop - is it a loop tag?\n   * @param   { Tag }  parent - parent tag node\n   * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n   * @param   { Object }  opts - tag options\n   * @param   { Array }  instAttrs - tag attributes array\n   */\n  function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n    // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n    // (and only this case) we don't need to do updateOpts, because the regular parse\n    // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n    if (isLoop && isAnonymous) { return }\n    var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n\n    each(instAttrs, function (attr) {\n      if (attr.expr) { updateExpression.call(ctx, attr.expr); }\n      // normalize the attribute names\n      opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n    });\n  }\n\n  /**\n   * Update the tag expressions and options\n   * @param { Tag } tag - tag object\n   * @param { * } data - data we want to use to extend the tag properties\n   * @param { Array } expressions - component expressions array\n   * @returns { Tag } the current tag instance\n   */\n  function componentUpdate(tag, data, expressions) {\n    var __ = tag.__;\n    var nextOpts = {};\n    var canTrigger = tag.isMounted && !__.skipAnonymous;\n\n    // inherit properties from the parent tag\n    if (__.isAnonymous && __.parent) { extend(tag, __.parent); }\n    extend(tag, data);\n\n    updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n    if (\n      canTrigger &&\n      tag.isMounted &&\n      isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)\n    ) {\n      return tag\n    }\n\n    extend(tag.opts, nextOpts);\n\n    if (canTrigger) { tag.trigger('update', data); }\n    update.call(tag, expressions);\n    if (canTrigger) { tag.trigger('updated'); }\n\n    return tag\n  }\n\n  /**\n   * Get selectors for tags\n   * @param   { Array } tags - tag names to select\n   * @returns { String } selector\n   */\n  function query(tags) {\n    // select all tags\n    if (!tags) {\n      var keys = Object.keys(__TAG_IMPL);\n      return keys + query(keys)\n    }\n\n    return tags\n      .filter(function (t) { return !/[^-\\w]/.test(t); })\n      .reduce(function (list, t) {\n        var name = t.trim().toLowerCase();\n        return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n      }, '')\n  }\n\n  /**\n   * Another way to create a riot tag a bit more es6 friendly\n   * @param { HTMLElement } el - tag DOM selector or DOM node/s\n   * @param { Object } opts - tag logic\n   * @returns { Tag } new riot tag instance\n   */\n  function Tag(el, opts) {\n    // get the tag properties from the class constructor\n    var ref = this;\n    var name = ref.name;\n    var tmpl = ref.tmpl;\n    var css = ref.css;\n    var attrs = ref.attrs;\n    var onCreate = ref.onCreate;\n    // register a new tag and cache the class prototype\n    if (!__TAG_IMPL[name]) {\n      tag(name, tmpl, css, attrs, onCreate);\n      // cache the class constructor\n      __TAG_IMPL[name].class = this.constructor;\n    }\n\n    // mount the tag using the class instance\n    mount$1(el, name, opts, this);\n    // inject the component css\n    if (css) { styleManager.inject(); }\n\n    return this\n  }\n\n  /**\n   * Create a new riot tag implementation\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag(name, tmpl, css, attrs, fn) {\n    if (isFunction(attrs)) {\n      fn = attrs;\n\n      if (/^[\\w-]+\\s?=/.test(css)) {\n        attrs = css;\n        css = '';\n      } else\n        { attrs = ''; }\n    }\n\n    if (css) {\n      if (isFunction(css))\n        { fn = css; }\n      else\n        { styleManager.add(css, name); }\n    }\n\n    name = name.toLowerCase();\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name\n  }\n\n  /**\n   * Create a new riot tag implementation (for use by the compiler)\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n  function tag2(name, tmpl, css, attrs, fn) {\n    if (css) { styleManager.add(css, name); }\n\n    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n    return name\n  }\n\n  /**\n   * Mount a tag using a specific tag implementation\n   * @param   { * } selector - tag DOM selector or DOM node/s\n   * @param   { String } tagName - tag implementation name\n   * @param   { Object } opts - tag logic\n   * @returns { Array } new tags instances\n   */\n  function mount(selector, tagName, opts) {\n    var tags = [];\n    var elem, allTags;\n\n    function pushTagsTo(root) {\n      if (root.tagName) {\n        var riotTag = getAttribute(root, IS_DIRECTIVE), tag;\n\n        // have tagName? force riot-tag to be the same\n        if (tagName && riotTag !== tagName) {\n          riotTag = tagName;\n          setAttribute(root, IS_DIRECTIVE, tagName);\n        }\n\n        tag = mount$1(root, riotTag || root.tagName.toLowerCase(), opts);\n\n        if (tag)\n          { tags.push(tag); }\n      } else if (root.length)\n        { each(root, pushTagsTo); } // assume nodeList\n    }\n\n    // inject styles into DOM\n    styleManager.inject();\n\n    if (isObject(tagName)) {\n      opts = tagName;\n      tagName = 0;\n    }\n\n    // crawl the DOM to find the tag\n    if (isString(selector)) {\n      selector = selector === '*' ?\n        // select all registered tags\n        // & tags found with the riot-tag attribute set\n        allTags = query() :\n        // or just the ones named like the selector\n        selector + query(selector.split(/, */));\n\n      // make sure to pass always a selector\n      // to the querySelectorAll function\n      elem = selector ? $$(selector) : [];\n    }\n    else\n      // probably you have passed already a tag or a NodeList\n      { elem = selector; }\n\n    // select all the registered and mount them inside their root elements\n    if (tagName === '*') {\n      // get all custom tags\n      tagName = allTags || query();\n      // if the root els it's just a single tag\n      if (elem.tagName)\n        { elem = $$(tagName, elem); }\n      else {\n        // select all the children for all the different root elements\n        var nodeList = [];\n\n        each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n        elem = nodeList;\n      }\n      // get rid of the tagName\n      tagName = 0;\n    }\n\n    pushTagsTo(elem);\n\n    return tags\n  }\n\n  // Create a mixin that could be globally shared across all the tags\n  var mixins = {};\n  var globals = mixins[GLOBAL_MIXIN] = {};\n  var mixins_id = 0;\n\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mix - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n  function mixin(name, mix, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      mixin((\"__\" + (mixins_id++) + \"__\"), name, true);\n      return\n    }\n\n    var store = g ? globals : mixins;\n\n    // Getter\n    if (!mix) {\n      if (isUndefined(store[name]))\n        { throw new Error((\"Unregistered mixin: \" + name)) }\n\n      return store[name]\n    }\n\n    // Setter\n    store[name] = isFunction(mix) ?\n      extend(mix.prototype, store[name] || {}) && mix :\n      extend(store[name] || {}, mix);\n  }\n\n  /**\n   * Update all the tags instances created\n   * @returns { Array } all the tags instances\n   */\n  function update$1() {\n    return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n  }\n\n  function unregister(name) {\n    styleManager.remove(name);\n    return delete __TAG_IMPL[name]\n  }\n\n  var version = 'v3.9.4';\n\n  var core = /*#__PURE__*/Object.freeze({\n    Tag: Tag,\n    tag: tag,\n    tag2: tag2,\n    mount: mount,\n    mixin: mixin,\n    update: update$1,\n    unregister: unregister,\n    version: version\n  });\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  function componentMixin(tag$$1) {\n    var mixins = [], len = arguments.length - 1;\n    while ( len-- > 0 ) mixins[ len ] = arguments[ len + 1 ];\n\n    each(mixins, function (mix) {\n      var instance;\n      var obj;\n      var props = [];\n\n      // properties blacklisted and will not be bound to the tag instance\n      var propsBlacklist = ['init', '__proto__'];\n\n      mix = isString(mix) ? mixin(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to tag\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(tag$$1, key, descriptor);\n          } else {\n            tag$$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(tag$$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(tag$$1)(tag$$1.opts); }\n    });\n\n    return tag$$1\n  }\n\n  /**\n   * Move the position of a custom tag in its parent tag\n   * @this Tag\n   * @param   { String } tagName - key where the tag was stored\n   * @param   { Number } newPos - index where the new tag will be stored\n   */\n  function moveChild(tagName, newPos) {\n    var parent = this.parent;\n    var tags;\n    // no parent no move\n    if (!parent) { return }\n\n    tags = parent.tags[tagName];\n\n    if (isArray(tags))\n      { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n    else { arrayishAdd(parent.tags, tagName, this); }\n  }\n\n  /**\n   * Move virtual tag and all child nodes\n   * @this Tag\n   * @param { Node } src  - the node that will do the inserting\n   * @param { Tag } target - insert before this tag's first child\n   */\n  function moveVirtual(src, target) {\n    var this$1 = this;\n\n    var el = this.__.head;\n    var sib;\n    var frag = createFragment();\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      el = sib;\n      if (el === this$1.__.tail) {\n        frag.appendChild(el);\n        src.insertBefore(frag, target.__.head);\n        break\n      }\n    }\n  }\n\n  /**\n   * Convert the item looped into an object used to extend the child tag properties\n   * @param   { Object } expr - object containing the keys used to extend the children tags\n   * @param   { * } key - value to assign to the new object returned\n   * @param   { * } val - value containing the position of the item in the array\n   * @returns { Object } - new object containing the values of the original item\n   *\n   * The variables 'key' and 'val' are arbitrary.\n   * They depend on the collection type looped (Array, Object)\n   * and on the expression used on the each tag\n   *\n   */\n  function mkitem(expr, key, val) {\n    var item = {};\n    item[expr.key] = key;\n    if (expr.pos) { item[expr.pos] = val; }\n    return item\n  }\n\n  /**\n   * Unmount the redundant tags\n   * @param   { Array } items - array containing the current items to loop\n   * @param   { Array } tags - array containing all the children tags\n   */\n  function unmountRedundant(items, tags, filteredItemsCount) {\n    var i = tags.length;\n    var j = items.length - filteredItemsCount;\n\n    while (i > j) {\n      i--;\n      remove.apply(tags[i], [tags, i]);\n    }\n  }\n\n\n  /**\n   * Remove a child tag\n   * @this Tag\n   * @param   { Array } tags - tags collection\n   * @param   { Number } i - index of the tag to remove\n   */\n  function remove(tags, i) {\n    tags.splice(i, 1);\n    this.unmount();\n    arrayishRemove(this.parent, this, this.__.tagName, true);\n  }\n\n  /**\n   * Move the nested custom tags in non custom loop tags\n   * @this Tag\n   * @param   { Number } i - current position of the loop tag\n   */\n  function moveNestedTags(i) {\n    var this$1 = this;\n\n    each(Object.keys(this.tags), function (tagName) {\n      moveChild.apply(this$1.tags[tagName], [tagName, i]);\n    });\n  }\n\n  /**\n   * Move a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function move(root, nextTag, isVirtual) {\n    if (isVirtual)\n      { moveVirtual.apply(this, [root, nextTag]); }\n    else\n      { safeInsert(root, this.root, nextTag.root); }\n  }\n\n  /**\n   * Insert and mount a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function insert(root, nextTag, isVirtual) {\n    if (isVirtual)\n      { makeVirtual.apply(this, [root, nextTag]); }\n    else\n      { safeInsert(root, this.root, nextTag.root); }\n  }\n\n  /**\n   * Append a new tag into the DOM\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n  function append(root, isVirtual) {\n    if (isVirtual)\n      { makeVirtual.call(this, root); }\n    else\n      { root.appendChild(this.root); }\n  }\n\n  /**\n   * Return the value we want to use to lookup the postion of our items in the collection\n   * @param   { String }  keyAttr         - lookup string or expression\n   * @param   { * }       originalItem    - original item from the collection\n   * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n   * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n   * @returns { * } value that we will use to figure out the item position via collection.indexOf\n   */\n  function getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n    if (keyAttr) {\n      return hasKeyAttrExpr ?  tmpl(keyAttr, keyedItem) :  originalItem[keyAttr]\n    }\n\n    return originalItem\n  }\n\n  /**\n   * Manage tags having the 'each'\n   * @param   { HTMLElement } dom - DOM node we need to loop\n   * @param   { Tag } parent - parent tag instance where the dom node is contained\n   * @param   { String } expr - string contained in the 'each' attribute\n   * @returns { Object } expression object for this each loop\n   */\n  function _each(dom, parent, expr) {\n    var mustReorder = typeof getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n    var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n    var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n    var tagName = getName(dom);\n    var impl = __TAG_IMPL[tagName];\n    var parentNode = dom.parentNode;\n    var placeholder = createDOMPlaceholder();\n    var child = get(dom);\n    var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n    var tags = [];\n    var isLoop = true;\n    var innerHTML = dom.innerHTML;\n    var isAnonymous = !__TAG_IMPL[tagName];\n    var isVirtual = dom.tagName === 'VIRTUAL';\n    var oldItems = [];\n    var hasKeys;\n\n    // remove the each property from the original tag\n    removeAttribute(dom, LOOP_DIRECTIVE);\n    removeAttribute(dom, KEY_DIRECTIVE);\n\n    // parse the each expression\n    expr = tmpl.loopKeys(expr);\n    expr.isLoop = true;\n\n    if (ifExpr) { removeAttribute(dom, CONDITIONAL_DIRECTIVE); }\n\n    // insert a marked where the loop tags will be injected\n    parentNode.insertBefore(placeholder, dom);\n    parentNode.removeChild(dom);\n\n    expr.update = function updateEach() {\n      // get the new items collection\n      expr.value = tmpl(expr.val, parent);\n\n      var items = expr.value;\n      var frag = createFragment();\n      var isObject = !isArray(items) && !isString(items);\n      var root = placeholder.parentNode;\n      var tmpItems = [];\n\n      // if this DOM was removed the update here is useless\n      // this condition fixes also a weird async issue on IE in our unit test\n      if (!root) { return }\n\n      // object loop. any changes cause full redraw\n      if (isObject) {\n        hasKeys = items || false;\n        items = hasKeys ?\n          Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n      } else {\n        hasKeys = false;\n      }\n\n      // store the amount of filtered items\n      var filteredItemsCount = 0;\n\n      // loop all the new items\n      each(items, function (_item, i) {\n        i -= filteredItemsCount;\n\n        var item = !hasKeys && expr.key ? mkitem(expr, _item, i) : _item;\n\n        // skip this item because it must be filtered\n        if (ifExpr && !tmpl(ifExpr, extend(create(parent), item))) {\n          filteredItemsCount ++;\n          return\n        }\n\n        var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr);\n        // reorder only if the items are objects\n        var doReorder = mustReorder && typeof _item === T_OBJECT && !hasKeys;\n        var oldPos = oldItems.indexOf(itemId);\n        var isNew = oldPos === -1;\n        var pos = !isNew && doReorder ? oldPos : i;\n        // does a tag exist in this position?\n        var tag = tags[pos];\n        var mustAppend = i >= oldItems.length;\n        var mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n        // new tag\n        if (mustCreate) {\n          tag = createTag(impl, {\n            parent: parent,\n            isLoop: isLoop,\n            isAnonymous: isAnonymous,\n            tagName: tagName,\n            root: dom.cloneNode(isAnonymous),\n            item: item,\n            index: i,\n          }, innerHTML);\n\n          // mount the tag\n          tag.mount();\n\n          if (mustAppend)\n            { append.apply(tag, [frag || root, isVirtual]); }\n          else\n            { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n          if (!mustAppend) { oldItems.splice(i, 0, item); }\n          tags.splice(i, 0, tag);\n          if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n        } else if (pos !== i && doReorder) {\n          // move\n          if (keyAttr || contains(items, oldItems[pos])) {\n            move.apply(tag, [root, tags[i], isVirtual]);\n            // move the old tag instance\n            tags.splice(i, 0, tags.splice(pos, 1)[0]);\n            // move the old item\n            oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n          }\n\n          // update the position attribute if it exists\n          if (expr.pos) { tag[expr.pos] = i; }\n\n          // if the loop tags are not custom\n          // we need to move all their custom tags into the right position\n          if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n        }\n\n        // cache the original item to use it in the events bound to this node\n        // and its children\n        extend(tag.__, {\n          item: item,\n          index: i,\n          parent: parent\n        });\n\n        tmpItems[i] = itemId;\n\n        if (!mustCreate) { tag.update(item); }\n      });\n\n      // remove the redundant tags\n      unmountRedundant(items, tags, filteredItemsCount);\n\n      // clone the items array\n      oldItems = tmpItems.slice();\n\n      root.insertBefore(frag, placeholder);\n    };\n\n    expr.unmount = function () {\n      each(tags, function (t) { t.unmount(); });\n    };\n\n    return expr\n  }\n\n  var RefExpr = {\n    init: function init(dom, parent, attrName, attrValue) {\n      this.dom = dom;\n      this.attr = attrName;\n      this.rawValue = attrValue;\n      this.parent = parent;\n      this.hasExp = tmpl.hasExpr(attrValue);\n      return this\n    },\n    update: function update() {\n      var old = this.value;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n      var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n      this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n      // the name changed, so we need to remove it from the old key (if present)\n      if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n      if (!isBlank(this.value) && isString(this.value)) {\n        // add it to the refs of parent tag (this behavior was changed >=3.0)\n        if (customParent) { arrayishAdd(\n          customParent.refs,\n          this.value,\n          tagOrDom,\n          // use an array if it's a looped node and the ref is not an expression\n          null,\n          this.parent.__.index\n        ); }\n\n        if (this.value !== old) {\n          setAttribute(this.dom, this.attr, this.value);\n        }\n      } else {\n        removeAttribute(this.dom, this.attr);\n      }\n\n      // cache the ref bound to this dom node\n      // to reuse it in future (see also #2329)\n      if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n    },\n    unmount: function unmount() {\n      var tagOrDom = this.tag || this.dom;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n      if (!isBlank(this.value) && customParent)\n        { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    }\n  }\n\n  /**\n   * Create a new ref directive\n   * @param   { HTMLElement } dom - dom node having the ref attribute\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attrName - either 'ref' or 'data-ref'\n   * @param   { String } attrValue - value of the ref attribute\n   * @returns { RefExpr } a new RefExpr object\n   */\n  function createRefDirective(dom, tag, attrName, attrValue) {\n    return create(RefExpr).init(dom, tag, attrName, attrValue)\n  }\n\n  /**\n   * Trigger the unmount method on all the expressions\n   * @param   { Array } expressions - DOM expressions\n   */\n  function unmountAll(expressions) {\n    each(expressions, function (expr) {\n      if (expr.unmount) { expr.unmount(true); }\n      else if (expr.tagName) { expr.tag.unmount(true); }\n      else if (expr.unmount) { expr.unmount(); }\n    });\n  }\n\n  var IfExpr = {\n    init: function init(dom, tag, expr) {\n      removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n      extend(this, { tag: tag, expr: expr, stub: createDOMPlaceholder(), pristine: dom });\n      var p = dom.parentNode;\n      p.insertBefore(this.stub, dom);\n      p.removeChild(dom);\n\n      return this\n    },\n    update: function update$$1() {\n      this.value = tmpl(this.expr, this.tag);\n\n      if (this.value && !this.current) { // insert\n        this.current = this.pristine.cloneNode(true);\n        this.stub.parentNode.insertBefore(this.current, this.stub);\n        this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n      } else if (!this.value && this.current) { // remove\n        unmountAll(this.expressions);\n        if (this.current._tag) {\n          this.current._tag.unmount();\n        } else if (this.current.parentNode) {\n          this.current.parentNode.removeChild(this.current);\n        }\n        this.current = null;\n        this.expressions = [];\n      }\n\n      if (this.value) { update.call(this.tag, this.expressions); }\n    },\n    unmount: function unmount() {\n      unmountAll(this.expressions || []);\n    }\n  }\n\n  /**\n   * Create a new if directive\n   * @param   { HTMLElement } dom - if root dom node\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attr - if expression\n   * @returns { IFExpr } a new IfExpr object\n   */\n  function createIfDirective(dom, tag, attr) {\n    return create(IfExpr).init(dom, tag, attr)\n  }\n\n  /**\n   * Walk the tag DOM to detect the expressions to evaluate\n   * @this Tag\n   * @param   { HTMLElement } root - root tag where we will start digging the expressions\n   * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n   * @returns { Array } all the expressions found\n   */\n  function parseExpressions(root, mustIncludeRoot) {\n    var this$1 = this;\n\n    var expressions = [];\n\n    walkNodes(root, function (dom) {\n      var type = dom.nodeType;\n      var attr;\n      var tagImpl;\n\n      if (!mustIncludeRoot && dom === root) { return }\n\n      // text node\n      if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n        { expressions.push({dom: dom, expr: dom.nodeValue}); }\n\n      if (type !== 1) { return }\n\n      var isVirtual = dom.tagName === 'VIRTUAL';\n\n      // loop. each does it's own thing (for now)\n      if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n        if(isVirtual) { setAttribute(dom, 'loopVirtual', true); } // ignore here, handled in _each\n        expressions.push(_each(dom, this$1, attr));\n        return false\n      }\n\n      // if-attrs become the new parent. Any following expressions (either on the current\n      // element, or below it) become children of this expression.\n      if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n        expressions.push(createIfDirective(dom, this$1, attr));\n        return false\n      }\n\n      if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n        if (tmpl.hasExpr(attr)) {\n          expressions.push({\n            isRtag: true,\n            expr: attr,\n            dom: dom,\n            attrs: [].slice.call(dom.attributes)\n          });\n\n          return false\n        }\n      }\n\n      // if this is a tag, stop traversing here.\n      // we ignore the root, since parseExpressions is called while we're mounting that root\n      tagImpl = get(dom);\n\n      if(isVirtual) {\n        if(getAttribute(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n        if(!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual'))  // ok to create virtual tag\n          { tagImpl = { tmpl: dom.outerHTML }; }\n      }\n\n      if (tagImpl && (dom !== root || mustIncludeRoot)) {\n        var hasIsDirective = getAttribute(dom, IS_DIRECTIVE);\n        if(isVirtual && !hasIsDirective) { // handled in update\n          // can not remove attribute like directives\n          // so flag for removal after creation to prevent maximum stack error\n          setAttribute(dom, 'virtualized', true);\n          var tag = createTag(\n            {tmpl: dom.outerHTML},\n            {root: dom, parent: this$1},\n            dom.innerHTML\n          );\n\n          expressions.push(tag); // no return, anonymous tag, keep parsing\n        } else {\n          if (hasIsDirective && isVirtual)\n            { warn((\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\")); }\n\n          expressions.push(\n            initChild(\n              tagImpl,\n              {\n                root: dom,\n                parent: this$1\n              },\n              dom.innerHTML,\n              this$1\n            )\n          );\n          return false\n        }\n      }\n\n      // attribute expressions\n      parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n        if (!expr) { return }\n        expressions.push(expr);\n      }]);\n    });\n\n    return expressions\n  }\n\n  /**\n   * Calls `fn` for every attribute on an element. If that attr has an expression,\n   * it is also passed to fn.\n   * @this Tag\n   * @param   { HTMLElement } dom - dom node to parse\n   * @param   { Array } attrs - array of attributes\n   * @param   { Function } fn - callback to exec on any iteration\n   */\n  function parseAttributes(dom, attrs, fn) {\n    var this$1 = this;\n\n    each(attrs, function (attr) {\n      if (!attr) { return false }\n\n      var name = attr.name;\n      var bool = isBoolAttr(name);\n      var expr;\n\n      if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n        expr =  createRefDirective(dom, this$1, name, attr.value);\n      } else if (tmpl.hasExpr(attr.value)) {\n        expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n      }\n\n      fn(attr, expr);\n    });\n  }\n\n  /**\n   * Manage the mount state of a tag triggering also the observable events\n   * @this Tag\n   * @param { Boolean } value - ..of the isMounted flag\n   */\n  function setMountState(value) {\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n\n    define(this, 'isMounted', value);\n\n    if (!isAnonymous) {\n      if (value) { this.trigger('mount'); }\n      else {\n        this.trigger('unmount');\n        this.off('*');\n        this.__.wasCreated = false;\n      }\n    }\n  }\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  function componentMount(tag$$1, dom, expressions, opts) {\n    var __ = tag$$1.__;\n    var root = __.root;\n    root._tag = tag$$1; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n      if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = tag$$1; }\n      attr.expr = expr;\n      __.instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    walkAttributes(__.impl.attrs, function (k, v) { __.implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttribute(root, attr.name, attr.value); }\n    }]);\n\n    // initialiation\n    updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin(GLOBAL_MIXIN);\n\n    if (globalMixin && !__.skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          tag$$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (__.impl.fn) { __.impl.fn.call(tag$$1, opts); }\n\n    if (!__.skipAnonymous) { tag$$1.trigger('before-mount'); }\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) { return expressions.push(e); });\n\n    tag$$1.update(__.item);\n\n    if (!__.isAnonymous && !__.isInline) {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n    }\n\n    define(tag$$1, 'root', root);\n\n    // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n    if (!__.skipAnonymous && tag$$1.parent) {\n      var p = getImmediateCustomParent(tag$$1.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        setMountState.call(tag$$1, true);\n      });\n    } else {\n      // otherwise it's not a child tag we can trigger its mount event\n      setMountState.call(tag$$1, true);\n    }\n\n    tag$$1.__.wasCreated = true;\n\n    return tag$$1\n  }\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  function tagUnmount(tag, mustKeepRoot, expressions) {\n    var __ = tag.__;\n    var root = __.root;\n    var tagIndex = __TAGS_CACHE.indexOf(tag);\n    var p = root.parentNode;\n\n    if (!__.skipAnonymous) { tag.trigger('before-unmount'); }\n\n    // clear all attributes coming from the mounted tag\n    walkAttributes(__.impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX))\n        { name = name.slice(ATTRS_PREFIX.length); }\n\n      removeAttribute(root, name);\n    });\n\n    // remove all the event listeners\n    tag.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    });\n\n    // remove tag instance from the global tags cache collection\n    if (tagIndex !== -1) { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    // clean up the parent tags object\n    if (__.parent && !__.isAnonymous) {\n      var ptag = getImmediateCustomParent(__.parent);\n\n      if (__.isVirtual) {\n        Object\n          .keys(tag.tags)\n          .forEach(function (tagName) { return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]); });\n      } else {\n        arrayishRemove(ptag.tags, __.tagName, tag);\n      }\n    }\n\n    // unmount all the virtual directives\n    if (tag.__.virts) {\n      each(tag.__.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(__.instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    // clear the tag html if it's necessary\n    if (mustKeepRoot) { setInnerHTML(root, ''); }\n    // otherwise detach the root tag from the DOM\n    else if (p) { p.removeChild(root); }\n\n    // custom internal unmount function to avoid relying on the observable\n    if (__.onUnmount) { __.onUnmount(); }\n\n    // weird fix for a weird edge case #2409 and #2436\n    // some users might use your software not as you've expected\n    // so I need to add these dirty hacks to mitigate unexpected issues\n    if (!tag.isMounted) { setMountState.call(tag, true); }\n\n    setMountState.call(tag, false);\n\n    delete root._tag;\n\n    return tag\n  }\n\n  /**\n   * Tag creation factory function\n   * @constructor\n   * @param { Object } impl - it contains the tag template, and logic\n   * @param { Object } conf - tag options\n   * @param { String } innerHTML - html that eventually we need to inject in the tag\n   */\n  function createTag(impl, conf, innerHTML) {\n    if ( impl === void 0 ) impl = {};\n    if ( conf === void 0 ) conf = {};\n\n    var tag = conf.context || {};\n    var opts = extend({}, conf.opts);\n    var parent = conf.parent;\n    var isLoop = conf.isLoop;\n    var isAnonymous = !!conf.isAnonymous;\n    var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n    var item = conf.item;\n    // available only for the looped nodes\n    var index = conf.index;\n    // All attributes on the Tag when it's first parsed\n    var instAttrs = [];\n    // expressions on this type of Tag\n    var implAttrs = [];\n    var expressions = [];\n    var root = conf.root;\n    var tagName = conf.tagName || getName(root);\n    var isVirtual = tagName === 'virtual';\n    var isInline = !isVirtual && !impl.tmpl;\n    var dom;\n\n    // make this tag observable\n    if (!skipAnonymous) { observable(tag); }\n    // only call unmount if we have a valid __TAG_IMPL (has name property)\n    if (impl.name && root._tag) { root._tag.unmount(true); }\n\n    // not yet mounted\n    define(tag, 'isMounted', false);\n\n    define(tag, '__', {\n      impl: impl,\n      root: root,\n      skipAnonymous: skipAnonymous,\n      implAttrs: implAttrs,\n      isAnonymous: isAnonymous,\n      instAttrs: instAttrs,\n      innerHTML: innerHTML,\n      tagName: tagName,\n      index: index,\n      isLoop: isLoop,\n      isInline: isInline,\n      item: item,\n      parent: parent,\n      // tags having event listeners\n      // it would be better to use weak maps here but we can not introduce breaking changes now\n      listeners: [],\n      // these vars will be needed only for the virtual tags\n      virts: [],\n      wasCreated: false,\n      tail: null,\n      head: null\n    });\n\n    // create a unique id to this tag\n    // it could be handy to use it also to improve the virtual dom rendering speed\n    define(tag, '_riot_id', uid()); // base 1 allows test !t._riot_id\n    define(tag, 'root', root);\n    extend(tag, { opts: opts }, item);\n    // protect the \"tags\" and \"refs\" property from being overridden\n    define(tag, 'parent', parent || null);\n    define(tag, 'tags', {});\n    define(tag, 'refs', {});\n\n    if (isInline || isLoop && isAnonymous) {\n      dom = root;\n    } else {\n      if (!isVirtual) { root.innerHTML = ''; }\n      dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n    }\n\n    define(tag, 'update', function (data) { return componentUpdate(tag, data, expressions); });\n    define(tag, 'mixin', function () {\n      var mixins = [], len = arguments.length;\n      while ( len-- ) mixins[ len ] = arguments[ len ];\n\n      return componentMixin.apply(void 0, [ tag ].concat( mixins ));\n    });\n    define(tag, 'mount', function () { return componentMount(tag, dom, expressions, opts); });\n    define(tag, 'unmount', function (mustKeepRoot) { return tagUnmount(tag, mustKeepRoot, expressions); });\n\n    return tag\n  }\n\n  /**\n   * Mount a tag creating new Tag instance\n   * @param   { Object } root - dom node where the tag will be mounted\n   * @param   { String } tagName - name of the riot tag we want to mount\n   * @param   { Object } opts - options to pass to the Tag instance\n   * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n   * @returns { Tag } a new Tag instance\n   */\n  function mount$1(root, tagName, opts, ctx) {\n    var impl = __TAG_IMPL[tagName];\n    var implClass = __TAG_IMPL[tagName].class;\n    var context = ctx || (implClass ? create(implClass.prototype) : {});\n    // cache the inner HTML to fix #855\n    var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n    var conf = extend({ root: root, opts: opts, context: context }, { parent: opts ? opts.parent : null });\n    var tag;\n\n    if (impl && root) { tag = createTag(impl, conf, innerHTML); }\n\n    if (tag && tag.mount) {\n      tag.mount(true);\n      // add this tag to the virtualDom variable\n      if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n    }\n\n    return tag\n  }\n\n\n\n  var tags = /*#__PURE__*/Object.freeze({\n    arrayishAdd: arrayishAdd,\n    getTagName: getName,\n    inheritParentProps: inheritParentProps,\n    mountTo: mount$1,\n    selectTags: query,\n    arrayishRemove: arrayishRemove,\n    getTag: get,\n    initChildTag: initChild,\n    moveChildTag: moveChild,\n    makeReplaceVirtual: makeReplaceVirtual,\n    getImmediateCustomParentTag: getImmediateCustomParent,\n    makeVirtual: makeVirtual,\n    moveVirtual: moveVirtual,\n    unmountAll: unmountAll,\n    createIfDirective: createIfDirective,\n    createRefDirective: createRefDirective\n  });\n\n  /**\n   * Riot public api\n   */\n  var settings$1 = settings;\n  var util = {\n    tmpl: tmpl,\n    brackets: brackets,\n    styleManager: styleManager,\n    vdom: __TAGS_CACHE,\n    styleNode: styleManager.styleNode,\n    // export the riot internal utils as well\n    dom: dom,\n    check: check,\n    misc: misc,\n    tags: tags\n  };\n\n  // export the core props/methods\n  var Tag$1 = Tag;\n  var tag$1 = tag;\n  var tag2$1 = tag2;\n  var mount$2 = mount;\n  var mixin$1 = mixin;\n  var update$2 = update$1;\n  var unregister$1 = unregister;\n  var version$1 = version;\n  var observable$1 = observable;\n\n  var riot$1 = extend({}, core, {\n    observable: observable,\n    settings: settings$1,\n    util: util,\n  })\n\n  exports.settings = settings$1;\n  exports.util = util;\n  exports.Tag = Tag$1;\n  exports.tag = tag$1;\n  exports.tag2 = tag2$1;\n  exports.mount = mount$2;\n  exports.mixin = mixin$1;\n  exports.update = update$2;\n  exports.unregister = unregister$1;\n  exports.version = version$1;\n  exports.observable = observable$1;\n  exports.default = riot$1;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmpzP2ZhNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxHQUFHLEdBQUc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZDQUE2QztBQUNwRDtBQUNBLE9BQU8sNkJBQTZCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBLE9BQU8sT0FBTyxvQ0FBb0M7O0FBRWxEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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MEI7O0FBRTFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBOztBQUVBLDJDQUEyQyxnREFBZ0QsRUFBRTtBQUM3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsc0NBQXNDLG9EQUFvRCxFQUFFO0FBQzVGLG9EQUFvRCxtREFBbUQsRUFBRTs7QUFFekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUEyQyxHQUFHLG9DQUFvQztBQUN6Rzs7QUFFQSx1QkFBdUIsd0NBQXdDOztBQUUvRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0JBQXdCO0FBQ2pFOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELGNBQWM7O0FBRTlELENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgdjMuOS40LCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5yaW90ID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFNob3J0ZXIgYW5kIGZhc3Qgd2F5IHRvIHNlbGVjdCBhIHNpbmdsZSBub2RlIGluIHRoZSBET01cbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBzZWxlY3RvciAtIHVuaXF1ZSBkb20gc2VsZWN0b3JcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBjdHggLSBET00gbm9kZSB3aGVyZSB0aGUgdGFyZ2V0IG9mIG91ciBzZWFyY2ggd2lsbCBpcyBsb2NhdGVkXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZG9tIG5vZGUgZm91bmRcbiAgICovXG4gIGZ1bmN0aW9uICQoc2VsZWN0b3IsIGN0eCkge1xuICAgIHJldHVybiAoY3R4IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICB9XG5cbiAgdmFyXG4gICAgLy8gYmUgYXdhcmUsIGludGVybmFsIHVzYWdlXG4gICAgLy8gQVRURU5USU9OOiBwcmVmaXggdGhlIGdsb2JhbCBkeW5hbWljIHZhcmlhYmxlcyB3aXRoIGBfX2BcbiAgICAvLyB0YWdzIGluc3RhbmNlcyBjYWNoZVxuICAgIF9fVEFHU19DQUNIRSA9IFtdLFxuICAgIC8vIHRhZ3MgaW1wbGVtZW50YXRpb24gY2FjaGVcbiAgICBfX1RBR19JTVBMID0ge30sXG4gICAgWUlFTERfVEFHID0gJ3lpZWxkJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0XG4gICAgICovXG4gICAgR0xPQkFMX01JWElOID0gJ19fZ2xvYmFsX21peGluJyxcblxuICAgIC8vIHJpb3Qgc3BlY2lmaWMgcHJlZml4ZXMgb3IgYXR0cmlidXRlc1xuICAgIEFUVFJTX1BSRUZJWCA9ICdyaW90LScsXG5cbiAgICAvLyBSaW90IERpcmVjdGl2ZXNcbiAgICBSRUZfRElSRUNUSVZFUyA9IFsncmVmJywgJ2RhdGEtcmVmJ10sXG4gICAgSVNfRElSRUNUSVZFID0gJ2RhdGEtaXMnLFxuICAgIENPTkRJVElPTkFMX0RJUkVDVElWRSA9ICdpZicsXG4gICAgTE9PUF9ESVJFQ1RJVkUgPSAnZWFjaCcsXG4gICAgTE9PUF9OT19SRU9SREVSX0RJUkVDVElWRSA9ICduby1yZW9yZGVyJyxcbiAgICBTSE9XX0RJUkVDVElWRSA9ICdzaG93JyxcbiAgICBISURFX0RJUkVDVElWRSA9ICdoaWRlJyxcbiAgICBLRVlfRElSRUNUSVZFID0gJ2tleScsXG4gICAgUklPVF9FVkVOVFNfS0VZID0gJ19fcmlvdC1ldmVudHNfXycsXG5cbiAgICAvLyBmb3IgdHlwZW9mID09ICcnIGNvbXBhcmlzb25zXG4gICAgVF9TVFJJTkcgPSAnc3RyaW5nJyxcbiAgICBUX09CSkVDVCA9ICdvYmplY3QnLFxuICAgIFRfVU5ERUYgID0gJ3VuZGVmaW5lZCcsXG4gICAgVF9GVU5DVElPTiA9ICdmdW5jdGlvbicsXG5cbiAgICBYTElOS19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIFhMSU5LX1JFR0VYID0gL154bGluazooXFx3KykvLFxuXG4gICAgV0lOID0gdHlwZW9mIHdpbmRvdyA9PT0gVF9VTkRFRiA/IHVuZGVmaW5lZCA6IHdpbmRvdyxcblxuICAgIC8vIHNwZWNpYWwgbmF0aXZlIHRhZ3MgdGhhdCBjYW5ub3QgYmUgdHJlYXRlZCBsaWtlIHRoZSBvdGhlcnNcbiAgICBSRV9TUEVDSUFMX1RBR1MgPSAvXig/OnQoPzpib2R5fGhlYWR8Zm9vdHxbcmhkXSl8Y2FwdGlvbnxjb2woPzpncm91cCk/fG9wdCg/Omlvbnxncm91cCkpJC8sXG4gICAgUkVfU1BFQ0lBTF9UQUdTX05PX09QVElPTiA9IC9eKD86dCg/OmJvZHl8aGVhZHxmb290fFtyaGRdKXxjYXB0aW9ufGNvbCg/Omdyb3VwKT8pJC8sXG4gICAgUkVfRVZFTlRTX1BSRUZJWCA9IC9eb24vLFxuICAgIFJFX0hUTUxfQVRUUlMgPSAvKFstXFx3XSspID89ID8oPzpcIihbXlwiXSopfCcoW14nXSopfCh7W159XSp9KSkvZyxcbiAgICAvLyBzb21lIERPTSBhdHRyaWJ1dGVzIG11c3QgYmUgbm9ybWFsaXplZFxuICAgIENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVMgPSB7XG4gICAgICAndmlld2JveCc6ICd2aWV3Qm94JyxcbiAgICAgICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIGJvb2xlYW4gSFRNTCBhdHRyaWJ1dGVzIGluIHRoZSByaW90IHRhZyBkZWZpbml0aW9uLlxuICAgICAqIFdpdGggYSBsb25nIGxpc3QgbGlrZSB0aGlzLCBhIHJlZ2V4IGlzIGZhc3RlciB0aGFuIGBbXS5pbmRleE9mYCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgICAqIEBjb25zdCB7UmVnRXhwfVxuICAgICAqIEBzZWUgW2F0dHJpYnV0ZXMubWRdKGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L2NvbXBpbGVyL2Jsb2IvZGV2L2RvYy9hdHRyaWJ1dGVzLm1kKVxuICAgICAqL1xuICAgIFJFX0JPT0xfQVRUUlMgPSAvXig/OmRpc2FibGVkfGNoZWNrZWR8cmVhZG9ubHl8cmVxdWlyZWR8YWxsb3dmdWxsc2NyZWVufGF1dG8oPzpmb2N1c3xwbGF5KXxjb21wYWN0fGNvbnRyb2xzfGRlZmF1bHR8Zm9ybW5vdmFsaWRhdGV8aGlkZGVufGlzbWFwfGl0ZW1zY29wZXxsb29wfG11bHRpcGxlfG11dGVkfG5vKD86cmVzaXplfHNoYWRlfHZhbGlkYXRlfHdyYXApP3xvcGVufHJldmVyc2VkfHNlYW1sZXNzfHNlbGVjdGVkfHNvcnRhYmxlfHRydWVzcGVlZHx0eXBlbXVzdG1hdGNoKSQvLFxuICAgIC8vIHZlcnNpb24jIGZvciBJRSA4LTExLCAwIGZvciBvdGhlcnNcbiAgICBJRV9WRVJTSU9OID0gKFdJTiAmJiBXSU4uZG9jdW1lbnQgfHwge30pLmRvY3VtZW50TW9kZSB8IDA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGdlbmVyaWMgRE9NIG5vZGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBuYW1lIC0gbmFtZSBvZiB0aGUgRE9NIG5vZGUgd2Ugd2FudCB0byBjcmVhdGVcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSBET00gbm9kZSBqdXN0IGNyZWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ3N2ZycgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBuYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW55IERPTSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byB1cGRhdGVcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIHdhbnQgdG8gc2V0XG4gICAqIEBwYXJhbSB7IFN0cmluZyB9IHZhbCAtIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNldFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKGRvbSwgbmFtZSwgdmFsKSB7XG4gICAgdmFyIHhsaW5rID0gWExJTktfUkVHRVguZXhlYyhuYW1lKTtcbiAgICBpZiAoeGxpbmsgJiYgeGxpbmtbMV0pXG4gICAgICB7IGRvbS5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgeGxpbmtbMV0sIHZhbCk7IH1cbiAgICBlbHNlXG4gICAgICB7IGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsKTsgfVxuICB9XG5cbiAgdmFyIHN0eWxlTm9kZTtcbiAgLy8gQ3JlYXRlIGNhY2hlIGFuZCBzaG9ydGN1dCB0byB0aGUgY29ycmVjdCBwcm9wZXJ0eVxuICB2YXIgY3NzVGV4dFByb3A7XG4gIHZhciBieU5hbWUgPSB7fTtcbiAgdmFyIG5lZWRzSW5qZWN0ID0gZmFsc2U7XG5cbiAgLy8gc2tpcCB0aGUgZm9sbG93aW5nIGNvZGUgb24gdGhlIHNlcnZlclxuICBpZiAoV0lOKSB7XG4gICAgc3R5bGVOb2RlID0gKChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgc3R5bGUgZWxlbWVudCB3aXRoIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgIHZhciBuZXdOb2RlID0gbWFrZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAvLyByZXBsYWNlIGFueSB1c2VyIG5vZGUgb3IgaW5zZXJ0IHRoZSBuZXcgb25lIGludG8gdGhlIGhlYWRcbiAgICAgIHZhciB1c2VyTm9kZSA9ICQoJ3N0eWxlW3R5cGU9cmlvdF0nKTtcblxuICAgICAgc2V0QXR0cmlidXRlKG5ld05vZGUsICd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKHVzZXJOb2RlKSB7XG4gICAgICAgIGlmICh1c2VyTm9kZS5pZCkgeyBuZXdOb2RlLmlkID0gdXNlck5vZGUuaWQ7IH1cbiAgICAgICAgdXNlck5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgdXNlck5vZGUpO1xuICAgICAgfSBlbHNlIHsgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChuZXdOb2RlKTsgfVxuXG4gICAgICByZXR1cm4gbmV3Tm9kZVxuICAgIH0pKSgpO1xuICAgIGNzc1RleHRQcm9wID0gc3R5bGVOb2RlLnN0eWxlU2hlZXQ7XG4gIH1cblxuICAvKipcbiAgICogT2JqZWN0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGluamVjdCBhbmQgbWFuYWdlIHRoZSBjc3Mgb2YgZXZlcnkgdGFnIGluc3RhbmNlXG4gICAqL1xuICB2YXIgc3R5bGVNYW5hZ2VyID0ge1xuICAgIHN0eWxlTm9kZTogc3R5bGVOb2RlLFxuICAgIC8qKlxuICAgICAqIFNhdmUgYSB0YWcgc3R5bGUgdG8gYmUgbGF0ZXIgaW5qZWN0ZWQgaW50byBET01cbiAgICAgKiBAcGFyYW0geyBTdHJpbmcgfSBjc3MgLSBjc3Mgc3RyaW5nXG4gICAgICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIGlmIGl0J3MgcGFzc2VkIHdlIHdpbGwgbWFwIHRoZSBjc3MgdG8gYSB0YWduYW1lXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoY3NzLCBuYW1lKSB7XG4gICAgICBieU5hbWVbbmFtZV0gPSBjc3M7XG4gICAgICBuZWVkc0luamVjdCA9IHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbmplY3QgYWxsIHByZXZpb3VzbHkgc2F2ZWQgdGFnIHN0eWxlcyBpbnRvIERPTVxuICAgICAqIGlubmVySFRNTCBzZWVtcyBzbG93OiBodHRwOi8vanNwZXJmLmNvbS9yaW90LWluc2VydC1zdHlsZVxuICAgICAqL1xuICAgIGluamVjdDogZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgICAgaWYgKCFXSU4gfHwgIW5lZWRzSW5qZWN0KSB7IHJldHVybiB9XG4gICAgICBuZWVkc0luamVjdCA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gT2JqZWN0LmtleXMoYnlOYW1lKVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBieU5hbWVba107IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoY3NzVGV4dFByb3ApIHsgY3NzVGV4dFByb3AuY3NzVGV4dCA9IHN0eWxlOyB9XG4gICAgICBlbHNlIHsgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlOyB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHRhZyBzdHlsZSBvZiBpbmplY3RlZCBET00gbGF0ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSByZWdpc3RlcmVkIHRhZ25hbWVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICBkZWxldGUgYnlOYW1lW25hbWVdO1xuICAgICAgbmVlZHNJbmplY3QgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcmlvdCB0ZW1wbGF0ZSBlbmdpbmVcbiAgICogQHZlcnNpb24gdjMuMC44XG4gICAqL1xuXG4gIHZhciBza2lwUmVnZXggPSAoZnVuY3Rpb24gKCkgeyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIHZhciBiZWZvcmVSZUNoYXJzID0gJ1t7KCw7Oj89fCYhXn4+JSovJztcblxuICAgIHZhciBiZWZvcmVSZVdvcmRzID0gW1xuICAgICAgJ2Nhc2UnLFxuICAgICAgJ2RlZmF1bHQnLFxuICAgICAgJ2RvJyxcbiAgICAgICdlbHNlJyxcbiAgICAgICdpbicsXG4gICAgICAnaW5zdGFuY2VvZicsXG4gICAgICAncHJlZml4JyxcbiAgICAgICdyZXR1cm4nLFxuICAgICAgJ3R5cGVvZicsXG4gICAgICAndm9pZCcsXG4gICAgICAneWllbGQnXG4gICAgXTtcblxuICAgIHZhciB3b3Jkc0xhc3RDaGFyID0gYmVmb3JlUmVXb3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKHMsIHcpIHtcbiAgICAgIHJldHVybiBzICsgdy5zbGljZSgtMSlcbiAgICB9LCAnJyk7XG5cbiAgICB2YXIgUkVfUkVHRVggPSAvXlxcLyg/PVteKj4vXSlbXlsvXFxcXF0qKD86KD86XFxcXC58XFxbKD86XFxcXC58W15cXF1cXFxcXSopKlxcXSlbXltcXFxcL10qKSo/XFwvW2dpbXV5XSovO1xuICAgIHZhciBSRV9WTl9DSEFSID0gL1skXFx3XS87XG5cbiAgICBmdW5jdGlvbiBwcmV2IChjb2RlLCBwb3MpIHtcbiAgICAgIHdoaWxlICgtLXBvcyA+PSAwICYmIC9cXHMvLnRlc3QoY29kZVtwb3NdKSl7IH1cbiAgICAgIHJldHVybiBwb3NcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfc2tpcFJlZ2V4IChjb2RlLCBzdGFydCkge1xuXG4gICAgICB2YXIgcmUgPSAvLiovZztcbiAgICAgIHZhciBwb3MgPSByZS5sYXN0SW5kZXggPSBzdGFydCsrO1xuICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhjb2RlKVswXS5tYXRjaChSRV9SRUdFWCk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgbmV4dCA9IHBvcyArIG1hdGNoWzBdLmxlbmd0aDtcblxuICAgICAgICBwb3MgPSBwcmV2KGNvZGUsIHBvcyk7XG4gICAgICAgIHZhciBjID0gY29kZVtwb3NdO1xuXG4gICAgICAgIGlmIChwb3MgPCAwIHx8IH5iZWZvcmVSZUNoYXJzLmluZGV4T2YoYykpIHtcbiAgICAgICAgICByZXR1cm4gbmV4dFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09ICcuJykge1xuXG4gICAgICAgICAgaWYgKGNvZGVbcG9zIC0gMV0gPT09ICcuJykge1xuICAgICAgICAgICAgc3RhcnQgPSBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcblxuICAgICAgICAgIGlmIChjb2RlWy0tcG9zXSAhPT0gYyB8fFxuICAgICAgICAgICAgICAocG9zID0gcHJldihjb2RlLCBwb3MpKSA8IDAgfHxcbiAgICAgICAgICAgICAgIVJFX1ZOX0NIQVIudGVzdChjb2RlW3Bvc10pKSB7XG4gICAgICAgICAgICBzdGFydCA9IG5leHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAofndvcmRzTGFzdENoYXIuaW5kZXhPZihjKSkge1xuXG4gICAgICAgICAgdmFyIGVuZCA9IHBvcyArIDE7XG5cbiAgICAgICAgICB3aGlsZSAoLS1wb3MgPj0gMCAmJiBSRV9WTl9DSEFSLnRlc3QoY29kZVtwb3NdKSl7IH1cbiAgICAgICAgICBpZiAofmJlZm9yZVJlV29yZHMuaW5kZXhPZihjb2RlLnNsaWNlKHBvcyArIDEsIGVuZCkpKSB7XG4gICAgICAgICAgICBzdGFydCA9IG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydFxuICAgIH1cblxuICAgIHJldHVybiBfc2tpcFJlZ2V4XG5cbiAgfSkoKTtcblxuICAvKipcbiAgICogcmlvdC51dGlsLmJyYWNrZXRzXG4gICAqXG4gICAqIC0gYGJyYWNrZXRzICAgIGAgLSBSZXR1cm5zIGEgc3RyaW5nIG9yIHJlZ2V4IGJhc2VkIG9uIGl0cyBwYXJhbWV0ZXJcbiAgICogLSBgYnJhY2tldHMuc2V0YCAtIENoYW5nZSB0aGUgY3VycmVudCByaW90IGJyYWNrZXRzXG4gICAqXG4gICAqIEBtb2R1bGVcbiAgICovXG5cbiAgLyogZ2xvYmFsIHJpb3QgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgYnJhY2tldHMgPSAoZnVuY3Rpb24gKFVOREVGKSB7XG5cbiAgICB2YXJcbiAgICAgIFJFR0xPQiA9ICdnJyxcblxuICAgICAgUl9NTENPTU1TID0gL1xcL1xcKlteKl0qXFwqKyg/OlteKlxcL11bXipdKlxcKispKlxcLy9nLFxuXG4gICAgICBSX1NUUklOR1MgPSAvXCJbXlwiXFxcXF0qKD86XFxcXFtcXFNcXHNdW15cIlxcXFxdKikqXCJ8J1teJ1xcXFxdKig/OlxcXFxbXFxTXFxzXVteJ1xcXFxdKikqJ3xgW15gXFxcXF0qKD86XFxcXFtcXFNcXHNdW15gXFxcXF0qKSpgL2csXG5cbiAgICAgIFNfUUJMT0NLUyA9IFJfU1RSSU5HUy5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAvKD86XFxicmV0dXJuXFxzK3woPzpbJFxcd1xcKVxcXV18XFwrXFwrfC0tKVxccyooXFwvKSg/IVsqXFwvXSkpLy5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAvXFwvKD89W14qXFwvXSlbXltcXC9cXFxcXSooPzooPzpcXFsoPzpcXFxcLnxbXlxcXVxcXFxdKikqXFxdfFxcXFwuKVteW1xcL1xcXFxdKikqPyhbXjxdXFwvKVtnaW1dKi8uc291cmNlLFxuXG4gICAgICBVTlNVUFBPUlRFRCA9IFJlZ0V4cCgnW1xcXFwnICsgJ3gwMC1cXFxceDFGPD5hLXpBLVowLTlcXCdcIiw7XFxcXFxcXFxdJyksXG5cbiAgICAgIE5FRURfRVNDQVBFID0gLyg/PVtbXFxdKCkqKz8uXiR8XSkvZyxcblxuICAgICAgU19RQkxPQ0syID0gUl9TVFJJTkdTLnNvdXJjZSArICd8JyArIC8oXFwvKSg/IVsqXFwvXSkvLnNvdXJjZSxcblxuICAgICAgRklOREJSQUNFUyA9IHtcbiAgICAgICAgJygnOiBSZWdFeHAoJyhbKCldKXwnICAgKyBTX1FCTE9DSzIsIFJFR0xPQiksXG4gICAgICAgICdbJzogUmVnRXhwKCcoW1tcXFxcXV0pfCcgKyBTX1FCTE9DSzIsIFJFR0xPQiksXG4gICAgICAgICd7JzogUmVnRXhwKCcoW3t9XSl8JyAgICsgU19RQkxPQ0syLCBSRUdMT0IpXG4gICAgICB9LFxuXG4gICAgICBERUZBVUxUID0gJ3sgfSc7XG5cbiAgICB2YXIgX3BhaXJzID0gW1xuICAgICAgJ3snLCAnfScsXG4gICAgICAneycsICd9JyxcbiAgICAgIC97W159XSp9LyxcbiAgICAgIC9cXFxcKFt7fV0pL2csXG4gICAgICAvXFxcXCh7KXx7L2csXG4gICAgICBSZWdFeHAoJ1xcXFxcXFxcKH0pfChbWyh7XSl8KH0pfCcgKyBTX1FCTE9DSzIsIFJFR0xPQiksXG4gICAgICBERUZBVUxULFxuICAgICAgL15cXHMqe1xcXj9cXHMqKFskXFx3XSspKD86XFxzKixcXHMqKFxcUyspKT9cXHMraW5cXHMrKFxcUy4qKVxccyp9LyxcbiAgICAgIC8oXnxbXlxcXFxdKXs9W1xcU1xcc10qP30vXG4gICAgXTtcblxuICAgIHZhclxuICAgICAgY2FjaGVkQnJhY2tldHMgPSBVTkRFRixcbiAgICAgIF9yZWdleCxcbiAgICAgIF9jYWNoZSA9IFtdLFxuICAgICAgX3NldHRpbmdzO1xuXG4gICAgZnVuY3Rpb24gX2xvb3BiYWNrIChyZSkgeyByZXR1cm4gcmUgfVxuXG4gICAgZnVuY3Rpb24gX3Jld3JpdGUgKHJlLCBicCkge1xuICAgICAgaWYgKCFicCkgeyBicCA9IF9jYWNoZTsgfVxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICAgIHJlLnNvdXJjZS5yZXBsYWNlKC97L2csIGJwWzJdKS5yZXBsYWNlKC99L2csIGJwWzNdKSwgcmUuZ2xvYmFsID8gUkVHTE9CIDogJydcbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlIChwYWlyKSB7XG4gICAgICBpZiAocGFpciA9PT0gREVGQVVMVCkgeyByZXR1cm4gX3BhaXJzIH1cblxuICAgICAgdmFyIGFyciA9IHBhaXIuc3BsaXQoJyAnKTtcblxuICAgICAgaWYgKGFyci5sZW5ndGggIT09IDIgfHwgVU5TVVBQT1JURUQudGVzdChwYWlyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGJyYWNrZXRzIFwiJyArIHBhaXIgKyAnXCInKVxuICAgICAgfVxuICAgICAgYXJyID0gYXJyLmNvbmNhdChwYWlyLnJlcGxhY2UoTkVFRF9FU0NBUEUsICdcXFxcJykuc3BsaXQoJyAnKSk7XG5cbiAgICAgIGFycls0XSA9IF9yZXdyaXRlKGFyclsxXS5sZW5ndGggPiAxID8gL3tbXFxTXFxzXSo/fS8gOiBfcGFpcnNbNF0sIGFycik7XG4gICAgICBhcnJbNV0gPSBfcmV3cml0ZShwYWlyLmxlbmd0aCA+IDMgPyAvXFxcXCh7fH0pL2cgOiBfcGFpcnNbNV0sIGFycik7XG4gICAgICBhcnJbNl0gPSBfcmV3cml0ZShfcGFpcnNbNl0sIGFycik7XG4gICAgICBhcnJbN10gPSBSZWdFeHAoJ1xcXFxcXFxcKCcgKyBhcnJbM10gKyAnKXwoW1soe10pfCgnICsgYXJyWzNdICsgJyl8JyArIFNfUUJMT0NLMiwgUkVHTE9CKTtcbiAgICAgIGFycls4XSA9IHBhaXI7XG4gICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2JyYWNrZXRzIChyZU9ySWR4KSB7XG4gICAgICByZXR1cm4gcmVPcklkeCBpbnN0YW5jZW9mIFJlZ0V4cCA/IF9yZWdleChyZU9ySWR4KSA6IF9jYWNoZVtyZU9ySWR4XVxuICAgIH1cblxuICAgIF9icmFja2V0cy5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChzdHIsIHRtcGwsIF9icCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IF9icCBpcyBmb3IgdGhlIGNvbXBpbGVyXG4gICAgICBpZiAoIV9icCkgeyBfYnAgPSBfY2FjaGU7IH1cblxuICAgICAgdmFyXG4gICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBpc2V4cHIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBwb3MsXG4gICAgICAgIHJlID0gX2JwWzZdO1xuXG4gICAgICB2YXIgcWJsb2NrcyA9IFtdO1xuICAgICAgdmFyIHByZXZTdHIgPSAnJztcbiAgICAgIHZhciBtYXJrLCBsYXN0SW5kZXg7XG5cbiAgICAgIGlzZXhwciA9IHN0YXJ0ID0gcmUubGFzdEluZGV4ID0gMDtcblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoc3RyKSkpIHtcblxuICAgICAgICBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHBvcyA9IG1hdGNoLmluZGV4O1xuXG4gICAgICAgIGlmIChpc2V4cHIpIHtcblxuICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuXG4gICAgICAgICAgICB2YXIgY2ggPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIHZhciByZWNoID0gRklOREJSQUNFU1tjaF07XG4gICAgICAgICAgICB2YXIgaXggPSAxO1xuXG4gICAgICAgICAgICByZWNoLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWNoLmV4ZWMoc3RyKSkpIHtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSBjaCkgeyArK2l4OyB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIS0taXgpIHsgYnJlYWsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2gubGFzdEluZGV4ID0gcHVzaFFCbG9jayhtYXRjaC5pbmRleCwgcmVjaC5sYXN0SW5kZXgsIG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmUubGFzdEluZGV4ID0gaXggPyBzdHIubGVuZ3RoIDogcmVjaC5sYXN0SW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghbWF0Y2hbM10pIHtcbiAgICAgICAgICAgIHJlLmxhc3RJbmRleCA9IHB1c2hRQmxvY2socG9zLCBsYXN0SW5kZXgsIG1hdGNoWzRdKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgICAgIHVuZXNjYXBlU3RyKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gICAgICAgICAgc3RhcnQgPSByZS5sYXN0SW5kZXg7XG4gICAgICAgICAgcmUgPSBfYnBbNiArIChpc2V4cHIgXj0gMSldO1xuICAgICAgICAgIHJlLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHIgJiYgc3RhcnQgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHVuZXNjYXBlU3RyKHN0ci5zbGljZShzdGFydCkpO1xuICAgICAgfVxuXG4gICAgICBwYXJ0cy5xYmxvY2tzID0gcWJsb2NrcztcblxuICAgICAgcmV0dXJuIHBhcnRzXG5cbiAgICAgIGZ1bmN0aW9uIHVuZXNjYXBlU3RyIChzKSB7XG4gICAgICAgIGlmIChwcmV2U3RyKSB7XG4gICAgICAgICAgcyA9IHByZXZTdHIgKyBzO1xuICAgICAgICAgIHByZXZTdHIgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG1wbCB8fCBpc2V4cHIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHMgJiYgcy5yZXBsYWNlKF9icFs1XSwgJyQxJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcHVzaFFCbG9jayhfcG9zLCBfbGFzdEluZGV4LCBzbGFzaCkgeyAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgaWYgKHNsYXNoKSB7XG4gICAgICAgICAgX2xhc3RJbmRleCA9IHNraXBSZWdleChzdHIsIF9wb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRtcGwgJiYgX2xhc3RJbmRleCA+IF9wb3MgKyAyKSB7XG4gICAgICAgICAgbWFyayA9ICdcXHUyMDU3JyArIHFibG9ja3MubGVuZ3RoICsgJ34nO1xuICAgICAgICAgIHFibG9ja3MucHVzaChzdHIuc2xpY2UoX3BvcywgX2xhc3RJbmRleCkpO1xuICAgICAgICAgIHByZXZTdHIgKz0gc3RyLnNsaWNlKHN0YXJ0LCBfcG9zKSArIG1hcms7XG4gICAgICAgICAgc3RhcnQgPSBfbGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbGFzdEluZGV4XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9icmFja2V0cy5oYXNFeHByID0gZnVuY3Rpb24gaGFzRXhwciAoc3RyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlWzRdLnRlc3Qoc3RyKVxuICAgIH07XG5cbiAgICBfYnJhY2tldHMubG9vcEtleXMgPSBmdW5jdGlvbiBsb29wS2V5cyAoZXhwcikge1xuICAgICAgdmFyIG0gPSBleHByLm1hdGNoKF9jYWNoZVs5XSk7XG5cbiAgICAgIHJldHVybiBtXG4gICAgICAgID8geyBrZXk6IG1bMV0sIHBvczogbVsyXSwgdmFsOiBfY2FjaGVbMF0gKyBtWzNdLnRyaW0oKSArIF9jYWNoZVsxXSB9XG4gICAgICAgIDogeyB2YWw6IGV4cHIudHJpbSgpIH1cbiAgICB9O1xuXG4gICAgX2JyYWNrZXRzLmFycmF5ID0gZnVuY3Rpb24gYXJyYXkgKHBhaXIpIHtcbiAgICAgIHJldHVybiBwYWlyID8gX2NyZWF0ZShwYWlyKSA6IF9jYWNoZVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfcmVzZXQgKHBhaXIpIHtcbiAgICAgIGlmICgocGFpciB8fCAocGFpciA9IERFRkFVTFQpKSAhPT0gX2NhY2hlWzhdKSB7XG4gICAgICAgIF9jYWNoZSA9IF9jcmVhdGUocGFpcik7XG4gICAgICAgIF9yZWdleCA9IHBhaXIgPT09IERFRkFVTFQgPyBfbG9vcGJhY2sgOiBfcmV3cml0ZTtcbiAgICAgICAgX2NhY2hlWzldID0gX3JlZ2V4KF9wYWlyc1s5XSk7XG4gICAgICB9XG4gICAgICBjYWNoZWRCcmFja2V0cyA9IHBhaXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3NldFNldHRpbmdzIChvKSB7XG4gICAgICB2YXIgYjtcblxuICAgICAgbyA9IG8gfHwge307XG4gICAgICBiID0gby5icmFja2V0cztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAnYnJhY2tldHMnLCB7XG4gICAgICAgIHNldDogX3Jlc2V0LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlZEJyYWNrZXRzIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgX3NldHRpbmdzID0gbztcbiAgICAgIF9yZXNldChiKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2JyYWNrZXRzLCAnc2V0dGluZ3MnLCB7XG4gICAgICBzZXQ6IF9zZXRTZXR0aW5ncyxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3NldHRpbmdzIH1cbiAgICB9KTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpbiB0aGUgYnJvd3NlciByaW90IGlzIGFsd2F5cyBpbiB0aGUgc2NvcGUgKi9cbiAgICBfYnJhY2tldHMuc2V0dGluZ3MgPSB0eXBlb2YgcmlvdCAhPT0gJ3VuZGVmaW5lZCcgJiYgcmlvdC5zZXR0aW5ncyB8fCB7fTtcbiAgICBfYnJhY2tldHMuc2V0ID0gX3Jlc2V0O1xuICAgIF9icmFja2V0cy5za2lwUmVnZXggPSBza2lwUmVnZXg7XG5cbiAgICBfYnJhY2tldHMuUl9TVFJJTkdTID0gUl9TVFJJTkdTO1xuICAgIF9icmFja2V0cy5SX01MQ09NTVMgPSBSX01MQ09NTVM7XG4gICAgX2JyYWNrZXRzLlNfUUJMT0NLUyA9IFNfUUJMT0NLUztcbiAgICBfYnJhY2tldHMuU19RQkxPQ0syID0gU19RQkxPQ0syO1xuXG4gICAgcmV0dXJuIF9icmFja2V0c1xuXG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgdG1wbFxuICAgKlxuICAgKiB0bXBsICAgICAgICAgIC0gUm9vdCBmdW5jdGlvbiwgcmV0dXJucyB0aGUgdGVtcGxhdGUgdmFsdWUsIHJlbmRlciB3aXRoIGRhdGFcbiAgICogdG1wbC5oYXNFeHByICAtIFRlc3QgdGhlIGV4aXN0ZW5jZSBvZiBhIGV4cHJlc3Npb24gaW5zaWRlIGEgc3RyaW5nXG4gICAqIHRtcGwubG9vcEtleXMgLSBHZXQgdGhlIGtleXMgZm9yIGFuICdlYWNoJyBsb29wICh1c2VkIGJ5IGBfZWFjaGApXG4gICAqL1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZhciB0bXBsID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBfY2FjaGUgPSB7fTtcblxuICAgIGZ1bmN0aW9uIF90bXBsIChzdHIsIGRhdGEpIHtcbiAgICAgIGlmICghc3RyKSB7IHJldHVybiBzdHIgfVxuXG4gICAgICByZXR1cm4gKF9jYWNoZVtzdHJdIHx8IChfY2FjaGVbc3RyXSA9IF9jcmVhdGUoc3RyKSkpLmNhbGwoXG4gICAgICAgIGRhdGEsIF9sb2dFcnIuYmluZCh7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICB0bXBsOiBzdHJcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBfdG1wbC5oYXNFeHByID0gYnJhY2tldHMuaGFzRXhwcjtcblxuICAgIF90bXBsLmxvb3BLZXlzID0gYnJhY2tldHMubG9vcEtleXM7XG5cbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIF90bXBsLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IF9jYWNoZSA9IHt9OyB9O1xuXG4gICAgX3RtcGwuZXJyb3JIYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIF9sb2dFcnIgKGVyciwgY3R4KSB7XG5cbiAgICAgIGVyci5yaW90RGF0YSA9IHtcbiAgICAgICAgdGFnTmFtZTogY3R4ICYmIGN0eC5fXyAmJiBjdHguX18udGFnTmFtZSxcbiAgICAgICAgX3Jpb3RfaWQ6IGN0eCAmJiBjdHguX3Jpb3RfaWQgIC8vZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIH07XG5cbiAgICAgIGlmIChfdG1wbC5lcnJvckhhbmRsZXIpIHsgX3RtcGwuZXJyb3JIYW5kbGVyKGVycik7IH1cbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5sb2coJzwlcz4gJXMnLCBlcnIucmlvdERhdGEudGFnTmFtZSB8fCAnVW5rbm93biB0YWcnLCB0aGlzLnRtcGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlIChzdHIpIHtcbiAgICAgIHZhciBleHByID0gX2dldFRtcGwoc3RyKTtcblxuICAgICAgaWYgKGV4cHIuc2xpY2UoMCwgMTEpICE9PSAndHJ5e3JldHVybiAnKSB7IGV4cHIgPSAncmV0dXJuICcgKyBleHByOyB9XG5cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ0UnLCBleHByICsgJzsnKSAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXG4gICAgfVxuXG4gICAgdmFyIFJFX0RRVU9URSA9IC9cXHUyMDU3L2c7XG4gICAgdmFyIFJFX1FCTUFSSyA9IC9cXHUyMDU3KFxcZCspfi9nO1xuXG4gICAgZnVuY3Rpb24gX2dldFRtcGwgKHN0cikge1xuICAgICAgdmFyIHBhcnRzID0gYnJhY2tldHMuc3BsaXQoc3RyLnJlcGxhY2UoUkVfRFFVT1RFLCAnXCInKSwgMSk7XG4gICAgICB2YXIgcXN0ciA9IHBhcnRzLnFibG9ja3M7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIgfHwgcGFydHNbMF0pIHtcbiAgICAgICAgdmFyIGksIGosIGxpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSBqID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICBleHByID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAoZXhwciAmJiAoZXhwciA9IGkgJiAxXG5cbiAgICAgICAgICAgICAgPyBfcGFyc2VFeHByKGV4cHIsIDEsIHFzdHIpXG5cbiAgICAgICAgICAgICAgOiAnXCInICsgZXhwclxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG4/fFxcbi9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArXG4gICAgICAgICAgICAgICAgJ1wiJ1xuXG4gICAgICAgICAgICApKSB7IGxpc3RbaisrXSA9IGV4cHI7IH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZXhwciA9IGogPCAyID8gbGlzdFswXVxuICAgICAgICAgICAgIDogJ1snICsgbGlzdC5qb2luKCcsJykgKyAnXS5qb2luKFwiXCIpJztcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBleHByID0gX3BhcnNlRXhwcihwYXJ0c1sxXSwgMCwgcXN0cik7XG4gICAgICB9XG5cbiAgICAgIGlmIChxc3RyLmxlbmd0aCkge1xuICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKFJFX1FCTUFSSywgZnVuY3Rpb24gKF8sIHBvcykge1xuICAgICAgICAgIHJldHVybiBxc3RyW3Bvc11cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwclxuICAgIH1cblxuICAgIHZhciBSRV9DU05BTUUgPSAvXig/OigtP1tfQS1aYS16XFx4QTAtXFx4RkZdWy1cXHdcXHhBMC1cXHhGRl0qKXxcXHUyMDU3KFxcZCspfik6LztcbiAgICB2YXJcbiAgICAgIFJFX0JSRU5EID0ge1xuICAgICAgICAnKCc6IC9bKCldL2csXG4gICAgICAgICdbJzogL1tbXFxdXS9nLFxuICAgICAgICAneyc6IC9be31dL2dcbiAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBfcGFyc2VFeHByIChleHByLCBhc1RleHQsIHFzdHIpIHtcblxuICAgICAgZXhwciA9IGV4cHJcbiAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL1xcID8oW1tcXCh7fSw/XFwuOl0pXFwgPy9nLCAnJDEnKTtcblxuICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICAgIGNudCA9IDAsXG4gICAgICAgICAgbWF0Y2g7XG5cbiAgICAgICAgd2hpbGUgKGV4cHIgJiZcbiAgICAgICAgICAgICAgKG1hdGNoID0gZXhwci5tYXRjaChSRV9DU05BTUUpKSAmJlxuICAgICAgICAgICAgICAhbWF0Y2guaW5kZXhcbiAgICAgICAgICApIHtcbiAgICAgICAgICB2YXJcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGpzYixcbiAgICAgICAgICAgIHJlID0gLyx8KFtbeyhdKXwkL2c7XG5cbiAgICAgICAgICBleHByID0gUmVnRXhwLnJpZ2h0Q29udGV4dDtcbiAgICAgICAgICBrZXkgID0gbWF0Y2hbMl0gPyBxc3RyW21hdGNoWzJdXS5zbGljZSgxLCAtMSkudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKSA6IG1hdGNoWzFdO1xuXG4gICAgICAgICAgd2hpbGUgKGpzYiA9IChtYXRjaCA9IHJlLmV4ZWMoZXhwcikpWzFdKSB7IHNraXBCcmFjZXMoanNiLCByZSk7IH1cblxuICAgICAgICAgIGpzYiAgPSBleHByLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICBleHByID0gUmVnRXhwLnJpZ2h0Q29udGV4dDtcblxuICAgICAgICAgIGxpc3RbY250KytdID0gX3dyYXBFeHByKGpzYiwgMSwga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHIgPSAhY250ID8gX3dyYXBFeHByKGV4cHIsIGFzVGV4dClcbiAgICAgICAgICAgICA6IGNudCA+IDEgPyAnWycgKyBsaXN0LmpvaW4oJywnKSArICddLmpvaW4oXCIgXCIpLnRyaW0oKScgOiBsaXN0WzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHJcblxuICAgICAgZnVuY3Rpb24gc2tpcEJyYWNlcyAoY2gsIHJlKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgIG1tLFxuICAgICAgICAgIGx2ID0gMSxcbiAgICAgICAgICBpciA9IFJFX0JSRU5EW2NoXTtcblxuICAgICAgICBpci5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHdoaWxlIChtbSA9IGlyLmV4ZWMoZXhwcikpIHtcbiAgICAgICAgICBpZiAobW1bMF0gPT09IGNoKSB7ICsrbHY7IH1cbiAgICAgICAgICBlbHNlIGlmICghLS1sdikgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgcmUubGFzdEluZGV4ID0gbHYgPyBleHByLmxlbmd0aCA6IGlyLmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbm90IGJvdGhcbiAgICB2YXIgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgIEpTX0NPTlRFWFQgPSAnXCJpbiB0aGlzP3RoaXM6JyArICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyA/ICdnbG9iYWwnIDogJ3dpbmRvdycpICsgJykuJyxcbiAgICAgIEpTX1ZBUk5BTUUgPSAvWyx7XVtcXCRcXHddKyg/PTopfCheICp8W14kXFx3XFwue10pKD8hKD86dHlwZW9mfHRydWV8ZmFsc2V8bnVsbHx1bmRlZmluZWR8aW58aW5zdGFuY2VvZnxpcyg/OkZpbml0ZXxOYU4pfHZvaWR8TmFOfG5ld3xEYXRlfFJlZ0V4cHxNYXRoKSg/IVskXFx3XSkpKFskX0EtWmEtel1bJFxcd10qKS9nLFxuICAgICAgSlNfTk9QUk9QUyA9IC9eKD89KFxcLlskXFx3XSspKVxcMSg/OlteLlsoXXwkKS87XG5cbiAgICBmdW5jdGlvbiBfd3JhcEV4cHIgKGV4cHIsIGFzVGV4dCwga2V5KSB7XG4gICAgICB2YXIgdGI7XG5cbiAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoSlNfVkFSTkFNRSwgZnVuY3Rpb24gKG1hdGNoLCBwLCBtdmFyLCBwb3MsIHMpIHtcbiAgICAgICAgaWYgKG12YXIpIHtcbiAgICAgICAgICBwb3MgPSB0YiA/IDAgOiBwb3MgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAobXZhciAhPT0gJ3RoaXMnICYmIG12YXIgIT09ICdnbG9iYWwnICYmIG12YXIgIT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICBtYXRjaCA9IHAgKyAnKFwiJyArIG12YXIgKyBKU19DT05URVhUICsgbXZhcjtcbiAgICAgICAgICAgIGlmIChwb3MpIHsgdGIgPSAocyA9IHNbcG9zXSkgPT09ICcuJyB8fCBzID09PSAnKCcgfHwgcyA9PT0gJ1snOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3MpIHtcbiAgICAgICAgICAgIHRiID0gIUpTX05PUFJPUFMudGVzdChzLnNsaWNlKHBvcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGIpIHtcbiAgICAgICAgZXhwciA9ICd0cnl7cmV0dXJuICcgKyBleHByICsgJ31jYXRjaChlKXtFKGUsdGhpcyl9JztcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSkge1xuXG4gICAgICAgIGV4cHIgPSAodGJcbiAgICAgICAgICAgID8gJ2Z1bmN0aW9uKCl7JyArIGV4cHIgKyAnfS5jYWxsKHRoaXMpJyA6ICcoJyArIGV4cHIgKyAnKSdcbiAgICAgICAgICApICsgJz9cIicgKyBrZXkgKyAnXCI6XCJcIic7XG5cbiAgICAgIH0gZWxzZSBpZiAoYXNUZXh0KSB7XG5cbiAgICAgICAgZXhwciA9ICdmdW5jdGlvbih2KXsnICsgKHRiXG4gICAgICAgICAgICA/IGV4cHIucmVwbGFjZSgncmV0dXJuICcsICd2PScpIDogJ3Y9KCcgKyBleHByICsgJyknXG4gICAgICAgICAgKSArICc7cmV0dXJuIHZ8fHY9PT0wP3Y6XCJcIn0uY2FsbCh0aGlzKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByXG4gICAgfVxuXG4gICAgX3RtcGwudmVyc2lvbiA9IGJyYWNrZXRzLnZlcnNpb24gPSAndjMuMC44JztcblxuICAgIHJldHVybiBfdG1wbFxuXG4gIH0pKCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmFyIG9ic2VydmFibGUgPSBmdW5jdGlvbihlbCkge1xuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kIHRoZSBvcmlnaW5hbCBvYmplY3Qgb3IgY3JlYXRlIGEgbmV3IGVtcHR5IG9uZVxuICAgICAqIEB0eXBlIHsgT2JqZWN0IH1cbiAgICAgKi9cblxuICAgIGVsID0gZWwgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHZhcmlhYmxlc1xuICAgICAqL1xuICAgIHZhciBjYWxsYmFja3MgPSB7fSxcbiAgICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIEFwaVxuICAgICAqL1xuXG4gICAgLy8gZXh0ZW5kIHRoZSBlbCBvYmplY3QgYWRkaW5nIHRoZSBvYnNlcnZhYmxlIG1ldGhvZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlbCwge1xuICAgICAgLyoqXG4gICAgICAgKiBMaXN0ZW4gdG8gdGhlIGdpdmVuIGBldmVudGAgYW5kc1xuICAgICAgICogZXhlY3V0ZSB0aGUgYGNhbGxiYWNrYCBlYWNoIHRpbWUgYW4gZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAgICogQHBhcmFtICB7IFN0cmluZyB9IGV2ZW50IC0gZXZlbnQgaWRcbiAgICAgICAqIEBwYXJhbSAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgICAqL1xuICAgICAgb246IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHsgKGNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3NbZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTsgfVxuICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGBldmVudGAgbGlzdGVuZXJzXG4gICAgICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGV2ZW50IC0gZXZlbnQgaWRcbiAgICAgICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICAgKi9cbiAgICAgIG9mZjoge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gICAgICAgICAgaWYgKGV2ZW50ID09ICcqJyAmJiAhZm4pIHsgY2FsbGJhY2tzID0ge307IH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICB2YXIgYXJyID0gY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNiOyBjYiA9IGFyciAmJiBhcnJbaV07ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChjYiA9PSBmbikgeyBhcnIuc3BsaWNlKGktLSwgMSk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgZGVsZXRlIGNhbGxiYWNrc1tldmVudF07IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVsXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogTGlzdGVuIHRvIHRoZSBnaXZlbiBgZXZlbnRgIGFuZFxuICAgICAgICogZXhlY3V0ZSB0aGUgYGNhbGxiYWNrYCBhdCBtb3N0IG9uY2VcbiAgICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXZlbnQgLSBldmVudCBpZFxuICAgICAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgICAqL1xuICAgICAgb25lOiB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgICAgICAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgICAgIGVsLm9mZihldmVudCwgb24pO1xuICAgICAgICAgICAgZm4uYXBwbHkoZWwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbC5vbihldmVudCwgb24pXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRXhlY3V0ZSBhbGwgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgbGlzdGVuIHRvXG4gICAgICAgKiB0aGUgZ2l2ZW4gYGV2ZW50YFxuICAgICAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICAgKi9cbiAgICAgIHRyaWdnZXI6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG5cbiAgICAgICAgICAvLyBnZXR0aW5nIHRoZSBhcmd1bWVudHNcbiAgICAgICAgICB2YXIgYXJnbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ2xlbiksXG4gICAgICAgICAgICBmbnMsXG4gICAgICAgICAgICBmbixcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpICsgMV07IC8vIHNraXAgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbnMgPSBzbGljZS5jYWxsKGNhbGxiYWNrc1tldmVudF0gfHwgW10sIDApO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgZm4gPSBmbnNbaV07ICsraSkge1xuICAgICAgICAgICAgZm4uYXBwbHkoZWwsIGFyZ3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjYWxsYmFja3NbJyonXSAmJiBldmVudCAhPSAnKicpXG4gICAgICAgICAgICB7IGVsLnRyaWdnZXIuYXBwbHkoZWwsIFsnKicsIGV2ZW50XS5jb25jYXQoYXJncykpOyB9XG5cbiAgICAgICAgICByZXR1cm4gZWxcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVsXG5cbiAgfTtcblxuICAvKipcbiAgICogU2hvcnQgYWxpYXMgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JcbiAgICovXG4gIGZ1bmN0aW9uIGdldFByb3BEZXNjcmlwdG9yIChvLCBrKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgaylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgdW5kZWZpbmVkXG4gICAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAgICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICAgKi9cbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBUX1VOREVGXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBvYmplY3QncyBwcm9wZXJ0eSBjb3VsZCBiZSBvdmVycmlkZGVuXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gIG9iaiAtIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAga2V5IC0gb2JqZWN0IHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IHRydWUgaWYgd3JpdGFibGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzV3JpdGFibGUob2JqLCBrZXkpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGdldFByb3BEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQob2JqW2tleV0pIHx8IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci53cml0YWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCBhbnkgb2JqZWN0IHdpdGggb3RoZXIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHNyYyAtIHNvdXJjZSBvYmplY3RcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSB0aGUgcmVzdWx0aW5nIGV4dGVuZGVkIG9iamVjdFxuICAgKlxuICAgKiB2YXIgb2JqID0geyBmb286ICdiYXonIH1cbiAgICogZXh0ZW5kKG9iaiwge2JhcjogJ2JhcicsIGZvbzogJ2Jhcid9KVxuICAgKiBjb25zb2xlLmxvZyhvYmopID0+IHtiYXI6ICdiYXInLCBmb286ICdiYXInfVxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuICAgIHZhciBvYmo7XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBsID0gYXJncy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKG9iaiA9IGFyZ3NbaV0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgcHJvcGVydHkgb2YgdGhlIHNvdXJjZSBvYmplY3QgY291bGQgYmUgb3ZlcnJpZGRlblxuICAgICAgICAgIGlmIChpc1dyaXRhYmxlKHNyYywga2V5KSlcbiAgICAgICAgICAgIHsgc3JjW2tleV0gPSBvYmpba2V5XTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcmNcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgT2JqZWN0LmNyZWF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlKHNyYykge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHNyYylcbiAgfVxuXG4gIHZhciBzZXR0aW5ncyA9IGV4dGVuZChjcmVhdGUoYnJhY2tldHMuc2V0dGluZ3MpLCB7XG4gICAgc2tpcEFub255bW91c1RhZ3M6IHRydWUsXG4gICAgLy8gaGFuZGxlIHRoZSBhdXRvIHVwZGF0ZXMgb24gYW55IERPTSBldmVudFxuICAgIGF1dG9VcGRhdGU6IHRydWVcbiAgfSlcblxuICAvKipcbiAgICogU2hvcnRlciBhbmQgZmFzdCB3YXkgdG8gc2VsZWN0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBET01cbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBzZWxlY3RvciAtIERPTSBzZWxlY3RvclxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIERPTSBub2RlIHdoZXJlIHRoZSB0YXJnZXRzIG9mIG91ciBzZWFyY2ggd2lsbCBpcyBsb2NhdGVkXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZG9tIG5vZGVzIGZvdW5kXG4gICAqL1xuICBmdW5jdGlvbiAkJChzZWxlY3RvciwgY3R4KSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoKGN0eCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgZG9jdW1lbnQgdGV4dCBub2RlXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gY3JlYXRlIGEgdGV4dCBub2RlIHRvIHVzZSBhcyBwbGFjZWhvbGRlclxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiBhbnkgRE9NIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byBoaWRlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IHNob3cgLSBkbyB3ZSB3YW50IHRvIHNob3cgaXQ/XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBzaG93KSB7XG4gICAgZG9tLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gJycgOiAnbm9uZSc7XG4gICAgZG9tLmhpZGRlbiA9IHNob3cgPyBmYWxzZSA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiBhbnkgRE9NIGF0dHJpYnV0ZSBvbiBhIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB3ZSB3YW50IHRvIGdldFxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB8IHVuZGVmaW5lZCB9IG5hbWUgb2YgdGhlIG5vZGUgYXR0cmlidXRlIHdoZXRoZXIgaXQgZXhpc3RzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZG9tLCBuYW1lKSB7XG4gICAgcmV0dXJuIGRvbS5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IERPTSBhdHRyaWJ1dGUgZnJvbSBhIG5vZGVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHVwZGF0ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHJlbW92ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGRvbSwgbmFtZSkge1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBpbm5lciBodG1sIG9mIGFueSBET00gbm9kZSBTVkdzIGluY2x1ZGVkXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IGNvbnRhaW5lciAtIERPTSBub2RlIHdoZXJlIHdlJ2xsIGluamVjdCBuZXcgaHRtbFxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSBodG1sIC0gaHRtbCB0byBpbmplY3RcbiAgICogQHBhcmFtIHsgQm9vbGVhbiB9IGlzU3ZnIC0gc3ZnIHRhZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgYSBiaXQgZGlmZmVyZW50bHlcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uIHNldElubmVySFRNTChjb250YWluZXIsIGh0bWwsIGlzU3ZnKSB7XG4gICAgLy8gaW5uZXJIVE1MIGlzIG5vdCBzdXBwb3J0ZWQgb24gc3ZnIHRhZ3Mgc28gd2UgbmVldCB0byB0cmVhdCB0aGVtIGRpZmZlcmVudGx5XG4gICAgaWYgKGlzU3ZnKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbnRhaW5lci5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoXG4gICAgICAgIG5ldyBET01QYXJzZXIoKVxuICAgICAgICAgIC5wYXJzZUZyb21TdHJpbmcoKFwiPHN2ZyB4bWxucz1cXFwiXCIgKyBTVkdfTlMgKyBcIlxcXCI+XCIgKyBodG1sICsgXCI8L3N2Zz5cIiksICdhcHBsaWNhdGlvbi94bWwnKVxuICAgICAgICAgIC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG5cbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1pbmltaXplIHJpc2s6IG9ubHkgemVybyBvciBvbmUgX3NwYWNlXyBiZXR3ZWVuIGF0dHIgJiB2YWx1ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgaHRtbCAtIGh0bWwgc3RyaW5nIHdlIHdhbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gYXBwbHkgb24gYW55IGF0dHJpYnV0ZSBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gd2Fsa0F0dHJpYnV0ZXMoaHRtbCwgZm4pIHtcbiAgICBpZiAoIWh0bWwpIHsgcmV0dXJuIH1cbiAgICB2YXIgbTtcbiAgICB3aGlsZSAobSA9IFJFX0hUTUxfQVRUUlMuZXhlYyhodG1sKSlcbiAgICAgIHsgZm4obVsxXS50b0xvd2VyQ2FzZSgpLCBtWzJdIHx8IG1bM10gfHwgbVs0XSk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvY3VtZW50IGZyYWdtZW50XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHNhZmVseSBhIHRhZyB0byBmaXggIzE5NjIgIzE2NDlcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBjaGlsZHJlbiBjb250YWluZXJcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGN1cnIgLSBub2RlIHRvIGluc2VydFxuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gbmV4dCAtIG5vZGUgdGhhdCBzaG91bGQgcHJlY2VlZCB0aGUgY3VycmVudCBub2RlIGluc2VydGVkXG4gICAqL1xuICBmdW5jdGlvbiBzYWZlSW5zZXJ0KHJvb3QsIGN1cnIsIG5leHQpIHtcbiAgICByb290Lmluc2VydEJlZm9yZShjdXJyLCBuZXh0LnBhcmVudE5vZGUgJiYgbmV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHN0eWxlIG9iamVjdCB0byBhIHN0cmluZ1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHN0eWxlIC0gc3R5bGUgb2JqZWN0IHdlIG5lZWQgdG8gcGFyc2VcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSByZXN1bHRpbmcgY3NzIHN0cmluZ1xuICAgKiBAZXhhbXBsZVxuICAgKiBzdHlsZU9iamVjdFRvU3RyaW5nKHsgY29sb3I6ICdyZWQnLCBoZWlnaHQ6ICcxMHB4J30pIC8vID0+ICdjb2xvcjogcmVkOyBoZWlnaHQ6IDEwcHgnXG4gICAqL1xuICBmdW5jdGlvbiBzdHlsZU9iamVjdFRvU3RyaW5nKHN0eWxlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgICAgcmV0dXJuIChhY2MgKyBcIiBcIiArIHByb3AgKyBcIjogXCIgKyAoc3R5bGVbcHJvcF0pICsgXCI7XCIpXG4gICAgfSwgJycpXG4gIH1cblxuICAvKipcbiAgICogV2FsayBkb3duIHJlY3Vyc2l2ZWx5IGFsbCB0aGUgY2hpbGRyZW4gdGFncyBzdGFydGluZyBkb20gbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9ICAgZG9tIC0gc3RhcnRpbmcgbm9kZSB3aGVyZSB3ZSB3aWxsIHN0YXJ0IHRoZSByZWN1cnNpb25cbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgdG8gdHJhbnNmb3JtIHRoZSBjaGlsZCBub2RlIGp1c3QgZm91bmRcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgIGNvbnRleHQgLSBmbiBjYW4gb3B0aW9uYWxseSByZXR1cm4gYW4gb2JqZWN0LCB3aGljaCBpcyBwYXNzZWQgdG8gY2hpbGRyZW5cbiAgICovXG4gIGZ1bmN0aW9uIHdhbGtOb2Rlcyhkb20sIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKGRvbSkge1xuICAgICAgdmFyIHJlcyA9IGZuKGRvbSwgY29udGV4dCk7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIC8vIHN0b3AgdGhlIHJlY3Vyc2lvblxuICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHsgcmV0dXJuIH1cblxuICAgICAgZG9tID0gZG9tLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgd2Fsa05vZGVzKGRvbSwgZm4sIHJlcyk7XG4gICAgICAgIGRvbSA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIHZhciBkb20gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgJCQ6ICQkLFxuICAgICQ6ICQsXG4gICAgY3JlYXRlRE9NUGxhY2Vob2xkZXI6IGNyZWF0ZURPTVBsYWNlaG9sZGVyLFxuICAgIG1rRWw6IG1ha2VFbGVtZW50LFxuICAgIHNldEF0dHI6IHNldEF0dHJpYnV0ZSxcbiAgICB0b2dnbGVWaXNpYmlsaXR5OiB0b2dnbGVWaXNpYmlsaXR5LFxuICAgIGdldEF0dHI6IGdldEF0dHJpYnV0ZSxcbiAgICByZW1BdHRyOiByZW1vdmVBdHRyaWJ1dGUsXG4gICAgc2V0SW5uZXJIVE1MOiBzZXRJbm5lckhUTUwsXG4gICAgd2Fsa0F0dHJzOiB3YWxrQXR0cmlidXRlcyxcbiAgICBjcmVhdGVGcmFnOiBjcmVhdGVGcmFnbWVudCxcbiAgICBzYWZlSW5zZXJ0OiBzYWZlSW5zZXJ0LFxuICAgIHN0eWxlT2JqZWN0VG9TdHJpbmc6IHN0eWxlT2JqZWN0VG9TdHJpbmcsXG4gICAgd2Fsa05vZGVzOiB3YWxrTm9kZXNcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENoZWNrIGFnYWluc3QgdGhlIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICogQHBhcmFtICAgeyAqIH0gIHZhbHVlIC1cbiAgICogQHJldHVybnMge0Jvb2xlYW59IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBlbXB0eS4gRGlmZmVyZW50IGZyb20gZmFsc3ksIGJlY2F1c2Ugd2UgZG9udCBjb25zaWRlciAwIG9yIGZhbHNlIHRvIGJlIGJsYW5rXG4gICAqIEBwYXJhbSB7ICogfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQmxhbmsodmFsdWUpIHtcbiAgICByZXR1cm4gaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSAnJ1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAgICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICAgKi9cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFRfRlVOQ1RJT05cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYW4gb2JqZWN0LCBleGNsdWRlIG51bGxcbiAgICogTk9URTogdXNlIGlzT2JqZWN0KHgpICYmICFpc0FycmF5KHgpIHRvIGV4Y2x1ZGVzIGFycmF5cy5cbiAgICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFRfT0JKRUNUIC8vIHR5cGVvZiBudWxsIGlzICdvYmplY3QnXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyBhbiBzdmcgdGFnIG9yIHBhcnQgb2YgYW4gc3ZnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSAgZWwgLSBub2RlIHdlIHdhbnQgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCdzIGFuIHN2ZyBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBpc1N2ZyhlbCkge1xuICAgIHZhciBvd25lciA9IGVsLm93bmVyU1ZHRWxlbWVudDtcbiAgICByZXR1cm4gISFvd25lciB8fCBvd25lciA9PT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIGtpbmQgb2YgYXJyYXlcbiAgICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLVxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzQm9vbEF0dHIodmFsdWUpIHtcbiAgICByZXR1cm4gUkVfQk9PTF9BVFRSUy50ZXN0KHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICAgKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVF9TVFJJTkdcbiAgfVxuXG5cblxuICB2YXIgY2hlY2sgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgaXNCbGFuazogaXNCbGFuayxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc1N2ZzogaXNTdmcsXG4gICAgaXNXcml0YWJsZTogaXNXcml0YWJsZSxcbiAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgIGlzQm9vbEF0dHI6IGlzQm9vbEF0dHIsXG4gICAgaXNOaWw6IGlzTmlsLFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWRcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYW4gYXJyYXkgY29udGFpbnMgYW4gaXRlbVxuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gYXJyYXkgLSB0YXJnZXQgYXJyYXlcbiAgICogQHBhcmFtICAgeyAqIH0gaXRlbSAtIGl0ZW0gdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gICAqL1xuICBmdW5jdGlvbiBjb250YWlucyhhcnJheSwgaXRlbSkge1xuICAgIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMVxuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpYWxpemVkIGZ1bmN0aW9uIGZvciBsb29waW5nIGFuIGFycmF5LWxpa2UgY29sbGVjdGlvbiB3aXRoIGBlYWNoPXt9YFxuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gbGlzdCAtIGNvbGxlY3Rpb24gb2YgaXRlbXNcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHsgQXJyYXkgfSB0aGUgYXJyYXkgbG9vcGVkXG4gICAqL1xuICBmdW5jdGlvbiBlYWNoKGxpc3QsIGZuKSB7XG4gICAgdmFyIGxlbiA9IGxpc3QgPyBsaXN0Lmxlbmd0aCA6IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHsgZm4obGlzdFtpXSwgaSk7IH1cbiAgICByZXR1cm4gbGlzdFxuICB9XG5cbiAgLyoqXG4gICAqIEZhc3RlciBTdHJpbmcgc3RhcnRzV2l0aCBhbHRlcm5hdGl2ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IHN0ciAtIHNvdXJjZSBzdHJpbmdcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB2YWx1ZSAtIHRlc3Qgc3RyaW5nXG4gICAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAgICovXG4gIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCB2YWx1ZSkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgdmFsdWUubGVuZ3RoKSA9PT0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZXR1cm5pbmcgYWx3YXlzIGEgdW5pcXVlIGlkZW50aWZpZXJcbiAgICogQHJldHVybnMgeyBOdW1iZXIgfSAtIG51bWJlciBmcm9tIDAuLi5uXG4gICAqL1xuICB2YXIgdWlkID0gKGZ1bmN0aW9uIHVpZCgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiArK2k7IH1cbiAgfSkoKVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IGFuIGltbXV0YWJsZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGVsIC0gb2JqZWN0IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzZXRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBrZXkgLSBvYmplY3Qga2V5IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzdG9yZWRcbiAgICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLSB2YWx1ZSBvZiB0aGUgbmV3IHByb3BlcnR5XG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0aW9ucyAtIHNldCB0aGUgcHJvcGVyeSBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSAtIHRoZSBpbml0aWFsIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lKGVsLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBrZXksIGV4dGVuZCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RyaW5nIGNvbnRhaW5pbmcgZGFzaGVzIHRvIGNhbWVsIGNhc2VcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBzdHIgLSBpbnB1dCBzdHJpbmdcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSBteS1zdHJpbmcgLT4gbXlTdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIHRvQ2FtZWwoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKFxcdykvZywgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJuIGEgbWVzc2FnZSB2aWEgY29uc29sZVxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSBtZXNzYWdlIC0gd2FybmluZyBtZXNzYWdlXG4gICAqL1xuICBmdW5jdGlvbiB3YXJuKG1lc3NhZ2UpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHsgY29uc29sZS53YXJuKG1lc3NhZ2UpOyB9XG4gIH1cblxuXG5cbiAgdmFyIG1pc2MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgZ2V0UHJvcERlc2NyaXB0b3I6IGdldFByb3BEZXNjcmlwdG9yLFxuICAgIHN0YXJ0c1dpdGg6IHN0YXJ0c1dpdGgsXG4gICAgdWlkOiB1aWQsXG4gICAgZGVmaW5lUHJvcGVydHk6IGRlZmluZSxcbiAgICBvYmplY3RDcmVhdGU6IGNyZWF0ZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICB0b0NhbWVsOiB0b0NhbWVsLFxuICAgIHdhcm46IHdhcm5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvcGVydHkgb2YgYW4gb2JqZWN0IGZvciBhIGdpdmVuIGtleS4gSWYgc29tZXRoaW5nIGFscmVhZHlcbiAgICogZXhpc3RzIHRoZXJlLCB0aGVuIGl0IGJlY29tZXMgYW4gYXJyYXkgY29udGFpbmluZyBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZS5cbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0ga2V5IC0gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgc2V0XG4gICAqIEBwYXJhbSB7IEJvb2xlYW4gfSBlbnN1cmVBcnJheSAtIGVuc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSByZW1haW5zIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7IE51bWJlciB9IGluZGV4IC0gYWRkIHRoZSBuZXcgaXRlbSBpbiBhIGNlcnRhaW4gYXJyYXkgcG9zaXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5aXNoQWRkKG9iaiwga2V5LCB2YWx1ZSwgZW5zdXJlQXJyYXksIGluZGV4KSB7XG4gICAgdmFyIGRlc3QgPSBvYmpba2V5XTtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KGRlc3QpO1xuICAgIHZhciBoYXNJbmRleCA9ICFpc1VuZGVmaW5lZChpbmRleCk7XG5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ID09PSB2YWx1ZSkgeyByZXR1cm4gfVxuXG4gICAgLy8gaWYgdGhlIGtleSB3YXMgbmV2ZXIgc2V0LCBzZXQgaXQgb25jZVxuICAgIGlmICghZGVzdCAmJiBlbnN1cmVBcnJheSkgeyBvYmpba2V5XSA9IFt2YWx1ZV07IH1cbiAgICBlbHNlIGlmICghZGVzdCkgeyBvYmpba2V5XSA9IHZhbHVlOyB9XG4gICAgLy8gaWYgaXQgd2FzIGFuIGFycmF5IGFuZCBub3QgeWV0IHNldFxuICAgIGVsc2Uge1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHZhciBvbGRJbmRleCA9IGRlc3QuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgIC8vIHRoaXMgaXRlbSBuZXZlciBjaGFuZ2VkIGl0cyBwb3NpdGlvblxuICAgICAgICBpZiAob2xkSW5kZXggPT09IGluZGV4KSB7IHJldHVybiB9XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBmcm9tIGl0cyBvbGQgcG9zaXRpb25cbiAgICAgICAgaWYgKG9sZEluZGV4ICE9PSAtMSkgeyBkZXN0LnNwbGljZShvbGRJbmRleCwgMSk7IH1cbiAgICAgICAgLy8gbW92ZSBvciBhZGQgdGhlIGl0ZW1cbiAgICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgICAgZGVzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXN0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyBvYmpba2V5XSA9IFtkZXN0LCB2YWx1ZV07IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHRoZSB0YWcgaW1wbGVtZW50YXRpb24gYnkgYSBET00gbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIG5lZWQgdG8gcGFyc2UgdG8gZ2V0IGl0cyB0YWcgaW1wbGVtZW50YXRpb25cbiAgICogQHJldHVybnMgeyBPYmplY3QgfSBpdCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGN1c3RvbSB0YWcgKHRlbXBsYXRlIGFuZCBib290IGZ1bmN0aW9uKVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0KGRvbSkge1xuICAgIHJldHVybiBkb20udGFnTmFtZSAmJiBfX1RBR19JTVBMW2dldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSkgfHxcbiAgICAgIGdldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSkgfHwgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKV1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZyBuYW1lIG9mIGFueSBET00gbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gc2tpcERhdGFJcyAtIGhhY2sgdG8gaWdub3JlIHRoZSBkYXRhLWlzIGF0dHJpYnV0ZSB3aGVuIGF0dGFjaGluZyB0byBwYXJlbnRcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSBuYW1lIHRvIGlkZW50aWZ5IHRoaXMgZG9tIG5vZGUgaW4gcmlvdFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TmFtZShkb20sIHNraXBEYXRhSXMpIHtcbiAgICB2YXIgY2hpbGQgPSBnZXQoZG9tKTtcbiAgICB2YXIgbmFtZWRUYWcgPSAhc2tpcERhdGFJcyAmJiBnZXRBdHRyaWJ1dGUoZG9tLCBJU19ESVJFQ1RJVkUpO1xuICAgIHJldHVybiBuYW1lZFRhZyAmJiAhdG1wbC5oYXNFeHByKG5hbWVkVGFnKSA/XG4gICAgICBuYW1lZFRhZyA6IGNoaWxkID8gY2hpbGQubmFtZSA6IGRvbS50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB0ZW1wb3JhcnkgY29udGV4dCBjb250YWluaW5nIGFsc28gdGhlIHBhcmVudCBwcm9wZXJ0aWVzXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0geyBUYWcgfSAtIHRlbXBvcmFyeSB0YWcgY29udGV4dCBjb250YWluaW5nIGFsbCB0aGUgcGFyZW50IHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGluaGVyaXRQYXJlbnRQcm9wcygpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHsgcmV0dXJuIGV4dGVuZChjcmVhdGUodGhpcyksIHRoaXMucGFyZW50KSB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qXG4gICAgSW5jbHVkZXMgaGFja3MgbmVlZGVkIGZvciB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbiA5IGFuZCBiZWxvd1xuICAgIFNlZTogaHR0cDovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNS8jaWU4XG4gICAgICAgICBodHRwOi8vY29kZXBsYW5ldC5pby9kcm9wcGluZy1pZTgvXG4gICovXG5cbiAgdmFyXG4gICAgcmVIYXNZaWVsZCAgPSAvPHlpZWxkXFxiL2ksXG4gICAgcmVZaWVsZEFsbCAgPSAvPHlpZWxkXFxzKig/OlxcLz58PihbXFxTXFxzXSo/KTxcXC95aWVsZFxccyo+fD4pL2lnLFxuICAgIHJlWWllbGRTcmMgID0gLzx5aWVsZFxccyt0bz1bJ1wiXShbXidcIj5dKilbJ1wiXVxccyo+KFtcXFNcXHNdKj8pPFxcL3lpZWxkXFxzKj4vaWcsXG4gICAgcmVZaWVsZERlc3QgPSAvPHlpZWxkXFxzK2Zyb209WydcIl0/KFstXFx3XSspWydcIl0/XFxzKig/OlxcLz58PihbXFxTXFxzXSo/KTxcXC95aWVsZFxccyo+KS9pZyxcbiAgICByb290RWxzID0geyB0cjogJ3Rib2R5JywgdGg6ICd0cicsIHRkOiAndHInLCBjb2w6ICdjb2xncm91cCcgfSxcbiAgICB0YmxUYWdzID0gSUVfVkVSU0lPTiAmJiBJRV9WRVJTSU9OIDwgMTAgPyBSRV9TUEVDSUFMX1RBR1MgOiBSRV9TUEVDSUFMX1RBR1NfTk9fT1BUSU9OLFxuICAgIEdFTkVSSUMgPSAnZGl2JyxcbiAgICBTVkcgPSAnc3ZnJztcblxuXG4gIC8qXG4gICAgQ3JlYXRlcyB0aGUgcm9vdCBlbGVtZW50IGZvciB0YWJsZSBvciBzZWxlY3QgY2hpbGQgZWxlbWVudHM6XG4gICAgdHIvdGgvdGQvdGhlYWQvdGZvb3QvdGJvZHkvY2FwdGlvbi9jb2wvY29sZ3JvdXAvb3B0aW9uL29wdGdyb3VwXG4gICovXG4gIGZ1bmN0aW9uIHNwZWNpYWxUYWdzKGVsLCB0bXBsLCB0YWdOYW1lKSB7XG5cbiAgICB2YXJcbiAgICAgIHNlbGVjdCA9IHRhZ05hbWVbMF0gPT09ICdvJyxcbiAgICAgIHBhcmVudCA9IHNlbGVjdCA/ICdzZWxlY3Q+JyA6ICd0YWJsZT4nO1xuXG4gICAgLy8gdHJpbSgpIGlzIGltcG9ydGFudCBoZXJlLCB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgaGF2ZSBhcnRpZmFjdHMsXG4gICAgLy8gc28gd2UgY2FuIGNoZWNrIGlmIHdlIGhhdmUgb25seSBvbmUgZWxlbWVudCBpbnNpZGUgdGhlIHBhcmVudFxuICAgIGVsLmlubmVySFRNTCA9ICc8JyArIHBhcmVudCArIHRtcGwudHJpbSgpICsgJzwvJyArIHBhcmVudDtcbiAgICBwYXJlbnQgPSBlbC5maXJzdENoaWxkO1xuXG4gICAgLy8gcmV0dXJucyB0aGUgaW1tZWRpYXRlIHBhcmVudCBpZiB0ci90aC90ZC9jb2wgaXMgdGhlIG9ubHkgZWxlbWVudCwgaWYgbm90XG4gICAgLy8gcmV0dXJucyB0aGUgd2hvbGUgdHJlZSwgYXMgdGhpcyBjYW4gaW5jbHVkZSBhZGRpdGlvbmFsIGVsZW1lbnRzXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleCA9IC0xOyAgLy8gZm9yIElFOSwgY29tcGF0aWJsZSB3L2N1cnJlbnQgcmlvdCBiZWhhdmlvclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdm9pZHMgaW5zZXJ0aW9uIG9mIGNvaW50YWluZXIgaW5zaWRlIGNvbnRhaW5lciAoZXg6IHRib2R5IGluc2lkZSB0Ym9keSlcbiAgICAgIHZhciB0bmFtZSA9IHJvb3RFbHNbdGFnTmFtZV07XG4gICAgICBpZiAodG5hbWUgJiYgcGFyZW50LmNoaWxkRWxlbWVudENvdW50ID09PSAxKSB7IHBhcmVudCA9ICQodG5hbWUsIHBhcmVudCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgLypcbiAgICBSZXBsYWNlIHRoZSB5aWVsZCB0YWcgZnJvbSBhbnkgdGFnIHRlbXBsYXRlIHdpdGggdGhlIGlubmVySFRNTCBvZiB0aGVcbiAgICBvcmlnaW5hbCB0YWcgaW4gdGhlIHBhZ2VcbiAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVlpZWxkKHRtcGwsIGh0bWwpIHtcbiAgICAvLyBkbyBub3RoaW5nIGlmIG5vIHlpZWxkXG4gICAgaWYgKCFyZUhhc1lpZWxkLnRlc3QodG1wbCkpIHsgcmV0dXJuIHRtcGwgfVxuXG4gICAgLy8gYmUgY2FyZWZ1bCB3aXRoICMxMzQzIC0gc3RyaW5nIG9uIHRoZSBzb3VyY2UgaGF2aW5nIGAkMWBcbiAgICB2YXIgc3JjID0ge307XG5cbiAgICBodG1sID0gaHRtbCAmJiBodG1sLnJlcGxhY2UocmVZaWVsZFNyYywgZnVuY3Rpb24gKF8sIHJlZiwgdGV4dCkge1xuICAgICAgc3JjW3JlZl0gPSBzcmNbcmVmXSB8fCB0ZXh0OyAgIC8vIHByZXNlcnZlIGZpcnN0IGRlZmluaXRpb25cbiAgICAgIHJldHVybiAnJ1xuICAgIH0pLnRyaW0oKTtcblxuICAgIHJldHVybiB0bXBsXG4gICAgICAucmVwbGFjZShyZVlpZWxkRGVzdCwgZnVuY3Rpb24gKF8sIHJlZiwgZGVmKSB7ICAvLyB5aWVsZCB3aXRoIGZyb20gLSB0byBhdHRyc1xuICAgICAgICByZXR1cm4gc3JjW3JlZl0gfHwgZGVmIHx8ICcnXG4gICAgICB9KVxuICAgICAgLnJlcGxhY2UocmVZaWVsZEFsbCwgZnVuY3Rpb24gKF8sIGRlZikgeyAgICAgICAgLy8geWllbGQgd2l0aG91dCBhbnkgXCJmcm9tXCJcbiAgICAgICAgcmV0dXJuIGh0bWwgfHwgZGVmIHx8ICcnXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBET00gZWxlbWVudCB0byB3cmFwIHRoZSBnaXZlbiBjb250ZW50LiBOb3JtYWxseSBhbiBgRElWYCwgYnV0IGNhbiBiZVxuICAgKiBhbHNvIGEgYFRBQkxFYCwgYFNFTEVDVGAsIGBUQk9EWWAsIGBUUmAsIG9yIGBDT0xHUk9VUGAgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0bXBsICAtIFRoZSB0ZW1wbGF0ZSBjb21pbmcgZnJvbSB0aGUgY3VzdG9tIHRhZyBkZWZpbml0aW9uXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gaHRtbCAtIEhUTUwgY29udGVudCB0aGF0IGNvbWVzIGZyb20gdGhlIERPTSBlbGVtZW50IHdoZXJlIHlvdVxuICAgKiAgICAgICAgICAgd2lsbCBtb3VudCB0aGUgdGFnLCBtb3N0bHkgdGhlIG9yaWdpbmFsIHRhZyBpbiB0aGUgcGFnZVxuICAgKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1N2ZyAtIHRydWUgaWYgdGhlIHJvb3Qgbm9kZSBpcyBhbiBzdmdcbiAgICogQHJldHVybnMgeyBIVE1MRWxlbWVudCB9IERPTSBlbGVtZW50IHdpdGggX3RtcGxfIG1lcmdlZCB0aHJvdWdoIGBZSUVMRGAgd2l0aCB0aGUgX2h0bWxfLlxuICAgKi9cbiAgZnVuY3Rpb24gbWtkb20odG1wbCwgaHRtbCwgaXNTdmcpIHtcbiAgICB2YXIgbWF0Y2ggICA9IHRtcGwgJiYgdG1wbC5tYXRjaCgvXlxccyo8KFstXFx3XSspLyk7XG4gICAgdmFyICB0YWdOYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgZWwgPSBtYWtlRWxlbWVudChpc1N2ZyA/IFNWRyA6IEdFTkVSSUMpO1xuXG4gICAgLy8gcmVwbGFjZSBhbGwgdGhlIHlpZWxkIHRhZ3Mgd2l0aCB0aGUgdGFnIGlubmVyIGh0bWxcbiAgICB0bXBsID0gcmVwbGFjZVlpZWxkKHRtcGwsIGh0bWwpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGJsVGFncy50ZXN0KHRhZ05hbWUpKVxuICAgICAgeyBlbCA9IHNwZWNpYWxUYWdzKGVsLCB0bXBsLCB0YWdOYW1lKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgc2V0SW5uZXJIVE1MKGVsLCB0bXBsLCBpc1N2Zyk7IH1cblxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIExvb3AgYmFja3dhcmQgYWxsIHRoZSBwYXJlbnRzIHRyZWUgdG8gZGV0ZWN0IHRoZSBmaXJzdCBjdXN0b20gcGFyZW50IHRhZ1xuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHRhZyAtIGEgVGFnIGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gdGhlIGluc3RhbmNlIG9mIHRoZSBmaXJzdCBjdXN0b20gcGFyZW50IHRhZyBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRhZykge1xuICAgIHZhciBwdGFnID0gdGFnO1xuICAgIHdoaWxlIChwdGFnLl9fLmlzQW5vbnltb3VzKSB7XG4gICAgICBpZiAoIXB0YWcucGFyZW50KSB7IGJyZWFrIH1cbiAgICAgIHB0YWcgPSBwdGFnLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHB0YWdcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIERPTSBldmVudHNcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGRvbSBlbGVtZW50IHRhcmdldCBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGhhbmRsZXIgLSB1c2VyIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZSAtIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRXZlbnQoZG9tLCBoYW5kbGVyLCBlKSB7XG4gICAgdmFyIHB0YWcgPSB0aGlzLl9fLnBhcmVudDtcbiAgICB2YXIgaXRlbSA9IHRoaXMuX18uaXRlbTtcblxuICAgIGlmICghaXRlbSlcbiAgICAgIHsgd2hpbGUgKHB0YWcgJiYgIWl0ZW0pIHtcbiAgICAgICAgaXRlbSA9IHB0YWcuX18uaXRlbTtcbiAgICAgICAgcHRhZyA9IHB0YWcuX18ucGFyZW50O1xuICAgICAgfSB9XG5cbiAgICAvLyBvdmVycmlkZSB0aGUgZXZlbnQgcHJvcGVydGllc1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGlzV3JpdGFibGUoZSwgJ2N1cnJlbnRUYXJnZXQnKSkgeyBlLmN1cnJlbnRUYXJnZXQgPSBkb207IH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChpc1dyaXRhYmxlKGUsICd0YXJnZXQnKSkgeyBlLnRhcmdldCA9IGUuc3JjRWxlbWVudDsgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKGlzV3JpdGFibGUoZSwgJ3doaWNoJykpIHsgZS53aGljaCA9IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlOyB9XG5cbiAgICBlLml0ZW0gPSBpdGVtO1xuXG4gICAgaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuXG4gICAgLy8gYXZvaWQgYXV0byB1cGRhdGVzXG4gICAgaWYgKCFzZXR0aW5ncy5hdXRvVXBkYXRlKSB7IHJldHVybiB9XG5cbiAgICBpZiAoIWUucHJldmVudFVwZGF0ZSkge1xuICAgICAgdmFyIHAgPSBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQodGhpcyk7XG4gICAgICAvLyBmaXhlcyAjMjA4M1xuICAgICAgaWYgKHAuaXNNb3VudGVkKSB7IHAudXBkYXRlKCk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGFuIGV2ZW50IHRvIGEgRE9NIG5vZGVcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIGV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHsgRnVuY3Rpb24gfSBoYW5kbGVyIC0gZXZlbnQgY2FsbGJhY2tcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZG9tIC0gZG9tIG5vZGVcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFnIC0gdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBzZXRFdmVudEhhbmRsZXIobmFtZSwgaGFuZGxlciwgZG9tLCB0YWcpIHtcbiAgICB2YXIgZXZlbnROYW1lO1xuICAgIHZhciBjYiA9IGhhbmRsZUV2ZW50LmJpbmQodGFnLCBkb20sIGhhbmRsZXIpO1xuXG4gICAgLy8gYXZvaWQgdG8gYmluZCB0d2ljZSB0aGUgc2FtZSBldmVudFxuICAgIC8vIHBvc3NpYmxlIGZpeCBmb3IgIzIzMzJcbiAgICBkb21bbmFtZV0gPSBudWxsO1xuXG4gICAgLy8gbm9ybWFsaXplIGV2ZW50IG5hbWVcbiAgICBldmVudE5hbWUgPSBuYW1lLnJlcGxhY2UoUkVfRVZFTlRTX1BSRUZJWCwgJycpO1xuXG4gICAgLy8gY2FjaGUgdGhlIGxpc3RlbmVyIGludG8gdGhlIGxpc3RlbmVycyBhcnJheVxuICAgIGlmICghY29udGFpbnModGFnLl9fLmxpc3RlbmVycywgZG9tKSkgeyB0YWcuX18ubGlzdGVuZXJzLnB1c2goZG9tKTsgfVxuICAgIGlmICghZG9tW1JJT1RfRVZFTlRTX0tFWV0pIHsgZG9tW1JJT1RfRVZFTlRTX0tFWV0gPSB7fTsgfVxuICAgIGlmIChkb21bUklPVF9FVkVOVFNfS0VZXVtuYW1lXSkgeyBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRvbVtSSU9UX0VWRU5UU19LRVldW25hbWVdKTsgfVxuXG4gICAgZG9tW1JJT1RfRVZFTlRTX0tFWV1bbmFtZV0gPSBjYjtcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGNoaWxkIHRhZyBpbmNsdWRpbmcgaXQgY29ycmVjdGx5IGludG8gaXRzIHBhcmVudFxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGNoaWxkIC0gY2hpbGQgdGFnIGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBvcHRpb25zIGNvbnRhaW5pbmcgdGhlIERPTSBub2RlIHdoZXJlIHRoZSB0YWcgd2lsbCBiZSBtb3VudGVkXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gaW5uZXJIVE1MIC0gaW5uZXIgaHRtbCBvZiB0aGUgY2hpbGQgbm9kZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IHBhcmVudCAtIGluc3RhbmNlIG9mIHRoZSBwYXJlbnQgdGFnIGluY2x1ZGluZyB0aGUgY2hpbGQgY3VzdG9tIHRhZ1xuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGluc3RhbmNlIG9mIHRoZSBuZXcgY2hpbGQgdGFnIGp1c3QgY3JlYXRlZFxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdENoaWxkKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwsIHBhcmVudCkge1xuICAgIHZhciB0YWcgPSBjcmVhdGVUYWcoY2hpbGQsIG9wdHMsIGlubmVySFRNTCk7XG4gICAgdmFyIHRhZ05hbWUgPSBvcHRzLnRhZ05hbWUgfHwgZ2V0TmFtZShvcHRzLnJvb3QsIHRydWUpO1xuICAgIHZhciBwdGFnID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHBhcmVudCk7XG4gICAgLy8gZml4IGZvciB0aGUgcGFyZW50IGF0dHJpYnV0ZSBpbiB0aGUgbG9vcGVkIGVsZW1lbnRzXG4gICAgZGVmaW5lKHRhZywgJ3BhcmVudCcsIHB0YWcpO1xuICAgIC8vIHN0b3JlIHRoZSByZWFsIHBhcmVudCB0YWdcbiAgICAvLyBpbiBzb21lIGNhc2VzIHRoaXMgY291bGQgYmUgZGlmZmVyZW50IGZyb20gdGhlIGN1c3RvbSBwYXJlbnQgdGFnXG4gICAgLy8gZm9yIGV4YW1wbGUgaW4gbmVzdGVkIGxvb3BzXG4gICAgdGFnLl9fLnBhcmVudCA9IHBhcmVudDtcblxuICAgIC8vIGFkZCB0aGlzIHRhZyB0byB0aGUgY3VzdG9tIHBhcmVudCB0YWdcbiAgICBhcnJheWlzaEFkZChwdGFnLnRhZ3MsIHRhZ05hbWUsIHRhZyk7XG5cbiAgICAvLyBhbmQgYWxzbyB0byB0aGUgcmVhbCBwYXJlbnQgdGFnXG4gICAgaWYgKHB0YWcgIT09IHBhcmVudClcbiAgICAgIHsgYXJyYXlpc2hBZGQocGFyZW50LnRhZ3MsIHRhZ05hbWUsIHRhZyk7IH1cblxuICAgIHJldHVybiB0YWdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBvYmplY3QgYXQgYSBnaXZlbiBrZXkuIElmIHRoZSBrZXkgcG9pbnRzIHRvIGFuIGFycmF5LFxuICAgKiB0aGVuIHRoZSBpdGVtIGlzIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheS5cbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtIHsgU3RyaW5nIH0ga2V5IC0gcHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0geyBCb29sZWFuIH0gZW5zdXJlQXJyYXkgLSBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgcmVtYWlucyBhbiBhcnJheVxuICAqL1xuICBmdW5jdGlvbiBhcnJheWlzaFJlbW92ZShvYmosIGtleSwgdmFsdWUsIGVuc3VyZUFycmF5KSB7XG4gICAgaWYgKGlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICB2YXIgaW5kZXggPSBvYmpba2V5XS5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHsgb2JqW2tleV0uc3BsaWNlKGluZGV4LCAxKTsgfVxuICAgICAgaWYgKCFvYmpba2V5XS5sZW5ndGgpIHsgZGVsZXRlIG9ialtrZXldOyB9XG4gICAgICBlbHNlIGlmIChvYmpba2V5XS5sZW5ndGggPT09IDEgJiYgIWVuc3VyZUFycmF5KSB7IG9ialtrZXldID0gb2JqW2tleV1bMF07IH1cbiAgICB9IGVsc2UgaWYgKG9ialtrZXldID09PSB2YWx1ZSlcbiAgICAgIHsgZGVsZXRlIG9ialtrZXldOyB9IC8vIG90aGVyd2lzZSBqdXN0IGRlbGV0ZSB0aGUga2V5XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudHMgZm9yIGEgdmlydHVhbCB0YWdcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IE5vZGUgfSBzcmMgLSB0aGUgbm9kZSB0aGF0IHdpbGwgZG8gdGhlIGluc2VydGluZyBvciBhcHBlbmRpbmdcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFyZ2V0IC0gb25seSBpZiBpbnNlcnRpbmcsIGluc2VydCBiZWZvcmUgdGhpcyB0YWcncyBmaXJzdCBjaGlsZFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVZpcnR1YWwoc3JjLCB0YXJnZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBoZWFkID0gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKTtcbiAgICB2YXIgdGFpbCA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCk7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICAgIHZhciBzaWI7XG4gICAgdmFyIGVsO1xuXG4gICAgdGhpcy5yb290Lmluc2VydEJlZm9yZShoZWFkLCB0aGlzLnJvb3QuZmlyc3RDaGlsZCk7XG4gICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRhaWwpO1xuXG4gICAgdGhpcy5fXy5oZWFkID0gZWwgPSBoZWFkO1xuICAgIHRoaXMuX18udGFpbCA9IHRhaWw7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIHNpYiA9IGVsLm5leHRTaWJsaW5nO1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB0aGlzJDEuX18udmlydHMucHVzaChlbCk7IC8vIGhvbGQgZm9yIHVubW91bnRpbmdcbiAgICAgIGVsID0gc2liO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQpXG4gICAgICB7IHNyYy5pbnNlcnRCZWZvcmUoZnJhZywgdGFyZ2V0Ll9fLmhlYWQpOyB9XG4gICAgZWxzZVxuICAgICAgeyBzcmMuYXBwZW5kQ2hpbGQoZnJhZyk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBtYWtlcyBhIHRhZyB2aXJ0dWFsIGFuZCByZXBsYWNlcyBhIHJlZmVyZW5jZSBpbiB0aGUgZG9tXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0geyB0YWcgfSB0aGUgdGFnIHRvIG1ha2UgdmlydHVhbFxuICAgKiBAcGFyYW0geyByZWYgfSB0aGUgZG9tIHJlZmVyZW5jZSBsb2NhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVJlcGxhY2VWaXJ0dWFsKHRhZywgcmVmKSB7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICAgIG1ha2VWaXJ0dWFsLmNhbGwodGFnLCBmcmFnKTtcbiAgICByZWYucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZnJhZywgcmVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZHluYW1pY2FsbHkgY3JlYXRlZCBkYXRhLWlzIHRhZ3Mgd2l0aCBjaGFuZ2luZyBleHByZXNzaW9uc1xuICAgKiBAcGFyYW0geyBPYmplY3QgfSBleHByIC0gZXhwcmVzc2lvbiB0YWcgYW5kIGV4cHJlc3Npb24gaW5mb1xuICAgKiBAcGFyYW0geyBUYWcgfSAgICBwYXJlbnQgLSBwYXJlbnQgZm9yIHRhZyBjcmVhdGlvblxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIHdlIHdhbnQgdG8gdXNlXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVEYXRhSXMoZXhwciwgcGFyZW50LCB0YWdOYW1lKSB7XG4gICAgdmFyIHRhZyA9IGV4cHIudGFnIHx8IGV4cHIuZG9tLl90YWc7XG4gICAgdmFyIHJlZjtcblxuICAgIHZhciByZWYkMSA9IHRhZyA/IHRhZy5fXyA6IHt9O1xuICAgIHZhciBoZWFkID0gcmVmJDEuaGVhZDtcbiAgICB2YXIgaXNWaXJ0dWFsID0gZXhwci5kb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuXG4gICAgaWYgKHRhZyAmJiBleHByLnRhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIHRhZy51cGRhdGUoKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHN5bmMgX3BhcmVudCB0byBhY2NvbW1vZGF0ZSBjaGFuZ2luZyB0YWduYW1lc1xuICAgIGlmICh0YWcpIHtcbiAgICAgIC8vIG5lZWQgcGxhY2Vob2xkZXIgYmVmb3JlIHVubW91bnRcbiAgICAgIGlmKGlzVmlydHVhbCkge1xuICAgICAgICByZWYgPSBjcmVhdGVET01QbGFjZWhvbGRlcigpO1xuICAgICAgICBoZWFkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJlZiwgaGVhZCk7XG4gICAgICB9XG5cbiAgICAgIHRhZy51bm1vdW50KHRydWUpO1xuICAgIH1cblxuICAgIC8vIHVuYWJsZSB0byBnZXQgdGhlIHRhZyBuYW1lXG4gICAgaWYgKCFpc1N0cmluZyh0YWdOYW1lKSkgeyByZXR1cm4gfVxuXG4gICAgZXhwci5pbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcblxuICAgIC8vIHVua25vd24gaW1wbGVtZW50YXRpb25cbiAgICBpZiAoIWV4cHIuaW1wbCkgeyByZXR1cm4gfVxuXG4gICAgZXhwci50YWcgPSB0YWcgPSBpbml0Q2hpbGQoXG4gICAgICBleHByLmltcGwsIHtcbiAgICAgICAgcm9vdDogZXhwci5kb20sXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lXG4gICAgICB9LFxuICAgICAgZXhwci5kb20uaW5uZXJIVE1MLFxuICAgICAgcGFyZW50XG4gICAgKTtcblxuICAgIGVhY2goZXhwci5hdHRycywgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHNldEF0dHJpYnV0ZSh0YWcucm9vdCwgYS5uYW1lLCBhLnZhbHVlKTsgfSk7XG4gICAgZXhwci50YWdOYW1lID0gdGFnTmFtZTtcbiAgICB0YWcubW91bnQoKTtcblxuICAgIC8vIHJvb3QgZXhpc3QgZmlyc3QgdGltZSwgYWZ0ZXIgdXNlIHBsYWNlaG9sZGVyXG4gICAgaWYgKGlzVmlydHVhbCkgeyBtYWtlUmVwbGFjZVZpcnR1YWwodGFnLCByZWYgfHwgdGFnLnJvb3QpOyB9XG5cbiAgICAvLyBwYXJlbnQgaXMgdGhlIHBsYWNlaG9sZGVyIHRhZywgbm90IHRoZSBkeW5hbWljIHRhZyBzbyBjbGVhbiB1cFxuICAgIHBhcmVudC5fXy5vblVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZGVsTmFtZSA9IHRhZy5vcHRzLmRhdGFJcztcbiAgICAgIGFycmF5aXNoUmVtb3ZlKHRhZy5wYXJlbnQudGFncywgZGVsTmFtZSwgdGFnKTtcbiAgICAgIGFycmF5aXNoUmVtb3ZlKHRhZy5fXy5wYXJlbnQudGFncywgZGVsTmFtZSwgdGFnKTtcbiAgICAgIHRhZy51bm1vdW50KCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb21hbGl6ZSBhbnkgYXR0cmlidXRlIHJlbW92aW5nIHRoZSBcInJpb3QtXCIgcHJlZml4XG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0ck5hbWUgLSBvcmlnaW5hbCBhdHRyaWJ1dGUgbmFtZVxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB9IHZhbGlkIGh0bWwgYXR0cmlidXRlIG5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJOYW1lKGF0dHJOYW1lKSB7XG4gICAgaWYgKCFhdHRyTmFtZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgYXR0ck5hbWUgPSBhdHRyTmFtZS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpO1xuICAgIGlmIChDQVNFX1NFTlNJVElWRV9BVFRSSUJVVEVTW2F0dHJOYW1lXSkgeyBhdHRyTmFtZSA9IENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVNbYXR0ck5hbWVdOyB9XG4gICAgcmV0dXJuIGF0dHJOYW1lXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIG9uIHNpbmdsZSB0YWcgZXhwcmVzc2lvblxuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZXhwciAtIGV4cHJlc3Npb24gbG9naWNcbiAgICogQHJldHVybnMgeyB1bmRlZmluZWQgfVxuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlRXhwcmVzc2lvbihleHByKSB7XG4gICAgaWYgKHRoaXMucm9vdCAmJiBnZXRBdHRyaWJ1dGUodGhpcy5yb290LCd2aXJ0dWFsaXplZCcpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgZG9tID0gZXhwci5kb207XG4gICAgLy8gcmVtb3ZlIHRoZSByaW90LSBwcmVmaXhcbiAgICB2YXIgYXR0ck5hbWUgPSBub3JtYWxpemVBdHRyTmFtZShleHByLmF0dHIpO1xuICAgIHZhciBpc1RvZ2dsZSA9IGNvbnRhaW5zKFtTSE9XX0RJUkVDVElWRSwgSElERV9ESVJFQ1RJVkVdLCBhdHRyTmFtZSk7XG4gICAgdmFyIGlzVmlydHVhbCA9IGV4cHIucm9vdCAmJiBleHByLnJvb3QudGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuICAgIHZhciByZWYgPSB0aGlzLl9fO1xuICAgIHZhciBpc0Fub255bW91cyA9IHJlZi5pc0Fub255bW91cztcbiAgICB2YXIgcGFyZW50ID0gZG9tICYmIChleHByLnBhcmVudCB8fCBkb20ucGFyZW50Tm9kZSk7XG4gICAgLy8gZGV0ZWN0IHRoZSBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgdmFyIGlzU3R5bGVBdHRyID0gYXR0ck5hbWUgPT09ICdzdHlsZSc7XG4gICAgdmFyIGlzQ2xhc3NBdHRyID0gYXR0ck5hbWUgPT09ICdjbGFzcyc7XG5cbiAgICB2YXIgdmFsdWU7XG5cbiAgICAvLyBpZiBpdCdzIGEgdGFnIHdlIGNvdWxkIHRvdGFsbHkgc2tpcCB0aGUgcmVzdFxuICAgIGlmIChleHByLl9yaW90X2lkKSB7XG4gICAgICBpZiAoZXhwci5fXy53YXNDcmVhdGVkKSB7XG4gICAgICAgIGV4cHIudXBkYXRlKCk7XG4gICAgICAvLyBpZiBpdCBoYXNuJ3QgYmVlbiBtb3VudGVkIHlldCwgZG8gdGhhdCBub3cuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByLm1vdW50KCk7XG4gICAgICAgIGlmIChpc1ZpcnR1YWwpIHtcbiAgICAgICAgICBtYWtlUmVwbGFjZVZpcnR1YWwoZXhwciwgZXhwci5yb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBleHByZXNzaW9uIGhhcyB0aGUgdXBkYXRlIG1ldGhvZCBpdCBtZWFucyBpdCBjYW4gaGFuZGxlIHRoZSBET00gY2hhbmdlcyBieSBpdHNlbGZcbiAgICBpZiAoZXhwci51cGRhdGUpIHsgcmV0dXJuIGV4cHIudXBkYXRlKCkgfVxuXG4gICAgdmFyIGNvbnRleHQgPSBpc1RvZ2dsZSAmJiAhaXNBbm9ueW1vdXMgPyBpbmhlcml0UGFyZW50UHJvcHMuY2FsbCh0aGlzKSA6IHRoaXM7XG5cbiAgICAvLyAuLi5pdCBzZWVtcyB0byBiZSBhIHNpbXBsZSBleHByZXNzaW9uIHNvIHdlIHRyeSB0byBjYWxjdWxhdGUgaXRzIHZhbHVlXG4gICAgdmFsdWUgPSB0bXBsKGV4cHIuZXhwciwgY29udGV4dCk7XG5cbiAgICB2YXIgaGFzVmFsdWUgPSAhaXNCbGFuayh2YWx1ZSk7XG4gICAgdmFyIGlzT2JqID0gaXNPYmplY3QodmFsdWUpO1xuXG4gICAgLy8gY29udmVydCB0aGUgc3R5bGUvY2xhc3Mgb2JqZWN0cyB0byBzdHJpbmdzXG4gICAgaWYgKGlzT2JqKSB7XG4gICAgICBpZiAoaXNDbGFzc0F0dHIpIHtcbiAgICAgICAgdmFsdWUgPSB0bXBsKEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3R5bGVBdHRyKSB7XG4gICAgICAgIHZhbHVlID0gc3R5bGVPYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIG9yaWdpbmFsIGF0dHJpYnV0ZVxuICAgIGlmIChleHByLmF0dHIgJiYgKCFleHByLndhc1BhcnNlZE9uY2UgfHwgIWhhc1ZhbHVlIHx8IHZhbHVlID09PSBmYWxzZSkpIHtcbiAgICAgIC8vIHJlbW92ZSBlaXRoZXIgcmlvdC0qIGF0dHJpYnV0ZXMgb3IganVzdCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShkb20sIGdldEF0dHJpYnV0ZShkb20sIGV4cHIuYXR0cikgPyBleHByLmF0dHIgOiBhdHRyTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZXMgd2UgZG9uJ3QgbmVlZCB0aGUgdmFsdWVcbiAgICAvLyB3ZSBjYW4gY29udmVydCBpdCB0byBjaGVja2VkPXRydWUgdG8gY2hlY2tlZD1jaGVja2VkXG4gICAgaWYgKGV4cHIuYm9vbCkgeyB2YWx1ZSA9IHZhbHVlID8gYXR0ck5hbWUgOiBmYWxzZTsgfVxuICAgIGlmIChleHByLmlzUnRhZykgeyByZXR1cm4gdXBkYXRlRGF0YUlzKGV4cHIsIHRoaXMsIHZhbHVlKSB9XG4gICAgaWYgKGV4cHIud2FzUGFyc2VkT25jZSAmJiBleHByLnZhbHVlID09PSB2YWx1ZSkgeyByZXR1cm4gfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBleHByZXNzaW9uIHZhbHVlXG4gICAgZXhwci52YWx1ZSA9IHZhbHVlO1xuICAgIGV4cHIud2FzUGFyc2VkT25jZSA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChhbmQgaXQncyBub3QgYSBzdHlsZSBvciBjbGFzcyBhdHRyaWJ1dGUpIHdlIGNhbiBub3QgZG8gbXVjaCBtb3JlIHdpdGggaXRcbiAgICBpZiAoaXNPYmogJiYgIWlzQ2xhc3NBdHRyICYmICFpc1N0eWxlQXR0ciAmJiAhaXNUb2dnbGUpIHsgcmV0dXJuIH1cbiAgICAvLyBhdm9pZCB0byByZW5kZXIgdW5kZWZpbmVkL251bGwgdmFsdWVzXG4gICAgaWYgKCFoYXNWYWx1ZSkgeyB2YWx1ZSA9ICcnOyB9XG5cbiAgICAvLyB0ZXh0YXJlYSBhbmQgdGV4dCBub2RlcyBoYXZlIG5vIGF0dHJpYnV0ZSBuYW1lXG4gICAgaWYgKCFhdHRyTmFtZSkge1xuICAgICAgLy8gYWJvdXQgIzgxNSB3L28gcmVwbGFjZTogdGhlIGJyb3dzZXIgY29udmVydHMgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLFxuICAgICAgLy8gdGhlIGNvbXBhcmlzb24gYnkgXCI9PVwiIGRvZXMgdG9vLCBidXQgbm90IGluIHRoZSBzZXJ2ZXJcbiAgICAgIHZhbHVlICs9ICcnO1xuICAgICAgLy8gdGVzdCBmb3IgcGFyZW50IGF2b2lkcyBlcnJvciB3aXRoIGludmFsaWQgYXNzaWdubWVudCB0byBub2RlVmFsdWVcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIHBhcmVudCBub2RlIGJlY2F1c2Ugc29tZWhvdyBpdCB3aWxsIGJlY29tZSBudWxsIG9uIElFXG4gICAgICAgIC8vIG9uIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICBleHByLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgcGFyZW50LnZhbHVlID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAvLyAjMTExM1xuICAgICAgICAgIGlmICghSUVfVkVSU0lPTikgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH0gIC8vICMxNjI1IElFIHRocm93cyBoZXJlLCBub2RlVmFsdWVcbiAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBhdmFpbGFibGUgb24gJ3VwZGF0ZWQnXG4gICAgICAgIGVsc2UgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH1cbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuXG4gICAgLy8gZXZlbnQgaGFuZGxlclxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgc2V0RXZlbnRIYW5kbGVyKGF0dHJOYW1lLCB2YWx1ZSwgZG9tLCB0aGlzKTtcbiAgICAvLyBzaG93IC8gaGlkZVxuICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUpIHtcbiAgICAgIHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBhdHRyTmFtZSA9PT0gSElERV9ESVJFQ1RJVkUgPyAhdmFsdWUgOiB2YWx1ZSk7XG4gICAgLy8gaGFuZGxlIGF0dHJpYnV0ZXNcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4cHIuYm9vbCkge1xuICAgICAgICBkb21bYXR0ck5hbWVdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ3ZhbHVlJyAmJiBkb20udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIGRvbS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChoYXNWYWx1ZSAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0QXR0cmlidXRlKGRvbSwgYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgaW4gY2FzZSBvZiBzdHlsZSBjaGFuZ2VzXG4gICAgICAvLyB0aGUgZWxlbWVudCBzdGF5cyBoaWRkZW5cbiAgICAgIGlmIChpc1N0eWxlQXR0ciAmJiBkb20uaGlkZGVuKSB7IHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBmYWxzZSk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFsbCB0aGUgZXhwcmVzc2lvbnMgaW4gYSBUYWcgaW5zdGFuY2VcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IEFycmF5IH0gZXhwcmVzc2lvbnMgLSBleHByZXNzaW9uIHRoYXQgbXVzdCBiZSByZSBldmFsdWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZShleHByZXNzaW9ucykge1xuICAgIGVhY2goZXhwcmVzc2lvbnMsIHVwZGF0ZUV4cHJlc3Npb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogV2UgbmVlZCB0byB1cGRhdGUgb3B0cyBmb3IgdGhpcyB0YWcuIFRoYXQgcmVxdWlyZXMgdXBkYXRpbmcgdGhlIGV4cHJlc3Npb25zXG4gICAqIGluIGFueSBhdHRyaWJ1dGVzIG9uIHRoZSB0YWcsIGFuZCB0aGVuIGNvcHlpbmcgdGhlIHJlc3VsdCBvbnRvIG9wdHMuXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7Qm9vbGVhbn0gaXNMb29wIC0gaXMgaXQgYSBsb29wIHRhZz9cbiAgICogQHBhcmFtICAgeyBUYWcgfSAgcGFyZW50IC0gcGFyZW50IHRhZyBub2RlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9ICBpc0Fub255bW91cyAtIGlzIGl0IGEgdGFnIHdpdGhvdXQgYW55IGltcGw/IChhIHRhZyBub3QgcmVnaXN0ZXJlZClcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgb3B0cyAtIHRhZyBvcHRpb25zXG4gICAqIEBwYXJhbSAgIHsgQXJyYXkgfSAgaW5zdEF0dHJzIC0gdGFnIGF0dHJpYnV0ZXMgYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZU9wdHMoaXNMb29wLCBwYXJlbnQsIGlzQW5vbnltb3VzLCBvcHRzLCBpbnN0QXR0cnMpIHtcbiAgICAvLyBpc0Fub255bW91cyBgZWFjaGAgdGFncyB0cmVhdCBgZG9tYCBhbmQgYHJvb3RgIGRpZmZlcmVudGx5LiBJbiB0aGlzIGNhc2VcbiAgICAvLyAoYW5kIG9ubHkgdGhpcyBjYXNlKSB3ZSBkb24ndCBuZWVkIHRvIGRvIHVwZGF0ZU9wdHMsIGJlY2F1c2UgdGhlIHJlZ3VsYXIgcGFyc2VcbiAgICAvLyB3aWxsIHVwZGF0ZSB0aG9zZSBhdHRycy4gUGx1cywgaXNBbm9ueW1vdXMgdGFncyBkb24ndCBuZWVkIG9wdHMgYW55d2F5XG4gICAgaWYgKGlzTG9vcCAmJiBpc0Fub255bW91cykgeyByZXR1cm4gfVxuICAgIHZhciBjdHggPSBpc0xvb3AgPyBpbmhlcml0UGFyZW50UHJvcHMuY2FsbCh0aGlzKSA6IHBhcmVudCB8fCB0aGlzO1xuXG4gICAgZWFjaChpbnN0QXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICBpZiAoYXR0ci5leHByKSB7IHVwZGF0ZUV4cHJlc3Npb24uY2FsbChjdHgsIGF0dHIuZXhwcik7IH1cbiAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgYXR0cmlidXRlIG5hbWVzXG4gICAgICBvcHRzW3RvQ2FtZWwoYXR0ci5uYW1lKS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpXSA9IGF0dHIuZXhwciA/IGF0dHIuZXhwci52YWx1ZSA6IGF0dHIudmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0YWcgZXhwcmVzc2lvbnMgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFnIC0gdGFnIG9iamVjdFxuICAgKiBAcGFyYW0geyAqIH0gZGF0YSAtIGRhdGEgd2Ugd2FudCB0byB1c2UgdG8gZXh0ZW5kIHRoZSB0YWcgcHJvcGVydGllc1xuICAgKiBAcGFyYW0geyBBcnJheSB9IGV4cHJlc3Npb25zIC0gY29tcG9uZW50IGV4cHJlc3Npb25zIGFycmF5XG4gICAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGUodGFnLCBkYXRhLCBleHByZXNzaW9ucykge1xuICAgIHZhciBfXyA9IHRhZy5fXztcbiAgICB2YXIgbmV4dE9wdHMgPSB7fTtcbiAgICB2YXIgY2FuVHJpZ2dlciA9IHRhZy5pc01vdW50ZWQgJiYgIV9fLnNraXBBbm9ueW1vdXM7XG5cbiAgICAvLyBpbmhlcml0IHByb3BlcnRpZXMgZnJvbSB0aGUgcGFyZW50IHRhZ1xuICAgIGlmIChfXy5pc0Fub255bW91cyAmJiBfXy5wYXJlbnQpIHsgZXh0ZW5kKHRhZywgX18ucGFyZW50KTsgfVxuICAgIGV4dGVuZCh0YWcsIGRhdGEpO1xuXG4gICAgdXBkYXRlT3B0cy5hcHBseSh0YWcsIFtfXy5pc0xvb3AsIF9fLnBhcmVudCwgX18uaXNBbm9ueW1vdXMsIG5leHRPcHRzLCBfXy5pbnN0QXR0cnNdKTtcblxuICAgIGlmIChcbiAgICAgIGNhblRyaWdnZXIgJiZcbiAgICAgIHRhZy5pc01vdW50ZWQgJiZcbiAgICAgIGlzRnVuY3Rpb24odGFnLnNob3VsZFVwZGF0ZSkgJiYgIXRhZy5zaG91bGRVcGRhdGUoZGF0YSwgbmV4dE9wdHMpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGFnXG4gICAgfVxuXG4gICAgZXh0ZW5kKHRhZy5vcHRzLCBuZXh0T3B0cyk7XG5cbiAgICBpZiAoY2FuVHJpZ2dlcikgeyB0YWcudHJpZ2dlcigndXBkYXRlJywgZGF0YSk7IH1cbiAgICB1cGRhdGUuY2FsbCh0YWcsIGV4cHJlc3Npb25zKTtcbiAgICBpZiAoY2FuVHJpZ2dlcikgeyB0YWcudHJpZ2dlcigndXBkYXRlZCcpOyB9XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuICAvKipcbiAgICogR2V0IHNlbGVjdG9ycyBmb3IgdGFnc1xuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIHRhZyBuYW1lcyB0byBzZWxlY3RcbiAgICogQHJldHVybnMgeyBTdHJpbmcgfSBzZWxlY3RvclxuICAgKi9cbiAgZnVuY3Rpb24gcXVlcnkodGFncykge1xuICAgIC8vIHNlbGVjdCBhbGwgdGFnc1xuICAgIGlmICghdGFncykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfX1RBR19JTVBMKTtcbiAgICAgIHJldHVybiBrZXlzICsgcXVlcnkoa2V5cylcbiAgICB9XG5cbiAgICByZXR1cm4gdGFnc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gIS9bXi1cXHddLy50ZXN0KHQpOyB9KVxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAobGlzdCwgdCkge1xuICAgICAgICB2YXIgbmFtZSA9IHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsaXN0ICsgXCIsW1wiICsgSVNfRElSRUNUSVZFICsgXCI9XFxcIlwiICsgbmFtZSArIFwiXFxcIl1cIlxuICAgICAgfSwgJycpXG4gIH1cblxuICAvKipcbiAgICogQW5vdGhlciB3YXkgdG8gY3JlYXRlIGEgcmlvdCB0YWcgYSBiaXQgbW9yZSBlczYgZnJpZW5kbHlcbiAgICogQHBhcmFtIHsgSFRNTEVsZW1lbnQgfSBlbCAtIHRhZyBET00gc2VsZWN0b3Igb3IgRE9NIG5vZGUvc1xuICAgKiBAcGFyYW0geyBPYmplY3QgfSBvcHRzIC0gdGFnIGxvZ2ljXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gbmV3IHJpb3QgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBUYWcoZWwsIG9wdHMpIHtcbiAgICAvLyBnZXQgdGhlIHRhZyBwcm9wZXJ0aWVzIGZyb20gdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICB2YXIgdG1wbCA9IHJlZi50bXBsO1xuICAgIHZhciBjc3MgPSByZWYuY3NzO1xuICAgIHZhciBhdHRycyA9IHJlZi5hdHRycztcbiAgICB2YXIgb25DcmVhdGUgPSByZWYub25DcmVhdGU7XG4gICAgLy8gcmVnaXN0ZXIgYSBuZXcgdGFnIGFuZCBjYWNoZSB0aGUgY2xhc3MgcHJvdG90eXBlXG4gICAgaWYgKCFfX1RBR19JTVBMW25hbWVdKSB7XG4gICAgICB0YWcobmFtZSwgdG1wbCwgY3NzLCBhdHRycywgb25DcmVhdGUpO1xuICAgICAgLy8gY2FjaGUgdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgICBfX1RBR19JTVBMW25hbWVdLmNsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICAvLyBtb3VudCB0aGUgdGFnIHVzaW5nIHRoZSBjbGFzcyBpbnN0YW5jZVxuICAgIG1vdW50JDEoZWwsIG5hbWUsIG9wdHMsIHRoaXMpO1xuICAgIC8vIGluamVjdCB0aGUgY29tcG9uZW50IGNzc1xuICAgIGlmIChjc3MpIHsgc3R5bGVNYW5hZ2VyLmluamVjdCgpOyB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyByaW90IHRhZyBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgbmFtZSAtIG5hbWUvaWQgb2YgdGhlIG5ldyByaW90IHRhZ1xuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgdG1wbCAtIHRhZyB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgY3NzIC0gY3VzdG9tIHRhZyBjc3NcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGF0dHJzIC0gcm9vdCB0YWcgYXR0cmlidXRlc1xuICAgKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSB1c2VyIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbmFtZS9pZCBvZiB0aGUgdGFnIGp1c3QgY3JlYXRlZFxuICAgKi9cbiAgZnVuY3Rpb24gdGFnKG5hbWUsIHRtcGwsIGNzcywgYXR0cnMsIGZuKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oYXR0cnMpKSB7XG4gICAgICBmbiA9IGF0dHJzO1xuXG4gICAgICBpZiAoL15bXFx3LV0rXFxzPz0vLnRlc3QoY3NzKSkge1xuICAgICAgICBhdHRycyA9IGNzcztcbiAgICAgICAgY3NzID0gJyc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgeyBhdHRycyA9ICcnOyB9XG4gICAgfVxuXG4gICAgaWYgKGNzcykge1xuICAgICAgaWYgKGlzRnVuY3Rpb24oY3NzKSlcbiAgICAgICAgeyBmbiA9IGNzczsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHN0eWxlTWFuYWdlci5hZGQoY3NzLCBuYW1lKTsgfVxuICAgIH1cblxuICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJpb3QgdGFnIGltcGxlbWVudGF0aW9uIChmb3IgdXNlIGJ5IHRoZSBjb21waWxlcilcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIG5hbWUgLSBuYW1lL2lkIG9mIHRoZSBuZXcgcmlvdCB0YWdcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIHRtcGwgLSB0YWcgdGVtcGxhdGVcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGNzcyAtIGN1c3RvbSB0YWcgY3NzXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBhdHRycyAtIHJvb3QgdGFnIGF0dHJpYnV0ZXNcbiAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gdXNlciBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7IFN0cmluZyB9IG5hbWUvaWQgb2YgdGhlIHRhZyBqdXN0IGNyZWF0ZWRcbiAgICovXG4gIGZ1bmN0aW9uIHRhZzIobmFtZSwgdG1wbCwgY3NzLCBhdHRycywgZm4pIHtcbiAgICBpZiAoY3NzKSB7IHN0eWxlTWFuYWdlci5hZGQoY3NzLCBuYW1lKTsgfVxuXG4gICAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvKipcbiAgICogTW91bnQgYSB0YWcgdXNpbmcgYSBzcGVjaWZpYyB0YWcgaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtICAgeyAqIH0gc2VsZWN0b3IgLSB0YWcgRE9NIHNlbGVjdG9yIG9yIERPTSBub2RlL3NcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIG5hbWVcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSBvcHRzIC0gdGFnIGxvZ2ljXG4gICAqIEByZXR1cm5zIHsgQXJyYXkgfSBuZXcgdGFncyBpbnN0YW5jZXNcbiAgICovXG4gIGZ1bmN0aW9uIG1vdW50KHNlbGVjdG9yLCB0YWdOYW1lLCBvcHRzKSB7XG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICB2YXIgZWxlbSwgYWxsVGFncztcblxuICAgIGZ1bmN0aW9uIHB1c2hUYWdzVG8ocm9vdCkge1xuICAgICAgaWYgKHJvb3QudGFnTmFtZSkge1xuICAgICAgICB2YXIgcmlvdFRhZyA9IGdldEF0dHJpYnV0ZShyb290LCBJU19ESVJFQ1RJVkUpLCB0YWc7XG5cbiAgICAgICAgLy8gaGF2ZSB0YWdOYW1lPyBmb3JjZSByaW90LXRhZyB0byBiZSB0aGUgc2FtZVxuICAgICAgICBpZiAodGFnTmFtZSAmJiByaW90VGFnICE9PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcmlvdFRhZyA9IHRhZ05hbWU7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKHJvb3QsIElTX0RJUkVDVElWRSwgdGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWcgPSBtb3VudCQxKHJvb3QsIHJpb3RUYWcgfHwgcm9vdC50YWdOYW1lLnRvTG93ZXJDYXNlKCksIG9wdHMpO1xuXG4gICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgeyB0YWdzLnB1c2godGFnKTsgfVxuICAgICAgfSBlbHNlIGlmIChyb290Lmxlbmd0aClcbiAgICAgICAgeyBlYWNoKHJvb3QsIHB1c2hUYWdzVG8pOyB9IC8vIGFzc3VtZSBub2RlTGlzdFxuICAgIH1cblxuICAgIC8vIGluamVjdCBzdHlsZXMgaW50byBET01cbiAgICBzdHlsZU1hbmFnZXIuaW5qZWN0KCk7XG5cbiAgICBpZiAoaXNPYmplY3QodGFnTmFtZSkpIHtcbiAgICAgIG9wdHMgPSB0YWdOYW1lO1xuICAgICAgdGFnTmFtZSA9IDA7XG4gICAgfVxuXG4gICAgLy8gY3Jhd2wgdGhlIERPTSB0byBmaW5kIHRoZSB0YWdcbiAgICBpZiAoaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yID09PSAnKicgP1xuICAgICAgICAvLyBzZWxlY3QgYWxsIHJlZ2lzdGVyZWQgdGFnc1xuICAgICAgICAvLyAmIHRhZ3MgZm91bmQgd2l0aCB0aGUgcmlvdC10YWcgYXR0cmlidXRlIHNldFxuICAgICAgICBhbGxUYWdzID0gcXVlcnkoKSA6XG4gICAgICAgIC8vIG9yIGp1c3QgdGhlIG9uZXMgbmFtZWQgbGlrZSB0aGUgc2VsZWN0b3JcbiAgICAgICAgc2VsZWN0b3IgKyBxdWVyeShzZWxlY3Rvci5zcGxpdCgvLCAqLykpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gcGFzcyBhbHdheXMgYSBzZWxlY3RvclxuICAgICAgLy8gdG8gdGhlIHF1ZXJ5U2VsZWN0b3JBbGwgZnVuY3Rpb25cbiAgICAgIGVsZW0gPSBzZWxlY3RvciA/ICQkKHNlbGVjdG9yKSA6IFtdO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAvLyBwcm9iYWJseSB5b3UgaGF2ZSBwYXNzZWQgYWxyZWFkeSBhIHRhZyBvciBhIE5vZGVMaXN0XG4gICAgICB7IGVsZW0gPSBzZWxlY3RvcjsgfVxuXG4gICAgLy8gc2VsZWN0IGFsbCB0aGUgcmVnaXN0ZXJlZCBhbmQgbW91bnQgdGhlbSBpbnNpZGUgdGhlaXIgcm9vdCBlbGVtZW50c1xuICAgIGlmICh0YWdOYW1lID09PSAnKicpIHtcbiAgICAgIC8vIGdldCBhbGwgY3VzdG9tIHRhZ3NcbiAgICAgIHRhZ05hbWUgPSBhbGxUYWdzIHx8IHF1ZXJ5KCk7XG4gICAgICAvLyBpZiB0aGUgcm9vdCBlbHMgaXQncyBqdXN0IGEgc2luZ2xlIHRhZ1xuICAgICAgaWYgKGVsZW0udGFnTmFtZSlcbiAgICAgICAgeyBlbGVtID0gJCQodGFnTmFtZSwgZWxlbSk7IH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBzZWxlY3QgYWxsIHRoZSBjaGlsZHJlbiBmb3IgYWxsIHRoZSBkaWZmZXJlbnQgcm9vdCBlbGVtZW50c1xuICAgICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcblxuICAgICAgICBlYWNoKGVsZW0sIGZ1bmN0aW9uIChfZWwpIHsgcmV0dXJuIG5vZGVMaXN0LnB1c2goJCQodGFnTmFtZSwgX2VsKSk7IH0pO1xuXG4gICAgICAgIGVsZW0gPSBub2RlTGlzdDtcbiAgICAgIH1cbiAgICAgIC8vIGdldCByaWQgb2YgdGhlIHRhZ05hbWVcbiAgICAgIHRhZ05hbWUgPSAwO1xuICAgIH1cblxuICAgIHB1c2hUYWdzVG8oZWxlbSk7XG5cbiAgICByZXR1cm4gdGFnc1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWl4aW4gdGhhdCBjb3VsZCBiZSBnbG9iYWxseSBzaGFyZWQgYWNyb3NzIGFsbCB0aGUgdGFnc1xuICB2YXIgbWl4aW5zID0ge307XG4gIHZhciBnbG9iYWxzID0gbWl4aW5zW0dMT0JBTF9NSVhJTl0gPSB7fTtcbiAgdmFyIG1peGluc19pZCA9IDA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZS9SZXR1cm4gYSBtaXhpbiBieSBpdHMgbmFtZVxuICAgKiBAcGFyYW0gICB7IFN0cmluZyB9ICBuYW1lIC0gbWl4aW4gbmFtZSAoZ2xvYmFsIG1peGluIGlmIG9iamVjdClcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAgbWl4IC0gbWl4aW4gbG9naWNcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gZyAtIGlzIGdsb2JhbD9cbiAgICogQHJldHVybnMgeyBPYmplY3QgfSAgdGhlIG1peGluIGxvZ2ljXG4gICAqL1xuICBmdW5jdGlvbiBtaXhpbihuYW1lLCBtaXgsIGcpIHtcbiAgICAvLyBVbm5hbWVkIGdsb2JhbFxuICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgbWl4aW4oKFwiX19cIiArIChtaXhpbnNfaWQrKykgKyBcIl9fXCIpLCBuYW1lLCB0cnVlKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdG9yZSA9IGcgPyBnbG9iYWxzIDogbWl4aW5zO1xuXG4gICAgLy8gR2V0dGVyXG4gICAgaWYgKCFtaXgpIHtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChzdG9yZVtuYW1lXSkpXG4gICAgICAgIHsgdGhyb3cgbmV3IEVycm9yKChcIlVucmVnaXN0ZXJlZCBtaXhpbjogXCIgKyBuYW1lKSkgfVxuXG4gICAgICByZXR1cm4gc3RvcmVbbmFtZV1cbiAgICB9XG5cbiAgICAvLyBTZXR0ZXJcbiAgICBzdG9yZVtuYW1lXSA9IGlzRnVuY3Rpb24obWl4KSA/XG4gICAgICBleHRlbmQobWl4LnByb3RvdHlwZSwgc3RvcmVbbmFtZV0gfHwge30pICYmIG1peCA6XG4gICAgICBleHRlbmQoc3RvcmVbbmFtZV0gfHwge30sIG1peCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGFsbCB0aGUgdGFncyBpbnN0YW5jZXMgY3JlYXRlZFxuICAgKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSB0YWdzIGluc3RhbmNlc1xuICAgKi9cbiAgZnVuY3Rpb24gdXBkYXRlJDEoKSB7XG4gICAgcmV0dXJuIGVhY2goX19UQUdTX0NBQ0hFLCBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcudXBkYXRlKCk7IH0pXG4gIH1cblxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICBzdHlsZU1hbmFnZXIucmVtb3ZlKG5hbWUpO1xuICAgIHJldHVybiBkZWxldGUgX19UQUdfSU1QTFtuYW1lXVxuICB9XG5cbiAgdmFyIHZlcnNpb24gPSAndjMuOS40JztcblxuICB2YXIgY29yZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBUYWc6IFRhZyxcbiAgICB0YWc6IHRhZyxcbiAgICB0YWcyOiB0YWcyLFxuICAgIG1vdW50OiBtb3VudCxcbiAgICBtaXhpbjogbWl4aW4sXG4gICAgdXBkYXRlOiB1cGRhdGUkMSxcbiAgICB1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyLFxuICAgIHZlcnNpb246IHZlcnNpb25cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1peGluIHRvIHRoaXMgdGFnXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wb25lbnRNaXhpbih0YWckJDEpIHtcbiAgICB2YXIgbWl4aW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgbWl4aW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgZWFjaChtaXhpbnMsIGZ1bmN0aW9uIChtaXgpIHtcbiAgICAgIHZhciBpbnN0YW5jZTtcbiAgICAgIHZhciBvYmo7XG4gICAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgICAgLy8gcHJvcGVydGllcyBibGFja2xpc3RlZCBhbmQgd2lsbCBub3QgYmUgYm91bmQgdG8gdGhlIHRhZyBpbnN0YW5jZVxuICAgICAgdmFyIHByb3BzQmxhY2tsaXN0ID0gWydpbml0JywgJ19fcHJvdG9fXyddO1xuXG4gICAgICBtaXggPSBpc1N0cmluZyhtaXgpID8gbWl4aW4obWl4KSA6IG1peDtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIG1peGluIGlzIGEgZnVuY3Rpb25cbiAgICAgIGlmIChpc0Z1bmN0aW9uKG1peCkpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgbWl4aW4gaW5zdGFuY2VcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgbWl4KCk7XG4gICAgICB9IGVsc2UgeyBpbnN0YW5jZSA9IG1peDsgfVxuXG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpO1xuXG4gICAgICAvLyBidWlsZCBtdWx0aWxldmVsIHByb3RvdHlwZSBpbmhlcml0YW5jZSBjaGFpbiBwcm9wZXJ0eSBsaXN0XG4gICAgICBkbyB7IHByb3BzID0gcHJvcHMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaiB8fCBpbnN0YW5jZSkpOyB9XG4gICAgICB3aGlsZSAob2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaiB8fCBpbnN0YW5jZSkpXG5cbiAgICAgIC8vIGxvb3AgdGhlIGtleXMgaW4gdGhlIGZ1bmN0aW9uIHByb3RvdHlwZSBvciB0aGUgYWxsIG9iamVjdCBrZXlzXG4gICAgICBlYWNoKHByb3BzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIGJpbmQgbWV0aG9kcyB0byB0YWdcbiAgICAgICAgLy8gYWxsb3cgbWl4aW5zIHRvIG92ZXJyaWRlIG90aGVyIHByb3BlcnRpZXMvcGFyZW50IG1peGluc1xuICAgICAgICBpZiAoIWNvbnRhaW5zKHByb3BzQmxhY2tsaXN0LCBrZXkpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGdldHRlcnMvc2V0dGVyc1xuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0UHJvcERlc2NyaXB0b3IoaW5zdGFuY2UsIGtleSkgfHwgZ2V0UHJvcERlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgICAgdmFyIGhhc0dldHRlclNldHRlciA9IGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KTtcblxuICAgICAgICAgIC8vIGFwcGx5IG1ldGhvZCBvbmx5IGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3Qgb24gdGhlIGluc3RhbmNlXG4gICAgICAgICAgaWYgKCF0YWckJDEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBoYXNHZXR0ZXJTZXR0ZXIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YWckJDEsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhZyQkMVtrZXldID0gaXNGdW5jdGlvbihpbnN0YW5jZVtrZXldKSA/XG4gICAgICAgICAgICAgIGluc3RhbmNlW2tleV0uYmluZCh0YWckJDEpIDpcbiAgICAgICAgICAgICAgaW5zdGFuY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBpbml0IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5XG4gICAgICBpZiAoaW5zdGFuY2UuaW5pdClcbiAgICAgICAgeyBpbnN0YW5jZS5pbml0LmJpbmQodGFnJCQxKSh0YWckJDEub3B0cyk7IH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0YWckJDFcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBwb3NpdGlvbiBvZiBhIGN1c3RvbSB0YWcgaW4gaXRzIHBhcmVudCB0YWdcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGFnTmFtZSAtIGtleSB3aGVyZSB0aGUgdGFnIHdhcyBzdG9yZWRcbiAgICogQHBhcmFtICAgeyBOdW1iZXIgfSBuZXdQb3MgLSBpbmRleCB3aGVyZSB0aGUgbmV3IHRhZyB3aWxsIGJlIHN0b3JlZFxuICAgKi9cbiAgZnVuY3Rpb24gbW92ZUNoaWxkKHRhZ05hbWUsIG5ld1Bvcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICB2YXIgdGFncztcbiAgICAvLyBubyBwYXJlbnQgbm8gbW92ZVxuICAgIGlmICghcGFyZW50KSB7IHJldHVybiB9XG5cbiAgICB0YWdzID0gcGFyZW50LnRhZ3NbdGFnTmFtZV07XG5cbiAgICBpZiAoaXNBcnJheSh0YWdzKSlcbiAgICAgIHsgdGFncy5zcGxpY2UobmV3UG9zLCAwLCB0YWdzLnNwbGljZSh0YWdzLmluZGV4T2YodGhpcyksIDEpWzBdKTsgfVxuICAgIGVsc2UgeyBhcnJheWlzaEFkZChwYXJlbnQudGFncywgdGFnTmFtZSwgdGhpcyk7IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHZpcnR1YWwgdGFnIGFuZCBhbGwgY2hpbGQgbm9kZXNcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IE5vZGUgfSBzcmMgIC0gdGhlIG5vZGUgdGhhdCB3aWxsIGRvIHRoZSBpbnNlcnRpbmdcbiAgICogQHBhcmFtIHsgVGFnIH0gdGFyZ2V0IC0gaW5zZXJ0IGJlZm9yZSB0aGlzIHRhZydzIGZpcnN0IGNoaWxkXG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlVmlydHVhbChzcmMsIHRhcmdldCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGVsID0gdGhpcy5fXy5oZWFkO1xuICAgIHZhciBzaWI7XG4gICAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBzaWIgPSBlbC5uZXh0U2libGluZztcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgZWwgPSBzaWI7XG4gICAgICBpZiAoZWwgPT09IHRoaXMkMS5fXy50YWlsKSB7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICBzcmMuaW5zZXJ0QmVmb3JlKGZyYWcsIHRhcmdldC5fXy5oZWFkKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgaXRlbSBsb29wZWQgaW50byBhbiBvYmplY3QgdXNlZCB0byBleHRlbmQgdGhlIGNoaWxkIHRhZyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZXhwciAtIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXlzIHVzZWQgdG8gZXh0ZW5kIHRoZSBjaGlsZHJlbiB0YWdzXG4gICAqIEBwYXJhbSAgIHsgKiB9IGtleSAtIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgbmV3IG9iamVjdCByZXR1cm5lZFxuICAgKiBAcGFyYW0gICB7ICogfSB2YWwgLSB2YWx1ZSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgYXJyYXlcbiAgICogQHJldHVybnMgeyBPYmplY3QgfSAtIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCBpdGVtXG4gICAqXG4gICAqIFRoZSB2YXJpYWJsZXMgJ2tleScgYW5kICd2YWwnIGFyZSBhcmJpdHJhcnkuXG4gICAqIFRoZXkgZGVwZW5kIG9uIHRoZSBjb2xsZWN0aW9uIHR5cGUgbG9vcGVkIChBcnJheSwgT2JqZWN0KVxuICAgKiBhbmQgb24gdGhlIGV4cHJlc3Npb24gdXNlZCBvbiB0aGUgZWFjaCB0YWdcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIG1raXRlbShleHByLCBrZXksIHZhbCkge1xuICAgIHZhciBpdGVtID0ge307XG4gICAgaXRlbVtleHByLmtleV0gPSBrZXk7XG4gICAgaWYgKGV4cHIucG9zKSB7IGl0ZW1bZXhwci5wb3NdID0gdmFsOyB9XG4gICAgcmV0dXJuIGl0ZW1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbm1vdW50IHRoZSByZWR1bmRhbnQgdGFnc1xuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gaXRlbXMgLSBhcnJheSBjb250YWluaW5nIHRoZSBjdXJyZW50IGl0ZW1zIHRvIGxvb3BcbiAgICogQHBhcmFtICAgeyBBcnJheSB9IHRhZ3MgLSBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgY2hpbGRyZW4gdGFnc1xuICAgKi9cbiAgZnVuY3Rpb24gdW5tb3VudFJlZHVuZGFudChpdGVtcywgdGFncywgZmlsdGVyZWRJdGVtc0NvdW50KSB7XG4gICAgdmFyIGkgPSB0YWdzLmxlbmd0aDtcbiAgICB2YXIgaiA9IGl0ZW1zLmxlbmd0aCAtIGZpbHRlcmVkSXRlbXNDb3VudDtcblxuICAgIHdoaWxlIChpID4gaikge1xuICAgICAgaS0tO1xuICAgICAgcmVtb3ZlLmFwcGx5KHRhZ3NbaV0sIFt0YWdzLCBpXSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGEgY2hpbGQgdGFnXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIHRhZ3MgY29sbGVjdGlvblxuICAgKiBAcGFyYW0gICB7IE51bWJlciB9IGkgLSBpbmRleCBvZiB0aGUgdGFnIHRvIHJlbW92ZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlKHRhZ3MsIGkpIHtcbiAgICB0YWdzLnNwbGljZShpLCAxKTtcbiAgICB0aGlzLnVubW91bnQoKTtcbiAgICBhcnJheWlzaFJlbW92ZSh0aGlzLnBhcmVudCwgdGhpcywgdGhpcy5fXy50YWdOYW1lLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBuZXN0ZWQgY3VzdG9tIHRhZ3MgaW4gbm9uIGN1c3RvbSBsb29wIHRhZ3NcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gaSAtIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxvb3AgdGFnXG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlTmVzdGVkVGFncyhpKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBlYWNoKE9iamVjdC5rZXlzKHRoaXMudGFncyksIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICBtb3ZlQ2hpbGQuYXBwbHkodGhpcyQxLnRhZ3NbdGFnTmFtZV0sIFt0YWdOYW1lLCBpXSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSBhIGNoaWxkIHRhZ1xuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBkb20gbm9kZSBjb250YWluaW5nIGFsbCB0aGUgbG9vcCBjaGlsZHJlblxuICAgKiBAcGFyYW0gICB7IFRhZyB9IG5leHRUYWcgLSBpbnN0YW5jZSBvZiB0aGUgbmV4dCB0YWcgcHJlY2VkaW5nIHRoZSBvbmUgd2Ugd2FudCB0byBtb3ZlXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzVmlydHVhbCAtIGlzIGl0IGEgdmlydHVhbCB0YWc/XG4gICAqL1xuICBmdW5jdGlvbiBtb3ZlKHJvb3QsIG5leHRUYWcsIGlzVmlydHVhbCkge1xuICAgIGlmIChpc1ZpcnR1YWwpXG4gICAgICB7IG1vdmVWaXJ0dWFsLmFwcGx5KHRoaXMsIFtyb290LCBuZXh0VGFnXSk7IH1cbiAgICBlbHNlXG4gICAgICB7IHNhZmVJbnNlcnQocm9vdCwgdGhpcy5yb290LCBuZXh0VGFnLnJvb3QpOyB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IGFuZCBtb3VudCBhIGNoaWxkIHRhZ1xuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBkb20gbm9kZSBjb250YWluaW5nIGFsbCB0aGUgbG9vcCBjaGlsZHJlblxuICAgKiBAcGFyYW0gICB7IFRhZyB9IG5leHRUYWcgLSBpbnN0YW5jZSBvZiB0aGUgbmV4dCB0YWcgcHJlY2VkaW5nIHRoZSBvbmUgd2Ugd2FudCB0byBpbnNlcnRcbiAgICogQHBhcmFtICAgeyBCb29sZWFuIH0gaXNWaXJ0dWFsIC0gaXMgaXQgYSB2aXJ0dWFsIHRhZz9cbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydChyb290LCBuZXh0VGFnLCBpc1ZpcnR1YWwpIHtcbiAgICBpZiAoaXNWaXJ0dWFsKVxuICAgICAgeyBtYWtlVmlydHVhbC5hcHBseSh0aGlzLCBbcm9vdCwgbmV4dFRhZ10pOyB9XG4gICAgZWxzZVxuICAgICAgeyBzYWZlSW5zZXJ0KHJvb3QsIHRoaXMucm9vdCwgbmV4dFRhZy5yb290KTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhIG5ldyB0YWcgaW50byB0aGUgRE9NXG4gICAqIEB0aGlzIFRhZ1xuICAgKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gcm9vdCAtIGRvbSBub2RlIGNvbnRhaW5pbmcgYWxsIHRoZSBsb29wIGNoaWxkcmVuXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzVmlydHVhbCAtIGlzIGl0IGEgdmlydHVhbCB0YWc/XG4gICAqL1xuICBmdW5jdGlvbiBhcHBlbmQocm9vdCwgaXNWaXJ0dWFsKSB7XG4gICAgaWYgKGlzVmlydHVhbClcbiAgICAgIHsgbWFrZVZpcnR1YWwuY2FsbCh0aGlzLCByb290KTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcm9vdC5hcHBlbmRDaGlsZCh0aGlzLnJvb3QpOyB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSB3ZSB3YW50IHRvIHVzZSB0byBsb29rdXAgdGhlIHBvc3Rpb24gb2Ygb3VyIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gIGtleUF0dHIgICAgICAgICAtIGxvb2t1cCBzdHJpbmcgb3IgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gICB7ICogfSAgICAgICBvcmlnaW5hbEl0ZW0gICAgLSBvcmlnaW5hbCBpdGVtIGZyb20gdGhlIGNvbGxlY3Rpb25cbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSAga2V5ZWRJdGVtICAgICAgIC0gb2JqZWN0IGNyZWF0ZWQgYnkgcmlvdCB2aWEgeyBpdGVtLCBpIGluIGNvbGxlY3Rpb24gfVxuICAgKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBoYXNLZXlBdHRyRXhwciAgLSBmbGFnIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGtleSBpcyBhbiBleHByZXNzaW9uXG4gICAqIEByZXR1cm5zIHsgKiB9IHZhbHVlIHRoYXQgd2Ugd2lsbCB1c2UgdG8gZmlndXJlIG91dCB0aGUgaXRlbSBwb3NpdGlvbiB2aWEgY29sbGVjdGlvbi5pbmRleE9mXG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVtSWQoa2V5QXR0ciwgb3JpZ2luYWxJdGVtLCBrZXllZEl0ZW0sIGhhc0tleUF0dHJFeHByKSB7XG4gICAgaWYgKGtleUF0dHIpIHtcbiAgICAgIHJldHVybiBoYXNLZXlBdHRyRXhwciA/ICB0bXBsKGtleUF0dHIsIGtleWVkSXRlbSkgOiAgb3JpZ2luYWxJdGVtW2tleUF0dHJdXG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsSXRlbVxuICB9XG5cbiAgLyoqXG4gICAqIE1hbmFnZSB0YWdzIGhhdmluZyB0aGUgJ2VhY2gnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSBkb20gLSBET00gbm9kZSB3ZSBuZWVkIHRvIGxvb3BcbiAgICogQHBhcmFtICAgeyBUYWcgfSBwYXJlbnQgLSBwYXJlbnQgdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBkb20gbm9kZSBpcyBjb250YWluZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBleHByIC0gc3RyaW5nIGNvbnRhaW5lZCBpbiB0aGUgJ2VhY2gnIGF0dHJpYnV0ZVxuICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIGVhY2ggbG9vcFxuICAgKi9cbiAgZnVuY3Rpb24gX2VhY2goZG9tLCBwYXJlbnQsIGV4cHIpIHtcbiAgICB2YXIgbXVzdFJlb3JkZXIgPSB0eXBlb2YgZ2V0QXR0cmlidXRlKGRvbSwgTE9PUF9OT19SRU9SREVSX0RJUkVDVElWRSkgIT09IFRfU1RSSU5HIHx8IHJlbW92ZUF0dHJpYnV0ZShkb20sIExPT1BfTk9fUkVPUkRFUl9ESVJFQ1RJVkUpO1xuICAgIHZhciBrZXlBdHRyID0gZ2V0QXR0cmlidXRlKGRvbSwgS0VZX0RJUkVDVElWRSk7XG4gICAgdmFyIGhhc0tleUF0dHJFeHByID0ga2V5QXR0ciA/IHRtcGwuaGFzRXhwcihrZXlBdHRyKSA6IGZhbHNlO1xuICAgIHZhciB0YWdOYW1lID0gZ2V0TmFtZShkb20pO1xuICAgIHZhciBpbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IGRvbS5wYXJlbnROb2RlO1xuICAgIHZhciBwbGFjZWhvbGRlciA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCk7XG4gICAgdmFyIGNoaWxkID0gZ2V0KGRvbSk7XG4gICAgdmFyIGlmRXhwciA9IGdldEF0dHJpYnV0ZShkb20sIENPTkRJVElPTkFMX0RJUkVDVElWRSk7XG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICB2YXIgaXNMb29wID0gdHJ1ZTtcbiAgICB2YXIgaW5uZXJIVE1MID0gZG9tLmlubmVySFRNTDtcbiAgICB2YXIgaXNBbm9ueW1vdXMgPSAhX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgICB2YXIgaXNWaXJ0dWFsID0gZG9tLnRhZ05hbWUgPT09ICdWSVJUVUFMJztcbiAgICB2YXIgb2xkSXRlbXMgPSBbXTtcbiAgICB2YXIgaGFzS2V5cztcblxuICAgIC8vIHJlbW92ZSB0aGUgZWFjaCBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCB0YWdcbiAgICByZW1vdmVBdHRyaWJ1dGUoZG9tLCBMT09QX0RJUkVDVElWRSk7XG4gICAgcmVtb3ZlQXR0cmlidXRlKGRvbSwgS0VZX0RJUkVDVElWRSk7XG5cbiAgICAvLyBwYXJzZSB0aGUgZWFjaCBleHByZXNzaW9uXG4gICAgZXhwciA9IHRtcGwubG9vcEtleXMoZXhwcik7XG4gICAgZXhwci5pc0xvb3AgPSB0cnVlO1xuXG4gICAgaWYgKGlmRXhwcikgeyByZW1vdmVBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpOyB9XG5cbiAgICAvLyBpbnNlcnQgYSBtYXJrZWQgd2hlcmUgdGhlIGxvb3AgdGFncyB3aWxsIGJlIGluamVjdGVkXG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocGxhY2Vob2xkZXIsIGRvbSk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuXG4gICAgZXhwci51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGVFYWNoKCkge1xuICAgICAgLy8gZ2V0IHRoZSBuZXcgaXRlbXMgY29sbGVjdGlvblxuICAgICAgZXhwci52YWx1ZSA9IHRtcGwoZXhwci52YWwsIHBhcmVudCk7XG5cbiAgICAgIHZhciBpdGVtcyA9IGV4cHIudmFsdWU7XG4gICAgICB2YXIgZnJhZyA9IGNyZWF0ZUZyYWdtZW50KCk7XG4gICAgICB2YXIgaXNPYmplY3QgPSAhaXNBcnJheShpdGVtcykgJiYgIWlzU3RyaW5nKGl0ZW1zKTtcbiAgICAgIHZhciByb290ID0gcGxhY2Vob2xkZXIucGFyZW50Tm9kZTtcbiAgICAgIHZhciB0bXBJdGVtcyA9IFtdO1xuXG4gICAgICAvLyBpZiB0aGlzIERPTSB3YXMgcmVtb3ZlZCB0aGUgdXBkYXRlIGhlcmUgaXMgdXNlbGVzc1xuICAgICAgLy8gdGhpcyBjb25kaXRpb24gZml4ZXMgYWxzbyBhIHdlaXJkIGFzeW5jIGlzc3VlIG9uIElFIGluIG91ciB1bml0IHRlc3RcbiAgICAgIGlmICghcm9vdCkgeyByZXR1cm4gfVxuXG4gICAgICAvLyBvYmplY3QgbG9vcC4gYW55IGNoYW5nZXMgY2F1c2UgZnVsbCByZWRyYXdcbiAgICAgIGlmIChpc09iamVjdCkge1xuICAgICAgICBoYXNLZXlzID0gaXRlbXMgfHwgZmFsc2U7XG4gICAgICAgIGl0ZW1zID0gaGFzS2V5cyA/XG4gICAgICAgICAgT2JqZWN0LmtleXMoaXRlbXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBta2l0ZW0oZXhwciwgaXRlbXNba2V5XSwga2V5KTsgfSkgOiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc0tleXMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcmUgdGhlIGFtb3VudCBvZiBmaWx0ZXJlZCBpdGVtc1xuICAgICAgdmFyIGZpbHRlcmVkSXRlbXNDb3VudCA9IDA7XG5cbiAgICAgIC8vIGxvb3AgYWxsIHRoZSBuZXcgaXRlbXNcbiAgICAgIGVhY2goaXRlbXMsIGZ1bmN0aW9uIChfaXRlbSwgaSkge1xuICAgICAgICBpIC09IGZpbHRlcmVkSXRlbXNDb3VudDtcblxuICAgICAgICB2YXIgaXRlbSA9ICFoYXNLZXlzICYmIGV4cHIua2V5ID8gbWtpdGVtKGV4cHIsIF9pdGVtLCBpKSA6IF9pdGVtO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBpdGVtIGJlY2F1c2UgaXQgbXVzdCBiZSBmaWx0ZXJlZFxuICAgICAgICBpZiAoaWZFeHByICYmICF0bXBsKGlmRXhwciwgZXh0ZW5kKGNyZWF0ZShwYXJlbnQpLCBpdGVtKSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZEl0ZW1zQ291bnQgKys7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlbUlkID0gZ2V0SXRlbUlkKGtleUF0dHIsIF9pdGVtLCBpdGVtLCBoYXNLZXlBdHRyRXhwcik7XG4gICAgICAgIC8vIHJlb3JkZXIgb25seSBpZiB0aGUgaXRlbXMgYXJlIG9iamVjdHNcbiAgICAgICAgdmFyIGRvUmVvcmRlciA9IG11c3RSZW9yZGVyICYmIHR5cGVvZiBfaXRlbSA9PT0gVF9PQkpFQ1QgJiYgIWhhc0tleXM7XG4gICAgICAgIHZhciBvbGRQb3MgPSBvbGRJdGVtcy5pbmRleE9mKGl0ZW1JZCk7XG4gICAgICAgIHZhciBpc05ldyA9IG9sZFBvcyA9PT0gLTE7XG4gICAgICAgIHZhciBwb3MgPSAhaXNOZXcgJiYgZG9SZW9yZGVyID8gb2xkUG9zIDogaTtcbiAgICAgICAgLy8gZG9lcyBhIHRhZyBleGlzdCBpbiB0aGlzIHBvc2l0aW9uP1xuICAgICAgICB2YXIgdGFnID0gdGFnc1twb3NdO1xuICAgICAgICB2YXIgbXVzdEFwcGVuZCA9IGkgPj0gb2xkSXRlbXMubGVuZ3RoO1xuICAgICAgICB2YXIgbXVzdENyZWF0ZSA9ICBkb1Jlb3JkZXIgJiYgaXNOZXcgfHwgIWRvUmVvcmRlciAmJiAhdGFnO1xuXG4gICAgICAgIC8vIG5ldyB0YWdcbiAgICAgICAgaWYgKG11c3RDcmVhdGUpIHtcbiAgICAgICAgICB0YWcgPSBjcmVhdGVUYWcoaW1wbCwge1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBpc0xvb3A6IGlzTG9vcCxcbiAgICAgICAgICAgIGlzQW5vbnltb3VzOiBpc0Fub255bW91cyxcbiAgICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgICByb290OiBkb20uY2xvbmVOb2RlKGlzQW5vbnltb3VzKSxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICB9LCBpbm5lckhUTUwpO1xuXG4gICAgICAgICAgLy8gbW91bnQgdGhlIHRhZ1xuICAgICAgICAgIHRhZy5tb3VudCgpO1xuXG4gICAgICAgICAgaWYgKG11c3RBcHBlbmQpXG4gICAgICAgICAgICB7IGFwcGVuZC5hcHBseSh0YWcsIFtmcmFnIHx8IHJvb3QsIGlzVmlydHVhbF0pOyB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyBpbnNlcnQuYXBwbHkodGFnLCBbcm9vdCwgdGFnc1tpXSwgaXNWaXJ0dWFsXSk7IH1cblxuICAgICAgICAgIGlmICghbXVzdEFwcGVuZCkgeyBvbGRJdGVtcy5zcGxpY2UoaSwgMCwgaXRlbSk7IH1cbiAgICAgICAgICB0YWdzLnNwbGljZShpLCAwLCB0YWcpO1xuICAgICAgICAgIGlmIChjaGlsZCkgeyBhcnJheWlzaEFkZChwYXJlbnQudGFncywgdGFnTmFtZSwgdGFnLCB0cnVlKTsgfVxuICAgICAgICB9IGVsc2UgaWYgKHBvcyAhPT0gaSAmJiBkb1Jlb3JkZXIpIHtcbiAgICAgICAgICAvLyBtb3ZlXG4gICAgICAgICAgaWYgKGtleUF0dHIgfHwgY29udGFpbnMoaXRlbXMsIG9sZEl0ZW1zW3Bvc10pKSB7XG4gICAgICAgICAgICBtb3ZlLmFwcGx5KHRhZywgW3Jvb3QsIHRhZ3NbaV0sIGlzVmlydHVhbF0pO1xuICAgICAgICAgICAgLy8gbW92ZSB0aGUgb2xkIHRhZyBpbnN0YW5jZVxuICAgICAgICAgICAgdGFncy5zcGxpY2UoaSwgMCwgdGFncy5zcGxpY2UocG9zLCAxKVswXSk7XG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBvbGQgaXRlbVxuICAgICAgICAgICAgb2xkSXRlbXMuc3BsaWNlKGksIDAsIG9sZEl0ZW1zLnNwbGljZShwb3MsIDEpWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBvc2l0aW9uIGF0dHJpYnV0ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICBpZiAoZXhwci5wb3MpIHsgdGFnW2V4cHIucG9zXSA9IGk7IH1cblxuICAgICAgICAgIC8vIGlmIHRoZSBsb29wIHRhZ3MgYXJlIG5vdCBjdXN0b21cbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1vdmUgYWxsIHRoZWlyIGN1c3RvbSB0YWdzIGludG8gdGhlIHJpZ2h0IHBvc2l0aW9uXG4gICAgICAgICAgaWYgKCFjaGlsZCAmJiB0YWcudGFncykgeyBtb3ZlTmVzdGVkVGFncy5jYWxsKHRhZywgaSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhY2hlIHRoZSBvcmlnaW5hbCBpdGVtIHRvIHVzZSBpdCBpbiB0aGUgZXZlbnRzIGJvdW5kIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgaXRzIGNoaWxkcmVuXG4gICAgICAgIGV4dGVuZCh0YWcuX18sIHtcbiAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRtcEl0ZW1zW2ldID0gaXRlbUlkO1xuXG4gICAgICAgIGlmICghbXVzdENyZWF0ZSkgeyB0YWcudXBkYXRlKGl0ZW0pOyB9XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgdGFnc1xuICAgICAgdW5tb3VudFJlZHVuZGFudChpdGVtcywgdGFncywgZmlsdGVyZWRJdGVtc0NvdW50KTtcblxuICAgICAgLy8gY2xvbmUgdGhlIGl0ZW1zIGFycmF5XG4gICAgICBvbGRJdGVtcyA9IHRtcEl0ZW1zLnNsaWNlKCk7XG5cbiAgICAgIHJvb3QuaW5zZXJ0QmVmb3JlKGZyYWcsIHBsYWNlaG9sZGVyKTtcbiAgICB9O1xuXG4gICAgZXhwci51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWFjaCh0YWdzLCBmdW5jdGlvbiAodCkgeyB0LnVubW91bnQoKTsgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBleHByXG4gIH1cblxuICB2YXIgUmVmRXhwciA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbSwgcGFyZW50LCBhdHRyTmFtZSwgYXR0clZhbHVlKSB7XG4gICAgICB0aGlzLmRvbSA9IGRvbTtcbiAgICAgIHRoaXMuYXR0ciA9IGF0dHJOYW1lO1xuICAgICAgdGhpcy5yYXdWYWx1ZSA9IGF0dHJWYWx1ZTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5oYXNFeHAgPSB0bXBsLmhhc0V4cHIoYXR0clZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBvbGQgPSB0aGlzLnZhbHVlO1xuICAgICAgdmFyIGN1c3RvbVBhcmVudCA9IHRoaXMucGFyZW50ICYmIGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudCh0aGlzLnBhcmVudCk7XG4gICAgICAvLyBpZiB0aGUgcmVmZXJlbmNlZCBlbGVtZW50IGlzIGEgY3VzdG9tIHRhZywgdGhlbiB3ZSBzZXQgdGhlIHRhZyBpdHNlbGYsIHJhdGhlciB0aGFuIERPTVxuICAgICAgdmFyIHRhZ09yRG9tID0gdGhpcy5kb20uX19yZWYgfHwgdGhpcy50YWcgfHwgdGhpcy5kb207XG5cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmhhc0V4cCA/IHRtcGwodGhpcy5yYXdWYWx1ZSwgdGhpcy5wYXJlbnQpIDogdGhpcy5yYXdWYWx1ZTtcblxuICAgICAgLy8gdGhlIG5hbWUgY2hhbmdlZCwgc28gd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgb2xkIGtleSAoaWYgcHJlc2VudClcbiAgICAgIGlmICghaXNCbGFuayhvbGQpICYmIGN1c3RvbVBhcmVudCkgeyBhcnJheWlzaFJlbW92ZShjdXN0b21QYXJlbnQucmVmcywgb2xkLCB0YWdPckRvbSk7IH1cbiAgICAgIGlmICghaXNCbGFuayh0aGlzLnZhbHVlKSAmJiBpc1N0cmluZyh0aGlzLnZhbHVlKSkge1xuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIHJlZnMgb2YgcGFyZW50IHRhZyAodGhpcyBiZWhhdmlvciB3YXMgY2hhbmdlZCA+PTMuMClcbiAgICAgICAgaWYgKGN1c3RvbVBhcmVudCkgeyBhcnJheWlzaEFkZChcbiAgICAgICAgICBjdXN0b21QYXJlbnQucmVmcyxcbiAgICAgICAgICB0aGlzLnZhbHVlLFxuICAgICAgICAgIHRhZ09yRG9tLFxuICAgICAgICAgIC8vIHVzZSBhbiBhcnJheSBpZiBpdCdzIGEgbG9vcGVkIG5vZGUgYW5kIHRoZSByZWYgaXMgbm90IGFuIGV4cHJlc3Npb25cbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRoaXMucGFyZW50Ll9fLmluZGV4XG4gICAgICAgICk7IH1cblxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gb2xkKSB7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKHRoaXMuZG9tLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVBdHRyaWJ1dGUodGhpcy5kb20sIHRoaXMuYXR0cik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhY2hlIHRoZSByZWYgYm91bmQgdG8gdGhpcyBkb20gbm9kZVxuICAgICAgLy8gdG8gcmV1c2UgaXQgaW4gZnV0dXJlIChzZWUgYWxzbyAjMjMyOSlcbiAgICAgIGlmICghdGhpcy5kb20uX19yZWYpIHsgdGhpcy5kb20uX19yZWYgPSB0YWdPckRvbTsgfVxuICAgIH0sXG4gICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHZhciB0YWdPckRvbSA9IHRoaXMudGFnIHx8IHRoaXMuZG9tO1xuICAgICAgdmFyIGN1c3RvbVBhcmVudCA9IHRoaXMucGFyZW50ICYmIGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudCh0aGlzLnBhcmVudCk7XG4gICAgICBpZiAoIWlzQmxhbmsodGhpcy52YWx1ZSkgJiYgY3VzdG9tUGFyZW50KVxuICAgICAgICB7IGFycmF5aXNoUmVtb3ZlKGN1c3RvbVBhcmVudC5yZWZzLCB0aGlzLnZhbHVlLCB0YWdPckRvbSk7IH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHJlZiBkaXJlY3RpdmVcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGRvbSBub2RlIGhhdmluZyB0aGUgcmVmIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0gICB7IFRhZyB9IGNvbnRleHQgLSB0YWcgaW5zdGFuY2Ugd2hlcmUgdGhlIERPTSBub2RlIGlzIGxvY2F0ZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBhdHRyTmFtZSAtIGVpdGhlciAncmVmJyBvciAnZGF0YS1yZWYnXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0clZhbHVlIC0gdmFsdWUgb2YgdGhlIHJlZiBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMgeyBSZWZFeHByIH0gYSBuZXcgUmVmRXhwciBvYmplY3RcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZkRpcmVjdGl2ZShkb20sIHRhZywgYXR0ck5hbWUsIGF0dHJWYWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGUoUmVmRXhwcikuaW5pdChkb20sIHRhZywgYXR0ck5hbWUsIGF0dHJWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSB1bm1vdW50IG1ldGhvZCBvbiBhbGwgdGhlIGV4cHJlc3Npb25zXG4gICAqIEBwYXJhbSAgIHsgQXJyYXkgfSBleHByZXNzaW9ucyAtIERPTSBleHByZXNzaW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gdW5tb3VudEFsbChleHByZXNzaW9ucykge1xuICAgIGVhY2goZXhwcmVzc2lvbnMsIGZ1bmN0aW9uIChleHByKSB7XG4gICAgICBpZiAoZXhwci51bm1vdW50KSB7IGV4cHIudW5tb3VudCh0cnVlKTsgfVxuICAgICAgZWxzZSBpZiAoZXhwci50YWdOYW1lKSB7IGV4cHIudGFnLnVubW91bnQodHJ1ZSk7IH1cbiAgICAgIGVsc2UgaWYgKGV4cHIudW5tb3VudCkgeyBleHByLnVubW91bnQoKTsgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIElmRXhwciA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbSwgdGFnLCBleHByKSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpO1xuICAgICAgZXh0ZW5kKHRoaXMsIHsgdGFnOiB0YWcsIGV4cHI6IGV4cHIsIHN0dWI6IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCksIHByaXN0aW5lOiBkb20gfSk7XG4gICAgICB2YXIgcCA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgcC5pbnNlcnRCZWZvcmUodGhpcy5zdHViLCBkb20pO1xuICAgICAgcC5yZW1vdmVDaGlsZChkb20pO1xuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdG1wbCh0aGlzLmV4cHIsIHRoaXMudGFnKTtcblxuICAgICAgaWYgKHRoaXMudmFsdWUgJiYgIXRoaXMuY3VycmVudCkgeyAvLyBpbnNlcnRcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wcmlzdGluZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuc3R1Yi5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmN1cnJlbnQsIHRoaXMuc3R1Yik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBwYXJzZUV4cHJlc3Npb25zLmFwcGx5KHRoaXMudGFnLCBbdGhpcy5jdXJyZW50LCB0cnVlXSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnZhbHVlICYmIHRoaXMuY3VycmVudCkgeyAvLyByZW1vdmVcbiAgICAgICAgdW5tb3VudEFsbCh0aGlzLmV4cHJlc3Npb25zKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5fdGFnKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50Ll90YWcudW5tb3VudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7IHVwZGF0ZS5jYWxsKHRoaXMudGFnLCB0aGlzLmV4cHJlc3Npb25zKTsgfVxuICAgIH0sXG4gICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRBbGwodGhpcy5leHByZXNzaW9ucyB8fCBbXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpZiBkaXJlY3RpdmVcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGlmIHJvb3QgZG9tIG5vZGVcbiAgICogQHBhcmFtICAgeyBUYWcgfSBjb250ZXh0IC0gdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBET00gbm9kZSBpcyBsb2NhdGVkXG4gICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0ciAtIGlmIGV4cHJlc3Npb25cbiAgICogQHJldHVybnMgeyBJRkV4cHIgfSBhIG5ldyBJZkV4cHIgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJZkRpcmVjdGl2ZShkb20sIHRhZywgYXR0cikge1xuICAgIHJldHVybiBjcmVhdGUoSWZFeHByKS5pbml0KGRvbSwgdGFnLCBhdHRyKVxuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhlIHRhZyBET00gdG8gZGV0ZWN0IHRoZSBleHByZXNzaW9ucyB0byBldmFsdWF0ZVxuICAgKiBAdGhpcyBUYWdcbiAgICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSByb290IHRhZyB3aGVyZSB3ZSB3aWxsIHN0YXJ0IGRpZ2dpbmcgdGhlIGV4cHJlc3Npb25zXG4gICAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IG11c3RJbmNsdWRlUm9vdCAtIGZsYWcgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHJvb3QgbXVzdCBiZSBwYXJzZWQgYXMgd2VsbFxuICAgKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSBleHByZXNzaW9ucyBmb3VuZFxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9ucyhyb290LCBtdXN0SW5jbHVkZVJvb3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuXG4gICAgd2Fsa05vZGVzKHJvb3QsIGZ1bmN0aW9uIChkb20pIHtcbiAgICAgIHZhciB0eXBlID0gZG9tLm5vZGVUeXBlO1xuICAgICAgdmFyIGF0dHI7XG4gICAgICB2YXIgdGFnSW1wbDtcblxuICAgICAgaWYgKCFtdXN0SW5jbHVkZVJvb3QgJiYgZG9tID09PSByb290KSB7IHJldHVybiB9XG5cbiAgICAgIC8vIHRleHQgbm9kZVxuICAgICAgaWYgKHR5cGUgPT09IDMgJiYgZG9tLnBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ1NUWUxFJyAmJiB0bXBsLmhhc0V4cHIoZG9tLm5vZGVWYWx1ZSkpXG4gICAgICAgIHsgZXhwcmVzc2lvbnMucHVzaCh7ZG9tOiBkb20sIGV4cHI6IGRvbS5ub2RlVmFsdWV9KTsgfVxuXG4gICAgICBpZiAodHlwZSAhPT0gMSkgeyByZXR1cm4gfVxuXG4gICAgICB2YXIgaXNWaXJ0dWFsID0gZG9tLnRhZ05hbWUgPT09ICdWSVJUVUFMJztcblxuICAgICAgLy8gbG9vcC4gZWFjaCBkb2VzIGl0J3Mgb3duIHRoaW5nIChmb3Igbm93KVxuICAgICAgaWYgKGF0dHIgPSBnZXRBdHRyaWJ1dGUoZG9tLCBMT09QX0RJUkVDVElWRSkpIHtcbiAgICAgICAgaWYoaXNWaXJ0dWFsKSB7IHNldEF0dHJpYnV0ZShkb20sICdsb29wVmlydHVhbCcsIHRydWUpOyB9IC8vIGlnbm9yZSBoZXJlLCBoYW5kbGVkIGluIF9lYWNoXG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goX2VhY2goZG9tLCB0aGlzJDEsIGF0dHIpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIC8vIGlmLWF0dHJzIGJlY29tZSB0aGUgbmV3IHBhcmVudC4gQW55IGZvbGxvd2luZyBleHByZXNzaW9ucyAoZWl0aGVyIG9uIHRoZSBjdXJyZW50XG4gICAgICAvLyBlbGVtZW50LCBvciBiZWxvdyBpdCkgYmVjb21lIGNoaWxkcmVuIG9mIHRoaXMgZXhwcmVzc2lvbi5cbiAgICAgIGlmIChhdHRyID0gZ2V0QXR0cmlidXRlKGRvbSwgQ09ORElUSU9OQUxfRElSRUNUSVZFKSkge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKGNyZWF0ZUlmRGlyZWN0aXZlKGRvbSwgdGhpcyQxLCBhdHRyKSk7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0ciA9IGdldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSkpIHtcbiAgICAgICAgaWYgKHRtcGwuaGFzRXhwcihhdHRyKSkge1xuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goe1xuICAgICAgICAgICAgaXNSdGFnOiB0cnVlLFxuICAgICAgICAgICAgZXhwcjogYXR0cixcbiAgICAgICAgICAgIGRvbTogZG9tLFxuICAgICAgICAgICAgYXR0cnM6IFtdLnNsaWNlLmNhbGwoZG9tLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgdGFnLCBzdG9wIHRyYXZlcnNpbmcgaGVyZS5cbiAgICAgIC8vIHdlIGlnbm9yZSB0aGUgcm9vdCwgc2luY2UgcGFyc2VFeHByZXNzaW9ucyBpcyBjYWxsZWQgd2hpbGUgd2UncmUgbW91bnRpbmcgdGhhdCByb290XG4gICAgICB0YWdJbXBsID0gZ2V0KGRvbSk7XG5cbiAgICAgIGlmKGlzVmlydHVhbCkge1xuICAgICAgICBpZihnZXRBdHRyaWJ1dGUoZG9tLCAndmlydHVhbGl6ZWQnKSkge2RvbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRvbSk7IH0gLy8gdGFnIGNyZWF0ZWQsIHJlbW92ZSBmcm9tIGRvbVxuICAgICAgICBpZighdGFnSW1wbCAmJiAhZ2V0QXR0cmlidXRlKGRvbSwgJ3ZpcnR1YWxpemVkJykgJiYgIWdldEF0dHJpYnV0ZShkb20sICdsb29wVmlydHVhbCcpKSAgLy8gb2sgdG8gY3JlYXRlIHZpcnR1YWwgdGFnXG4gICAgICAgICAgeyB0YWdJbXBsID0geyB0bXBsOiBkb20ub3V0ZXJIVE1MIH07IH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRhZ0ltcGwgJiYgKGRvbSAhPT0gcm9vdCB8fCBtdXN0SW5jbHVkZVJvb3QpKSB7XG4gICAgICAgIHZhciBoYXNJc0RpcmVjdGl2ZSA9IGdldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSk7XG4gICAgICAgIGlmKGlzVmlydHVhbCAmJiAhaGFzSXNEaXJlY3RpdmUpIHsgLy8gaGFuZGxlZCBpbiB1cGRhdGVcbiAgICAgICAgICAvLyBjYW4gbm90IHJlbW92ZSBhdHRyaWJ1dGUgbGlrZSBkaXJlY3RpdmVzXG4gICAgICAgICAgLy8gc28gZmxhZyBmb3IgcmVtb3ZhbCBhZnRlciBjcmVhdGlvbiB0byBwcmV2ZW50IG1heGltdW0gc3RhY2sgZXJyb3JcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoZG9tLCAndmlydHVhbGl6ZWQnLCB0cnVlKTtcbiAgICAgICAgICB2YXIgdGFnID0gY3JlYXRlVGFnKFxuICAgICAgICAgICAge3RtcGw6IGRvbS5vdXRlckhUTUx9LFxuICAgICAgICAgICAge3Jvb3Q6IGRvbSwgcGFyZW50OiB0aGlzJDF9LFxuICAgICAgICAgICAgZG9tLmlubmVySFRNTFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRhZyk7IC8vIG5vIHJldHVybiwgYW5vbnltb3VzIHRhZywga2VlcCBwYXJzaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhhc0lzRGlyZWN0aXZlICYmIGlzVmlydHVhbClcbiAgICAgICAgICAgIHsgd2FybigoXCJWaXJ0dWFsIHRhZ3Mgc2hvdWxkbid0IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgXFxcIlwiICsgSVNfRElSRUNUSVZFICsgXCJcXFwiIGF0dHJpYnV0ZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI1MTFcIikpOyB9XG5cbiAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgICAgICAgaW5pdENoaWxkKFxuICAgICAgICAgICAgICB0YWdJbXBsLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9vdDogZG9tLFxuICAgICAgICAgICAgICAgIHBhcmVudDogdGhpcyQxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRvbS5pbm5lckhUTUwsXG4gICAgICAgICAgICAgIHRoaXMkMVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYXR0cmlidXRlIGV4cHJlc3Npb25zXG4gICAgICBwYXJzZUF0dHJpYnV0ZXMuYXBwbHkodGhpcyQxLCBbZG9tLCBkb20uYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHIsIGV4cHIpIHtcbiAgICAgICAgaWYgKCFleHByKSB7IHJldHVybiB9XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XG4gICAgICB9XSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBgZm5gIGZvciBldmVyeSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC4gSWYgdGhhdCBhdHRyIGhhcyBhbiBleHByZXNzaW9uLFxuICAgKiBpdCBpcyBhbHNvIHBhc3NlZCB0byBmbi5cbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSBkb20gLSBkb20gbm9kZSB0byBwYXJzZVxuICAgKiBAcGFyYW0gICB7IEFycmF5IH0gYXR0cnMgLSBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIHRvIGV4ZWMgb24gYW55IGl0ZXJhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVzKGRvbSwgYXR0cnMsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBlYWNoKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgaWYgKCFhdHRyKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAgIHZhciBuYW1lID0gYXR0ci5uYW1lO1xuICAgICAgdmFyIGJvb2wgPSBpc0Jvb2xBdHRyKG5hbWUpO1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGlmIChjb250YWlucyhSRUZfRElSRUNUSVZFUywgbmFtZSkgJiYgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gWUlFTERfVEFHKSB7XG4gICAgICAgIGV4cHIgPSAgY3JlYXRlUmVmRGlyZWN0aXZlKGRvbSwgdGhpcyQxLCBuYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodG1wbC5oYXNFeHByKGF0dHIudmFsdWUpKSB7XG4gICAgICAgIGV4cHIgPSB7ZG9tOiBkb20sIGV4cHI6IGF0dHIudmFsdWUsIGF0dHI6IG5hbWUsIGJvb2w6IGJvb2x9O1xuICAgICAgfVxuXG4gICAgICBmbihhdHRyLCBleHByKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGhlIG1vdW50IHN0YXRlIG9mIGEgdGFnIHRyaWdnZXJpbmcgYWxzbyB0aGUgb2JzZXJ2YWJsZSBldmVudHNcbiAgICogQHRoaXMgVGFnXG4gICAqIEBwYXJhbSB7IEJvb2xlYW4gfSB2YWx1ZSAtIC4ub2YgdGhlIGlzTW91bnRlZCBmbGFnXG4gICAqL1xuICBmdW5jdGlvbiBzZXRNb3VudFN0YXRlKHZhbHVlKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuX187XG4gICAgdmFyIGlzQW5vbnltb3VzID0gcmVmLmlzQW5vbnltb3VzO1xuXG4gICAgZGVmaW5lKHRoaXMsICdpc01vdW50ZWQnLCB2YWx1ZSk7XG5cbiAgICBpZiAoIWlzQW5vbnltb3VzKSB7XG4gICAgICBpZiAodmFsdWUpIHsgdGhpcy50cmlnZ2VyKCdtb3VudCcpOyB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd1bm1vdW50Jyk7XG4gICAgICAgIHRoaXMub2ZmKCcqJyk7XG4gICAgICAgIHRoaXMuX18ud2FzQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VudCB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAgICogQHJldHVybnMgeyBUYWcgfSB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBvbmVudE1vdW50KHRhZyQkMSwgZG9tLCBleHByZXNzaW9ucywgb3B0cykge1xuICAgIHZhciBfXyA9IHRhZyQkMS5fXztcbiAgICB2YXIgcm9vdCA9IF9fLnJvb3Q7XG4gICAgcm9vdC5fdGFnID0gdGFnJCQxOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWcganVzdCBjcmVhdGVkXG5cbiAgICAvLyBSZWFkIGFsbCB0aGUgYXR0cnMgb24gdGhpcyBpbnN0YW5jZS4gVGhpcyBnaXZlIHVzIHRoZSBpbmZvIHdlIG5lZWQgZm9yIHVwZGF0ZU9wdHNcbiAgICBwYXJzZUF0dHJpYnV0ZXMuYXBwbHkoX18ucGFyZW50LCBbcm9vdCwgcm9vdC5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0ciwgZXhwcikge1xuICAgICAgaWYgKCFfXy5pc0Fub255bW91cyAmJiBSZWZFeHByLmlzUHJvdG90eXBlT2YoZXhwcikpIHsgZXhwci50YWcgPSB0YWckJDE7IH1cbiAgICAgIGF0dHIuZXhwciA9IGV4cHI7XG4gICAgICBfXy5pbnN0QXR0cnMucHVzaChhdHRyKTtcbiAgICB9XSk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHJvb3QgYWRkaW5nIGN1c3RvbSBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIHRoZSBjb21waWxlclxuICAgIHdhbGtBdHRyaWJ1dGVzKF9fLmltcGwuYXR0cnMsIGZ1bmN0aW9uIChrLCB2KSB7IF9fLmltcGxBdHRycy5wdXNoKHtuYW1lOiBrLCB2YWx1ZTogdn0pOyB9KTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMuYXBwbHkodGFnJCQxLCBbcm9vdCwgX18uaW1wbEF0dHJzLCBmdW5jdGlvbiAoYXR0ciwgZXhwcikge1xuICAgICAgaWYgKGV4cHIpIHsgZXhwcmVzc2lvbnMucHVzaChleHByKTsgfVxuICAgICAgZWxzZSB7IHNldEF0dHJpYnV0ZShyb290LCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpOyB9XG4gICAgfV0pO1xuXG4gICAgLy8gaW5pdGlhbGlhdGlvblxuICAgIHVwZGF0ZU9wdHMuYXBwbHkodGFnJCQxLCBbX18uaXNMb29wLCBfXy5wYXJlbnQsIF9fLmlzQW5vbnltb3VzLCBvcHRzLCBfXy5pbnN0QXR0cnNdKTtcblxuICAgIC8vIGFkZCBnbG9iYWwgbWl4aW5zXG4gICAgdmFyIGdsb2JhbE1peGluID0gbWl4aW4oR0xPQkFMX01JWElOKTtcblxuICAgIGlmIChnbG9iYWxNaXhpbiAmJiAhX18uc2tpcEFub255bW91cykge1xuICAgICAgZm9yICh2YXIgaSBpbiBnbG9iYWxNaXhpbikge1xuICAgICAgICBpZiAoZ2xvYmFsTWl4aW4uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB0YWckJDEubWl4aW4oZ2xvYmFsTWl4aW5baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9fLmltcGwuZm4pIHsgX18uaW1wbC5mbi5jYWxsKHRhZyQkMSwgb3B0cyk7IH1cblxuICAgIGlmICghX18uc2tpcEFub255bW91cykgeyB0YWckJDEudHJpZ2dlcignYmVmb3JlLW1vdW50Jyk7IH1cblxuICAgIC8vIHBhcnNlIGxheW91dCBhZnRlciBpbml0LiBmbiBtYXkgY2FsY3VsYXRlIGFyZ3MgZm9yIG5lc3RlZCBjdXN0b20gdGFnc1xuICAgIGVhY2gocGFyc2VFeHByZXNzaW9ucy5hcHBseSh0YWckJDEsIFtkb20sIF9fLmlzQW5vbnltb3VzXSksIGZ1bmN0aW9uIChlKSB7IHJldHVybiBleHByZXNzaW9ucy5wdXNoKGUpOyB9KTtcblxuICAgIHRhZyQkMS51cGRhdGUoX18uaXRlbSk7XG5cbiAgICBpZiAoIV9fLmlzQW5vbnltb3VzICYmICFfXy5pc0lubGluZSkge1xuICAgICAgd2hpbGUgKGRvbS5maXJzdENoaWxkKSB7IHJvb3QuYXBwZW5kQ2hpbGQoZG9tLmZpcnN0Q2hpbGQpOyB9XG4gICAgfVxuXG4gICAgZGVmaW5lKHRhZyQkMSwgJ3Jvb3QnLCByb290KTtcblxuICAgIC8vIGlmIHdlIG5lZWQgdG8gd2FpdCB0aGF0IHRoZSBwYXJlbnQgXCJtb3VudFwiIG9yIFwidXBkYXRlZFwiIGV2ZW50IGdldHMgdHJpZ2dlcmVkXG4gICAgaWYgKCFfXy5za2lwQW5vbnltb3VzICYmIHRhZyQkMS5wYXJlbnQpIHtcbiAgICAgIHZhciBwID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRhZyQkMS5wYXJlbnQpO1xuICAgICAgcC5vbmUoIXAuaXNNb3VudGVkID8gJ21vdW50JyA6ICd1cGRhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRNb3VudFN0YXRlLmNhbGwodGFnJCQxLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UgaXQncyBub3QgYSBjaGlsZCB0YWcgd2UgY2FuIHRyaWdnZXIgaXRzIG1vdW50IGV2ZW50XG4gICAgICBzZXRNb3VudFN0YXRlLmNhbGwodGFnJCQxLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0YWckJDEuX18ud2FzQ3JlYXRlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGFnJCQxXG4gIH1cblxuICAvKipcbiAgICogVW5tb3VudCB0aGUgdGFnIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7IEJvb2xlYW4gfSBtdXN0S2VlcFJvb3QgLSBpZiBpdCdzIHRydWUgdGhlIHJvb3Qgbm9kZSB3aWxsIG5vdCBiZSByZW1vdmVkXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiB0YWdVbm1vdW50KHRhZywgbXVzdEtlZXBSb290LCBleHByZXNzaW9ucykge1xuICAgIHZhciBfXyA9IHRhZy5fXztcbiAgICB2YXIgcm9vdCA9IF9fLnJvb3Q7XG4gICAgdmFyIHRhZ0luZGV4ID0gX19UQUdTX0NBQ0hFLmluZGV4T2YodGFnKTtcbiAgICB2YXIgcCA9IHJvb3QucGFyZW50Tm9kZTtcblxuICAgIGlmICghX18uc2tpcEFub255bW91cykgeyB0YWcudHJpZ2dlcignYmVmb3JlLXVubW91bnQnKTsgfVxuXG4gICAgLy8gY2xlYXIgYWxsIGF0dHJpYnV0ZXMgY29taW5nIGZyb20gdGhlIG1vdW50ZWQgdGFnXG4gICAgd2Fsa0F0dHJpYnV0ZXMoX18uaW1wbC5hdHRycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoKG5hbWUsIEFUVFJTX1BSRUZJWCkpXG4gICAgICAgIHsgbmFtZSA9IG5hbWUuc2xpY2UoQVRUUlNfUFJFRklYLmxlbmd0aCk7IH1cblxuICAgICAgcmVtb3ZlQXR0cmlidXRlKHJvb3QsIG5hbWUpO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGFnLl9fLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChkb20pIHtcbiAgICAgIE9iamVjdC5rZXlzKGRvbVtSSU9UX0VWRU5UU19LRVldKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBkb21bUklPVF9FVkVOVFNfS0VZXVtldmVudE5hbWVdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIHRhZyBpbnN0YW5jZSBmcm9tIHRoZSBnbG9iYWwgdGFncyBjYWNoZSBjb2xsZWN0aW9uXG4gICAgaWYgKHRhZ0luZGV4ICE9PSAtMSkgeyBfX1RBR1NfQ0FDSEUuc3BsaWNlKHRhZ0luZGV4LCAxKTsgfVxuXG4gICAgLy8gY2xlYW4gdXAgdGhlIHBhcmVudCB0YWdzIG9iamVjdFxuICAgIGlmIChfXy5wYXJlbnQgJiYgIV9fLmlzQW5vbnltb3VzKSB7XG4gICAgICB2YXIgcHRhZyA9IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudChfXy5wYXJlbnQpO1xuXG4gICAgICBpZiAoX18uaXNWaXJ0dWFsKSB7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgIC5rZXlzKHRhZy50YWdzKVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBhcnJheWlzaFJlbW92ZShwdGFnLnRhZ3MsIHRhZ05hbWUsIHRhZy50YWdzW3RhZ05hbWVdKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheWlzaFJlbW92ZShwdGFnLnRhZ3MsIF9fLnRhZ05hbWUsIHRhZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdW5tb3VudCBhbGwgdGhlIHZpcnR1YWwgZGlyZWN0aXZlc1xuICAgIGlmICh0YWcuX18udmlydHMpIHtcbiAgICAgIGVhY2godGFnLl9fLnZpcnRzLCBmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAodi5wYXJlbnROb2RlKSB7IHYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2KTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZXhwcmVzc2lvbnMgdG8gdW5tb3VudCB0aGVtc2VsdmVzXG4gICAgdW5tb3VudEFsbChleHByZXNzaW9ucyk7XG4gICAgZWFjaChfXy5pbnN0QXR0cnMsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLmV4cHIgJiYgYS5leHByLnVubW91bnQgJiYgYS5leHByLnVubW91bnQoKTsgfSk7XG5cbiAgICAvLyBjbGVhciB0aGUgdGFnIGh0bWwgaWYgaXQncyBuZWNlc3NhcnlcbiAgICBpZiAobXVzdEtlZXBSb290KSB7IHNldElubmVySFRNTChyb290LCAnJyk7IH1cbiAgICAvLyBvdGhlcndpc2UgZGV0YWNoIHRoZSByb290IHRhZyBmcm9tIHRoZSBET01cbiAgICBlbHNlIGlmIChwKSB7IHAucmVtb3ZlQ2hpbGQocm9vdCk7IH1cblxuICAgIC8vIGN1c3RvbSBpbnRlcm5hbCB1bm1vdW50IGZ1bmN0aW9uIHRvIGF2b2lkIHJlbHlpbmcgb24gdGhlIG9ic2VydmFibGVcbiAgICBpZiAoX18ub25Vbm1vdW50KSB7IF9fLm9uVW5tb3VudCgpOyB9XG5cbiAgICAvLyB3ZWlyZCBmaXggZm9yIGEgd2VpcmQgZWRnZSBjYXNlICMyNDA5IGFuZCAjMjQzNlxuICAgIC8vIHNvbWUgdXNlcnMgbWlnaHQgdXNlIHlvdXIgc29mdHdhcmUgbm90IGFzIHlvdSd2ZSBleHBlY3RlZFxuICAgIC8vIHNvIEkgbmVlZCB0byBhZGQgdGhlc2UgZGlydHkgaGFja3MgdG8gbWl0aWdhdGUgdW5leHBlY3RlZCBpc3N1ZXNcbiAgICBpZiAoIXRhZy5pc01vdW50ZWQpIHsgc2V0TW91bnRTdGF0ZS5jYWxsKHRhZywgdHJ1ZSk7IH1cblxuICAgIHNldE1vdW50U3RhdGUuY2FsbCh0YWcsIGZhbHNlKTtcblxuICAgIGRlbGV0ZSByb290Ll90YWc7XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuICAvKipcbiAgICogVGFnIGNyZWF0aW9uIGZhY3RvcnkgZnVuY3Rpb25cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IGltcGwgLSBpdCBjb250YWlucyB0aGUgdGFnIHRlbXBsYXRlLCBhbmQgbG9naWNcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gY29uZiAtIHRhZyBvcHRpb25zXG4gICAqIEBwYXJhbSB7IFN0cmluZyB9IGlubmVySFRNTCAtIGh0bWwgdGhhdCBldmVudHVhbGx5IHdlIG5lZWQgdG8gaW5qZWN0IGluIHRoZSB0YWdcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhZyhpbXBsLCBjb25mLCBpbm5lckhUTUwpIHtcbiAgICBpZiAoIGltcGwgPT09IHZvaWQgMCApIGltcGwgPSB7fTtcbiAgICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICAgIHZhciB0YWcgPSBjb25mLmNvbnRleHQgfHwge307XG4gICAgdmFyIG9wdHMgPSBleHRlbmQoe30sIGNvbmYub3B0cyk7XG4gICAgdmFyIHBhcmVudCA9IGNvbmYucGFyZW50O1xuICAgIHZhciBpc0xvb3AgPSBjb25mLmlzTG9vcDtcbiAgICB2YXIgaXNBbm9ueW1vdXMgPSAhIWNvbmYuaXNBbm9ueW1vdXM7XG4gICAgdmFyIHNraXBBbm9ueW1vdXMgPSBzZXR0aW5ncy5za2lwQW5vbnltb3VzVGFncyAmJiBpc0Fub255bW91cztcbiAgICB2YXIgaXRlbSA9IGNvbmYuaXRlbTtcbiAgICAvLyBhdmFpbGFibGUgb25seSBmb3IgdGhlIGxvb3BlZCBub2Rlc1xuICAgIHZhciBpbmRleCA9IGNvbmYuaW5kZXg7XG4gICAgLy8gQWxsIGF0dHJpYnV0ZXMgb24gdGhlIFRhZyB3aGVuIGl0J3MgZmlyc3QgcGFyc2VkXG4gICAgdmFyIGluc3RBdHRycyA9IFtdO1xuICAgIC8vIGV4cHJlc3Npb25zIG9uIHRoaXMgdHlwZSBvZiBUYWdcbiAgICB2YXIgaW1wbEF0dHJzID0gW107XG4gICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgdmFyIHJvb3QgPSBjb25mLnJvb3Q7XG4gICAgdmFyIHRhZ05hbWUgPSBjb25mLnRhZ05hbWUgfHwgZ2V0TmFtZShyb290KTtcbiAgICB2YXIgaXNWaXJ0dWFsID0gdGFnTmFtZSA9PT0gJ3ZpcnR1YWwnO1xuICAgIHZhciBpc0lubGluZSA9ICFpc1ZpcnR1YWwgJiYgIWltcGwudG1wbDtcbiAgICB2YXIgZG9tO1xuXG4gICAgLy8gbWFrZSB0aGlzIHRhZyBvYnNlcnZhYmxlXG4gICAgaWYgKCFza2lwQW5vbnltb3VzKSB7IG9ic2VydmFibGUodGFnKTsgfVxuICAgIC8vIG9ubHkgY2FsbCB1bm1vdW50IGlmIHdlIGhhdmUgYSB2YWxpZCBfX1RBR19JTVBMIChoYXMgbmFtZSBwcm9wZXJ0eSlcbiAgICBpZiAoaW1wbC5uYW1lICYmIHJvb3QuX3RhZykgeyByb290Ll90YWcudW5tb3VudCh0cnVlKTsgfVxuXG4gICAgLy8gbm90IHlldCBtb3VudGVkXG4gICAgZGVmaW5lKHRhZywgJ2lzTW91bnRlZCcsIGZhbHNlKTtcblxuICAgIGRlZmluZSh0YWcsICdfXycsIHtcbiAgICAgIGltcGw6IGltcGwsXG4gICAgICByb290OiByb290LFxuICAgICAgc2tpcEFub255bW91czogc2tpcEFub255bW91cyxcbiAgICAgIGltcGxBdHRyczogaW1wbEF0dHJzLFxuICAgICAgaXNBbm9ueW1vdXM6IGlzQW5vbnltb3VzLFxuICAgICAgaW5zdEF0dHJzOiBpbnN0QXR0cnMsXG4gICAgICBpbm5lckhUTUw6IGlubmVySFRNTCxcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBpc0xvb3A6IGlzTG9vcCxcbiAgICAgIGlzSW5saW5lOiBpc0lubGluZSxcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIC8vIHRhZ3MgaGF2aW5nIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgLy8gaXQgd291bGQgYmUgYmV0dGVyIHRvIHVzZSB3ZWFrIG1hcHMgaGVyZSBidXQgd2UgY2FuIG5vdCBpbnRyb2R1Y2UgYnJlYWtpbmcgY2hhbmdlcyBub3dcbiAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAvLyB0aGVzZSB2YXJzIHdpbGwgYmUgbmVlZGVkIG9ubHkgZm9yIHRoZSB2aXJ0dWFsIHRhZ3NcbiAgICAgIHZpcnRzOiBbXSxcbiAgICAgIHdhc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgdGFpbDogbnVsbCxcbiAgICAgIGhlYWQ6IG51bGxcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBhIHVuaXF1ZSBpZCB0byB0aGlzIHRhZ1xuICAgIC8vIGl0IGNvdWxkIGJlIGhhbmR5IHRvIHVzZSBpdCBhbHNvIHRvIGltcHJvdmUgdGhlIHZpcnR1YWwgZG9tIHJlbmRlcmluZyBzcGVlZFxuICAgIGRlZmluZSh0YWcsICdfcmlvdF9pZCcsIHVpZCgpKTsgLy8gYmFzZSAxIGFsbG93cyB0ZXN0ICF0Ll9yaW90X2lkXG4gICAgZGVmaW5lKHRhZywgJ3Jvb3QnLCByb290KTtcbiAgICBleHRlbmQodGFnLCB7IG9wdHM6IG9wdHMgfSwgaXRlbSk7XG4gICAgLy8gcHJvdGVjdCB0aGUgXCJ0YWdzXCIgYW5kIFwicmVmc1wiIHByb3BlcnR5IGZyb20gYmVpbmcgb3ZlcnJpZGRlblxuICAgIGRlZmluZSh0YWcsICdwYXJlbnQnLCBwYXJlbnQgfHwgbnVsbCk7XG4gICAgZGVmaW5lKHRhZywgJ3RhZ3MnLCB7fSk7XG4gICAgZGVmaW5lKHRhZywgJ3JlZnMnLCB7fSk7XG5cbiAgICBpZiAoaXNJbmxpbmUgfHwgaXNMb29wICYmIGlzQW5vbnltb3VzKSB7XG4gICAgICBkb20gPSByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzVmlydHVhbCkgeyByb290LmlubmVySFRNTCA9ICcnOyB9XG4gICAgICBkb20gPSBta2RvbShpbXBsLnRtcGwsIGlubmVySFRNTCwgaXNTdmcocm9vdCkpO1xuICAgIH1cblxuICAgIGRlZmluZSh0YWcsICd1cGRhdGUnLCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gY29tcG9uZW50VXBkYXRlKHRhZywgZGF0YSwgZXhwcmVzc2lvbnMpOyB9KTtcbiAgICBkZWZpbmUodGFnLCAnbWl4aW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWl4aW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgbWl4aW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHJldHVybiBjb21wb25lbnRNaXhpbi5hcHBseSh2b2lkIDAsIFsgdGFnIF0uY29uY2F0KCBtaXhpbnMgKSk7XG4gICAgfSk7XG4gICAgZGVmaW5lKHRhZywgJ21vdW50JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50TW91bnQodGFnLCBkb20sIGV4cHJlc3Npb25zLCBvcHRzKTsgfSk7XG4gICAgZGVmaW5lKHRhZywgJ3VubW91bnQnLCBmdW5jdGlvbiAobXVzdEtlZXBSb290KSB7IHJldHVybiB0YWdVbm1vdW50KHRhZywgbXVzdEtlZXBSb290LCBleHByZXNzaW9ucyk7IH0pO1xuXG4gICAgcmV0dXJuIHRhZ1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdW50IGEgdGFnIGNyZWF0aW5nIG5ldyBUYWcgaW5zdGFuY2VcbiAgICogQHBhcmFtICAgeyBPYmplY3QgfSByb290IC0gZG9tIG5vZGUgd2hlcmUgdGhlIHRhZyB3aWxsIGJlIG1vdW50ZWRcbiAgICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gbmFtZSBvZiB0aGUgcmlvdCB0YWcgd2Ugd2FudCB0byBtb3VudFxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdHMgLSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFRhZyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIG9wdGlvbmFsIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGNsYXNzICggdXNlZCBpbiByaW90LlRhZyApXG4gICAqIEByZXR1cm5zIHsgVGFnIH0gYSBuZXcgVGFnIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBtb3VudCQxKHJvb3QsIHRhZ05hbWUsIG9wdHMsIGN0eCkge1xuICAgIHZhciBpbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgICB2YXIgaW1wbENsYXNzID0gX19UQUdfSU1QTFt0YWdOYW1lXS5jbGFzcztcbiAgICB2YXIgY29udGV4dCA9IGN0eCB8fCAoaW1wbENsYXNzID8gY3JlYXRlKGltcGxDbGFzcy5wcm90b3R5cGUpIDoge30pO1xuICAgIC8vIGNhY2hlIHRoZSBpbm5lciBIVE1MIHRvIGZpeCAjODU1XG4gICAgdmFyIGlubmVySFRNTCA9IHJvb3QuX2lubmVySFRNTCA9IHJvb3QuX2lubmVySFRNTCB8fCByb290LmlubmVySFRNTDtcbiAgICB2YXIgY29uZiA9IGV4dGVuZCh7IHJvb3Q6IHJvb3QsIG9wdHM6IG9wdHMsIGNvbnRleHQ6IGNvbnRleHQgfSwgeyBwYXJlbnQ6IG9wdHMgPyBvcHRzLnBhcmVudCA6IG51bGwgfSk7XG4gICAgdmFyIHRhZztcblxuICAgIGlmIChpbXBsICYmIHJvb3QpIHsgdGFnID0gY3JlYXRlVGFnKGltcGwsIGNvbmYsIGlubmVySFRNTCk7IH1cblxuICAgIGlmICh0YWcgJiYgdGFnLm1vdW50KSB7XG4gICAgICB0YWcubW91bnQodHJ1ZSk7XG4gICAgICAvLyBhZGQgdGhpcyB0YWcgdG8gdGhlIHZpcnR1YWxEb20gdmFyaWFibGVcbiAgICAgIGlmICghY29udGFpbnMoX19UQUdTX0NBQ0hFLCB0YWcpKSB7IF9fVEFHU19DQUNIRS5wdXNoKHRhZyk7IH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFnXG4gIH1cblxuXG5cbiAgdmFyIHRhZ3MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgYXJyYXlpc2hBZGQ6IGFycmF5aXNoQWRkLFxuICAgIGdldFRhZ05hbWU6IGdldE5hbWUsXG4gICAgaW5oZXJpdFBhcmVudFByb3BzOiBpbmhlcml0UGFyZW50UHJvcHMsXG4gICAgbW91bnRUbzogbW91bnQkMSxcbiAgICBzZWxlY3RUYWdzOiBxdWVyeSxcbiAgICBhcnJheWlzaFJlbW92ZTogYXJyYXlpc2hSZW1vdmUsXG4gICAgZ2V0VGFnOiBnZXQsXG4gICAgaW5pdENoaWxkVGFnOiBpbml0Q2hpbGQsXG4gICAgbW92ZUNoaWxkVGFnOiBtb3ZlQ2hpbGQsXG4gICAgbWFrZVJlcGxhY2VWaXJ0dWFsOiBtYWtlUmVwbGFjZVZpcnR1YWwsXG4gICAgZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnOiBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQsXG4gICAgbWFrZVZpcnR1YWw6IG1ha2VWaXJ0dWFsLFxuICAgIG1vdmVWaXJ0dWFsOiBtb3ZlVmlydHVhbCxcbiAgICB1bm1vdW50QWxsOiB1bm1vdW50QWxsLFxuICAgIGNyZWF0ZUlmRGlyZWN0aXZlOiBjcmVhdGVJZkRpcmVjdGl2ZSxcbiAgICBjcmVhdGVSZWZEaXJlY3RpdmU6IGNyZWF0ZVJlZkRpcmVjdGl2ZVxuICB9KTtcblxuICAvKipcbiAgICogUmlvdCBwdWJsaWMgYXBpXG4gICAqL1xuICB2YXIgc2V0dGluZ3MkMSA9IHNldHRpbmdzO1xuICB2YXIgdXRpbCA9IHtcbiAgICB0bXBsOiB0bXBsLFxuICAgIGJyYWNrZXRzOiBicmFja2V0cyxcbiAgICBzdHlsZU1hbmFnZXI6IHN0eWxlTWFuYWdlcixcbiAgICB2ZG9tOiBfX1RBR1NfQ0FDSEUsXG4gICAgc3R5bGVOb2RlOiBzdHlsZU1hbmFnZXIuc3R5bGVOb2RlLFxuICAgIC8vIGV4cG9ydCB0aGUgcmlvdCBpbnRlcm5hbCB1dGlscyBhcyB3ZWxsXG4gICAgZG9tOiBkb20sXG4gICAgY2hlY2s6IGNoZWNrLFxuICAgIG1pc2M6IG1pc2MsXG4gICAgdGFnczogdGFnc1xuICB9O1xuXG4gIC8vIGV4cG9ydCB0aGUgY29yZSBwcm9wcy9tZXRob2RzXG4gIHZhciBUYWckMSA9IFRhZztcbiAgdmFyIHRhZyQxID0gdGFnO1xuICB2YXIgdGFnMiQxID0gdGFnMjtcbiAgdmFyIG1vdW50JDIgPSBtb3VudDtcbiAgdmFyIG1peGluJDEgPSBtaXhpbjtcbiAgdmFyIHVwZGF0ZSQyID0gdXBkYXRlJDE7XG4gIHZhciB1bnJlZ2lzdGVyJDEgPSB1bnJlZ2lzdGVyO1xuICB2YXIgdmVyc2lvbiQxID0gdmVyc2lvbjtcbiAgdmFyIG9ic2VydmFibGUkMSA9IG9ic2VydmFibGU7XG5cbiAgdmFyIHJpb3QkMSA9IGV4dGVuZCh7fSwgY29yZSwge1xuICAgIG9ic2VydmFibGU6IG9ic2VydmFibGUsXG4gICAgc2V0dGluZ3M6IHNldHRpbmdzJDEsXG4gICAgdXRpbDogdXRpbCxcbiAgfSlcblxuICBleHBvcnRzLnNldHRpbmdzID0gc2V0dGluZ3MkMTtcbiAgZXhwb3J0cy51dGlsID0gdXRpbDtcbiAgZXhwb3J0cy5UYWcgPSBUYWckMTtcbiAgZXhwb3J0cy50YWcgPSB0YWckMTtcbiAgZXhwb3J0cy50YWcyID0gdGFnMiQxO1xuICBleHBvcnRzLm1vdW50ID0gbW91bnQkMjtcbiAgZXhwb3J0cy5taXhpbiA9IG1peGluJDE7XG4gIGV4cG9ydHMudXBkYXRlID0gdXBkYXRlJDI7XG4gIGV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXIkMTtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbiQxO1xuICBleHBvcnRzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlJDE7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IHJpb3QkMTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},1:function(module,exports){eval('/* Umbrella JS 2.10.0 umbrellajs.com */\nfunction ajax(a,b,c,d){c=c||function(){},b=b||{},b.body=b.body||{},b.method=(b.method||"GET").toUpperCase(),b.headers=b.headers||{},b.headers["X-Requested-With"]=b.headers["X-Requested-With"]||"XMLHttpRequest","undefined"!=typeof window.FormData&&b.body instanceof window.FormData||(b.headers["Content-Type"]=b.headers["Content-Type"]||"application/x-www-form-urlencoded"),/json/.test(b.headers["Content-Type"])&&(b.body=JSON.stringify(b.body)),"object"!=typeof b.body||b.body instanceof window.FormData||(b.body=u().param(b.body));var e=new window.XMLHttpRequest;u(e).on("error timeout abort",function(){c(new Error,null,e)}).on("load",function(){var a=/^(4|5)/.test(e.status)?new Error(e.status):null,b=parseJson(e.response)||e.response;return c(a,b,e)}),e.open(b.method,a),e.withCredentials=!0;for(var f in b.headers)e.setRequestHeader(f,b.headers[f]);return d&&d(e),e.send(b.body),e}function parseJson(a){try{var b=JSON.parse(a);if(b&&"object"==typeof b)return b}catch(c){}return!1}var u=function(a,b){return this instanceof u?a instanceof u?a:("string"==typeof a&&(a=this.select(a,b)),a&&a.nodeName&&(a=[a]),void(this.nodes=this.slice(a))):new u(a,b)};u.prototype={get length(){return this.nodes.length}},u.prototype.nodes=[],u.prototype.addClass=function(){return this.eacharg(arguments,function(a,b){a.classList.add(b)})},u.prototype.adjacent=function(a,b,c){return"number"==typeof b&&(b=0===b?[]:new Array(b).join().split(",").map(Number.call,Number)),this.each(function(d,e){var f=document.createDocumentFragment();u(b||{}).map(function(b,c){var f="function"==typeof a?a.call(this,b,c,d,e):a;return"string"==typeof f?this.generate(f):u(f)}).each(function(a){this.isInPage(a)?f.appendChild(u(a).clone().first()):f.appendChild(a)}),c.call(this,d,f)})},u.prototype.after=function(a,b){return this.adjacent(a,b,function(a,b){a.parentNode.insertBefore(b,a.nextSibling)})},u.prototype.ajax=function(a,b){return this.handle("submit",function(c){ajax(u(this).attr("action"),{body:u(this).serialize(),method:u(this).attr("method")},a&&a.bind(this),b&&b.bind(this))})},u.prototype.append=function(a,b){return this.adjacent(a,b,function(a,b){a.appendChild(b)})},u.prototype.args=function(a,b,c){return"function"==typeof a&&(a=a(b,c)),"string"!=typeof a&&(a=this.slice(a).map(this.str(b,c))),a.toString().split(/[\\s,]+/).filter(function(a){return a.length})},u.prototype.array=function(a){a=a;var b=this;return this.nodes.reduce(function(c,d,e){var f;return a?(f=a.call(b,d,e),f||(f=!1),"string"==typeof f&&(f=u(f)),f instanceof u&&(f=f.nodes)):f=d.innerHTML,c.concat(f!==!1?f:[])},[])},u.prototype.attr=function(a,b,c){return c=c?"data-":"",this.pairs(a,b,function(a,b){return a.getAttribute(c+b)},function(a,b,d){a.setAttribute(c+b,d)})},u.prototype.before=function(a,b){return this.adjacent(a,b,function(a,b){a.parentNode.insertBefore(b,a)})},u.prototype.children=function(a){return this.map(function(a){return this.slice(a.children)}).filter(a)},u.prototype.clone=function(){return this.map(function(a,b){var c=a.cloneNode(!0),d=this.getAll(c);return this.getAll(a).each(function(a,b){for(var c in this.mirror)this.mirror[c](a,d.nodes[b])}),c})},u.prototype.getAll=function(a){return u([a].concat(u("*",a).nodes))},u.prototype.mirror={},u.prototype.mirror.events=function(a,b){if(a._e)for(var c in a._e)a._e[c].forEach(function(a){u(b).on(c,a)})},u.prototype.mirror.select=function(a,b){u(a).is("select")&&(b.value=a.value)},u.prototype.mirror.textarea=function(a,b){u(a).is("textarea")&&(b.value=a.value)},u.prototype.closest=function(a){return this.map(function(b){do if(u(b).is(a))return b;while((b=b.parentNode)&&b!==document)})},u.prototype.data=function(a,b){return this.attr(a,b,!0)},u.prototype.each=function(a){return this.nodes.forEach(a.bind(this)),this},u.prototype.eacharg=function(a,b){return this.each(function(c,d){this.args(a,c,d).forEach(function(a){b.call(this,c,a)},this)})},u.prototype.empty=function(){return this.each(function(a){for(;a.firstChild;)a.removeChild(a.firstChild)})},u.prototype.filter=function(a){var b=function(b){return b.matches=b.matches||b.msMatchesSelector||b.webkitMatchesSelector,b.matches(a||"*")};return"function"==typeof a&&(b=a),a instanceof u&&(b=function(b){return a.nodes.indexOf(b)!==-1}),u(this.nodes.filter(b))},u.prototype.find=function(a){return this.map(function(b){return u(a||"*",b)})},u.prototype.first=function(){return this.nodes[0]||!1},u.prototype.generate=function(a){return/^\\s*<t(h|r|d)/.test(a)?u(document.createElement("table")).html(a).children().nodes:/^\\s*</.test(a)?u(document.createElement("div")).html(a).children().nodes:document.createTextNode(a)},u.prototype.handle=function(){var a=this.slice(arguments).map(function(a){return"function"==typeof a?function(b){b.preventDefault(),a.apply(this,arguments)}:a},this);return this.on.apply(this,a)},u.prototype.hasClass=function(){return this.is("."+this.args(arguments).join("."))},u.prototype.html=function(a){return void 0===a?this.first().innerHTML||"":this.each(function(b){b.innerHTML=a})},u.prototype.is=function(a){return this.filter(a).length>0},u.prototype.isInPage=function(a){return a!==document.body&&document.body.contains(a)},u.prototype.last=function(){return this.nodes[this.length-1]||!1},u.prototype.map=function(a){return a?u(this.array(a)).unique():this},u.prototype.not=function(a){return this.filter(function(b){return!u(b).is(a||!0)})},u.prototype.off=function(a){return this.eacharg(a,function(a,b){u(a._e?a._e[b]:[]).each(function(c){a.removeEventListener(b,c)})})},u.prototype.on=function(a,b,c){if("string"==typeof b){var d=b;b=function(a){var b=arguments;u(a.currentTarget).find(d).each(function(d){if(d===a.target||d.contains(a.target)){try{Object.defineProperty(a,"currentTarget",{get:function(){return d}})}catch(e){}c.apply(d,b)}})}}var e=function(a){return b.apply(this,[a].concat(a.detail||[]))};return this.eacharg(a,function(a,b){a.addEventListener(b,e),a._e=a._e||{},a._e[b]=a._e[b]||[],a._e[b].push(e)})},u.prototype.pairs=function(a,b,c,d){if("undefined"!=typeof b){var e=a;a={},a[e]=b}return"object"==typeof a?this.each(function(b){for(var c in a)d(b,c,a[c])}):this.length?c(this.first(),a):""},u.prototype.param=function(a){return Object.keys(a).map(function(b){return this.uri(b)+"="+this.uri(a[b])}.bind(this)).join("&")},u.prototype.parent=function(a){return this.map(function(a){return a.parentNode}).filter(a)},u.prototype.prepend=function(a,b){return this.adjacent(a,b,function(a,b){a.insertBefore(b,a.firstChild)})},u.prototype.remove=function(){return this.each(function(a){a.parentNode&&a.parentNode.removeChild(a)})},u.prototype.removeClass=function(){return this.eacharg(arguments,function(a,b){a.classList.remove(b)})},u.prototype.replace=function(a,b){var c=[];return this.adjacent(a,b,function(a,b){c=c.concat(this.slice(b.children)),a.parentNode.replaceChild(b,a)}),u(c)},u.prototype.scroll=function(){return this.first().scrollIntoView({behavior:"smooth"}),this},u.prototype.select=function(a,b){if(a=a.replace(/^\\s*/,"").replace(/\\s*$/,""),b)return this.select.byCss(a,b);for(var c in this.selectors)if(b=c.split("/"),new RegExp(b[1],b[2]).test(a))return this.selectors[c](a);return this.select.byCss(a)},u.prototype.select.byCss=function(a,b){return(b||document).querySelectorAll(a)},u.prototype.selectors={},u.prototype.selectors[/^\\.[\\w\\-]+$/]=function(a){return document.getElementsByClassName(a.substring(1))},u.prototype.selectors[/^\\w+$/]=function(a){return document.getElementsByTagName(a)},u.prototype.selectors[/^\\#[\\w\\-]+$/]=function(a){return document.getElementById(a.substring(1))},u.prototype.selectors[/^</]=function(a){return u().generate(a)},u.prototype.serialize=function(){var a=this;return this.slice(this.first().elements).reduce(function(b,c){return!c.name||c.disabled||"file"===c.type?b:/(checkbox|radio)/.test(c.type)&&!c.checked?b:"select-multiple"===c.type?(u(c.options).each(function(d){d.selected&&(b+="&"+a.uri(c.name)+"="+a.uri(d.value))}),b):b+"&"+a.uri(c.name)+"="+a.uri(c.value)},"").slice(1)},u.prototype.siblings=function(a){return this.parent().children(a).not(this)},u.prototype.size=function(){return this.first().getBoundingClientRect()},u.prototype.slice=function(a){return a&&0!==a.length&&"string"!=typeof a&&"[object Function]"!==a.toString()?a.length?[].slice.call(a.nodes||a):[a]:[]},u.prototype.str=function(a,b){return function(c){return"function"==typeof c?c.call(this,a,b):c.toString()}},u.prototype.text=function(a){return void 0===a?this.first().textContent||"":this.each(function(b){b.textContent=a})},u.prototype.toggleClass=function(a,b){return!!b===b?this[b?"addClass":"removeClass"](a):this.eacharg(a,function(a,b){a.classList.toggle(b)})},u.prototype.trigger=function(a){var b=this.slice(arguments).slice(1);return this.eacharg(a,function(a,c){var d,e={bubbles:!0,cancelable:!0,detail:b};try{d=new window.CustomEvent(c,e)}catch(f){d=document.createEvent("CustomEvent"),d.initCustomEvent(c,!0,!0,b)}a.dispatchEvent(d)})},u.prototype.unique=function(){return u(this.nodes.reduce(function(a,b){var c=null!==b&&void 0!==b&&b!==!1;return c&&a.indexOf(b)===-1?a.concat(b):a},[]))},u.prototype.uri=function(a){return encodeURIComponent(a).replace(/!/g,"%21").replace(/\'/g,"%27").replace(/\\(/g,"%28").replace(/\\)/g,"%29").replace(/\\*/g,"%2A").replace(/%20/g,"+")},u.prototype.wrap=function(a){function b(a){for(;a.firstElementChild;)a=a.firstElementChild;return u(a)}return this.map(function(c){return u(a).each(function(a){b(a).append(c.cloneNode(!0)),c.parentNode.replaceChild(a,c)})})},"object"==typeof module&&module.exports&&(module.exports={u:u,ajax:ajax});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW1icmVsbGFqcy91bWJyZWxsYS5taW4uanM/ZmE4MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHVCQUF1QixpQkFBaUIsUUFBUSxrQkFBa0IsaUVBQWlFLGlaQUFpWixnQ0FBZ0MseUNBQXlDLG9CQUFvQix1QkFBdUIsMkZBQTJGLGdCQUFnQiwwQ0FBMEMsMERBQTBELGdDQUFnQyxzQkFBc0IsSUFBSSxvQkFBb0Isa0NBQWtDLFVBQVUsU0FBUyxvQkFBb0IsdUpBQXVKLGFBQWEsYUFBYSwwQkFBMEIsc0RBQXNELDRDQUE0QyxtQkFBbUIsRUFBRSxzQ0FBc0Msc0hBQXNILHdDQUF3QyxPQUFPLG9CQUFvQixrREFBa0QsK0NBQStDLG1CQUFtQixzRUFBc0UsbUJBQW1CLEVBQUUsaUNBQWlDLHVDQUF1QywyQ0FBMkMsRUFBRSxnQ0FBZ0Msd0NBQXdDLDZCQUE2Qix1REFBdUQsa0NBQWtDLEVBQUUsa0NBQWtDLHVDQUF1QyxpQkFBaUIsRUFBRSxrQ0FBa0MsZ0pBQWdKLGdCQUFnQixFQUFFLCtCQUErQixJQUFJLFdBQVcseUNBQXlDLE1BQU0sa0lBQWtJLEtBQUssa0NBQWtDLG1EQUFtRCwyQkFBMkIsaUJBQWlCLHNCQUFzQixFQUFFLGtDQUFrQyx1Q0FBdUMsK0JBQStCLEVBQUUsa0NBQWtDLDRCQUE0Qiw4QkFBOEIsWUFBWSw4QkFBOEIsOEJBQThCLHVDQUF1Qyx5Q0FBeUMsc0RBQXNELElBQUksRUFBRSxnQ0FBZ0MscUNBQXFDLHNCQUFzQix5Q0FBeUMsc0RBQXNELGFBQWEsRUFBRSx5Q0FBeUMscUNBQXFDLDJDQUEyQyx1Q0FBdUMsaUNBQWlDLDRCQUE0QiwwQkFBMEIsc0NBQXNDLEVBQUUsZ0NBQWdDLHlCQUF5Qiw4QkFBOEIsNkNBQTZDLG1DQUFtQywrQkFBK0IscUNBQXFDLGlCQUFpQixPQUFPLEVBQUUsOEJBQThCLDZCQUE2QixLQUFLLGFBQWEsNkJBQTZCLEVBQUUsZ0NBQWdDLGtCQUFrQiw0RkFBNEYsaUVBQWlFLCtCQUErQiwwQkFBMEIsOEJBQThCLDRCQUE0QixtQkFBbUIsRUFBRSw4QkFBOEIseUJBQXlCLGtDQUFrQywrTEFBK0wsK0JBQStCLDRDQUE0Qyx1Q0FBdUMsMkNBQTJDLEdBQUcsT0FBTyw2QkFBNkIsaUNBQWlDLG1EQUFtRCw4QkFBOEIsbUVBQW1FLGNBQWMsRUFBRSw0QkFBNEIsK0JBQStCLGtDQUFrQyxvREFBb0QsNkJBQTZCLHFDQUFxQyw2QkFBNkIsd0NBQXdDLDZCQUE2QiwrQkFBK0Isc0JBQXNCLEVBQUUsNkJBQTZCLG9DQUFvQyxvQ0FBb0MsMkJBQTJCLEVBQUUsRUFBRSxnQ0FBZ0MsdUJBQXVCLFFBQVEsY0FBYyxnQkFBZ0IsNENBQTRDLHVDQUF1QyxJQUFJLHlDQUF5QyxlQUFlLFVBQVUsRUFBRSxVQUFVLGNBQWMsR0FBRyxrQkFBa0IsK0NBQStDLG9DQUFvQyxxQ0FBcUMscUNBQXFDLEVBQUUscUNBQXFDLDBCQUEwQixRQUFRLElBQUksUUFBUSwrQ0FBK0MsMkJBQTJCLG1DQUFtQywrQkFBK0Isc0NBQXNDLHNDQUFzQyx1QkFBdUIsZ0NBQWdDLDRCQUE0QixvQkFBb0IsWUFBWSxtQ0FBbUMsdUNBQXVDLCtCQUErQixFQUFFLCtCQUErQiw2QkFBNkIsMENBQTBDLEVBQUUsb0NBQW9DLDRDQUE0QyxzQkFBc0IsRUFBRSxtQ0FBbUMsU0FBUyx1Q0FBdUMsa0VBQWtFLE9BQU8sK0JBQStCLG9DQUFvQyxrQkFBa0IsT0FBTyxrQ0FBa0MsNkVBQTZFLHdHQUF3Ryw0QkFBNEIsd0NBQXdDLHdDQUF3Qyx5QkFBeUIsa0RBQWtELHVEQUF1RCw0Q0FBNEMsd0NBQXdDLGtEQUFrRCwrQ0FBK0MseUNBQXlDLHVCQUF1QixrQ0FBa0MsV0FBVyw4REFBOEQscUpBQXFKLHNEQUFzRCw0Q0FBNEMsY0FBYyxrQ0FBa0MsMkNBQTJDLDZCQUE2Qiw0Q0FBNEMsK0JBQStCLHlIQUF5SCwrQkFBK0IsbUJBQW1CLDBEQUEwRCw4QkFBOEIscUVBQXFFLGdCQUFnQixFQUFFLHVDQUF1QywrRUFBK0Usc0JBQXNCLEVBQUUsaUNBQWlDLHFDQUFxQyxvQ0FBb0MsU0FBUyxtQ0FBbUMsSUFBSSw4QkFBOEIsU0FBUyxtRUFBbUUsbUJBQW1CLEVBQUUsK0JBQStCLHlDQUF5QyxtQ0FBbUMsMENBQTBDLE1BQU0sNkJBQTZCLHdKQUF3Siw4QkFBOEIsY0FBYyxLQUFLLG9CQUFvQix1QkFBdUIsWUFBWSw0QkFBNEIsNkJBQTZCLDREQUE0RCxFQUFFLEVBQUUsMkRBQTJELGNBQWMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFVtYnJlbGxhIEpTIDIuMTAuMCB1bWJyZWxsYWpzLmNvbSAqL1xuZnVuY3Rpb24gYWpheChhLGIsYyxkKXtjPWN8fGZ1bmN0aW9uKCl7fSxiPWJ8fHt9LGIuYm9keT1iLmJvZHl8fHt9LGIubWV0aG9kPShiLm1ldGhvZHx8XCJHRVRcIikudG9VcHBlckNhc2UoKSxiLmhlYWRlcnM9Yi5oZWFkZXJzfHx7fSxiLmhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPWIuaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl18fFwiWE1MSHR0cFJlcXVlc3RcIixcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93LkZvcm1EYXRhJiZiLmJvZHkgaW5zdGFuY2VvZiB3aW5kb3cuRm9ybURhdGF8fChiLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl09Yi5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdfHxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSwvanNvbi8udGVzdChiLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pJiYoYi5ib2R5PUpTT04uc3RyaW5naWZ5KGIuYm9keSkpLFwib2JqZWN0XCIhPXR5cGVvZiBiLmJvZHl8fGIuYm9keSBpbnN0YW5jZW9mIHdpbmRvdy5Gb3JtRGF0YXx8KGIuYm9keT11KCkucGFyYW0oYi5ib2R5KSk7dmFyIGU9bmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDt1KGUpLm9uKFwiZXJyb3IgdGltZW91dCBhYm9ydFwiLGZ1bmN0aW9uKCl7YyhuZXcgRXJyb3IsbnVsbCxlKX0pLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7dmFyIGE9L14oNHw1KS8udGVzdChlLnN0YXR1cyk/bmV3IEVycm9yKGUuc3RhdHVzKTpudWxsLGI9cGFyc2VKc29uKGUucmVzcG9uc2UpfHxlLnJlc3BvbnNlO3JldHVybiBjKGEsYixlKX0pLGUub3BlbihiLm1ldGhvZCxhKSxlLndpdGhDcmVkZW50aWFscz0hMDtmb3IodmFyIGYgaW4gYi5oZWFkZXJzKWUuc2V0UmVxdWVzdEhlYWRlcihmLGIuaGVhZGVyc1tmXSk7cmV0dXJuIGQmJmQoZSksZS5zZW5kKGIuYm9keSksZX1mdW5jdGlvbiBwYXJzZUpzb24oYSl7dHJ5e3ZhciBiPUpTT04ucGFyc2UoYSk7aWYoYiYmXCJvYmplY3RcIj09dHlwZW9mIGIpcmV0dXJuIGJ9Y2F0Y2goYyl7fXJldHVybiExfXZhciB1PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiB1P2EgaW5zdGFuY2VvZiB1P2E6KFwic3RyaW5nXCI9PXR5cGVvZiBhJiYoYT10aGlzLnNlbGVjdChhLGIpKSxhJiZhLm5vZGVOYW1lJiYoYT1bYV0pLHZvaWQodGhpcy5ub2Rlcz10aGlzLnNsaWNlKGEpKSk6bmV3IHUoYSxiKX07dS5wcm90b3R5cGU9e2dldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGh9fSx1LnByb3RvdHlwZS5ub2Rlcz1bXSx1LnByb3RvdHlwZS5hZGRDbGFzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2hhcmcoYXJndW1lbnRzLGZ1bmN0aW9uKGEsYil7YS5jbGFzc0xpc3QuYWRkKGIpfSl9LHUucHJvdG90eXBlLmFkamFjZW50PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYiYmKGI9MD09PWI/W106bmV3IEFycmF5KGIpLmpvaW4oKS5zcGxpdChcIixcIikubWFwKE51bWJlci5jYWxsLE51bWJlcikpLHRoaXMuZWFjaChmdW5jdGlvbihkLGUpe3ZhciBmPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt1KGJ8fHt9KS5tYXAoZnVuY3Rpb24oYixjKXt2YXIgZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2EuY2FsbCh0aGlzLGIsYyxkLGUpOmE7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGY/dGhpcy5nZW5lcmF0ZShmKTp1KGYpfSkuZWFjaChmdW5jdGlvbihhKXt0aGlzLmlzSW5QYWdlKGEpP2YuYXBwZW5kQ2hpbGQodShhKS5jbG9uZSgpLmZpcnN0KCkpOmYuYXBwZW5kQ2hpbGQoYSl9KSxjLmNhbGwodGhpcyxkLGYpfSl9LHUucHJvdG90eXBlLmFmdGVyPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuYWRqYWNlbnQoYSxiLGZ1bmN0aW9uKGEsYil7YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGEubmV4dFNpYmxpbmcpfSl9LHUucHJvdG90eXBlLmFqYXg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5oYW5kbGUoXCJzdWJtaXRcIixmdW5jdGlvbihjKXthamF4KHUodGhpcykuYXR0cihcImFjdGlvblwiKSx7Ym9keTp1KHRoaXMpLnNlcmlhbGl6ZSgpLG1ldGhvZDp1KHRoaXMpLmF0dHIoXCJtZXRob2RcIil9LGEmJmEuYmluZCh0aGlzKSxiJiZiLmJpbmQodGhpcykpfSl9LHUucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmFkamFjZW50KGEsYixmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9KX0sdS5wcm90b3R5cGUuYXJncz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYSYmKGE9YShiLGMpKSxcInN0cmluZ1wiIT10eXBlb2YgYSYmKGE9dGhpcy5zbGljZShhKS5tYXAodGhpcy5zdHIoYixjKSkpLGEudG9TdHJpbmcoKS5zcGxpdCgvW1xccyxdKy8pLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYS5sZW5ndGh9KX0sdS5wcm90b3R5cGUuYXJyYXk9ZnVuY3Rpb24oYSl7YT1hO3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKGZ1bmN0aW9uKGMsZCxlKXt2YXIgZjtyZXR1cm4gYT8oZj1hLmNhbGwoYixkLGUpLGZ8fChmPSExKSxcInN0cmluZ1wiPT10eXBlb2YgZiYmKGY9dShmKSksZiBpbnN0YW5jZW9mIHUmJihmPWYubm9kZXMpKTpmPWQuaW5uZXJIVE1MLGMuY29uY2F0KGYhPT0hMT9mOltdKX0sW10pfSx1LnByb3RvdHlwZS5hdHRyPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYz1jP1wiZGF0YS1cIjpcIlwiLHRoaXMucGFpcnMoYSxiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZ2V0QXR0cmlidXRlKGMrYil9LGZ1bmN0aW9uKGEsYixkKXthLnNldEF0dHJpYnV0ZShjK2IsZCl9KX0sdS5wcm90b3R5cGUuYmVmb3JlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuYWRqYWNlbnQoYSxiLGZ1bmN0aW9uKGEsYil7YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGEpfSl9LHUucHJvdG90eXBlLmNoaWxkcmVuPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zbGljZShhLmNoaWxkcmVuKX0pLmZpbHRlcihhKX0sdS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmNsb25lTm9kZSghMCksZD10aGlzLmdldEFsbChjKTtyZXR1cm4gdGhpcy5nZXRBbGwoYSkuZWFjaChmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiB0aGlzLm1pcnJvcil0aGlzLm1pcnJvcltjXShhLGQubm9kZXNbYl0pfSksY30pfSx1LnByb3RvdHlwZS5nZXRBbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIHUoW2FdLmNvbmNhdCh1KFwiKlwiLGEpLm5vZGVzKSl9LHUucHJvdG90eXBlLm1pcnJvcj17fSx1LnByb3RvdHlwZS5taXJyb3IuZXZlbnRzPWZ1bmN0aW9uKGEsYil7aWYoYS5fZSlmb3IodmFyIGMgaW4gYS5fZSlhLl9lW2NdLmZvckVhY2goZnVuY3Rpb24oYSl7dShiKS5vbihjLGEpfSl9LHUucHJvdG90eXBlLm1pcnJvci5zZWxlY3Q9ZnVuY3Rpb24oYSxiKXt1KGEpLmlzKFwic2VsZWN0XCIpJiYoYi52YWx1ZT1hLnZhbHVlKX0sdS5wcm90b3R5cGUubWlycm9yLnRleHRhcmVhPWZ1bmN0aW9uKGEsYil7dShhKS5pcyhcInRleHRhcmVhXCIpJiYoYi52YWx1ZT1hLnZhbHVlKX0sdS5wcm90b3R5cGUuY2xvc2VzdD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oYil7ZG8gaWYodShiKS5pcyhhKSlyZXR1cm4gYjt3aGlsZSgoYj1iLnBhcmVudE5vZGUpJiZiIT09ZG9jdW1lbnQpfSl9LHUucHJvdG90eXBlLmRhdGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hdHRyKGEsYiwhMCl9LHUucHJvdG90eXBlLmVhY2g9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubm9kZXMuZm9yRWFjaChhLmJpbmQodGhpcykpLHRoaXN9LHUucHJvdG90eXBlLmVhY2hhcmc9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGMsZCl7dGhpcy5hcmdzKGEsYyxkKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2IuY2FsbCh0aGlzLGMsYSl9LHRoaXMpfSl9LHUucHJvdG90eXBlLmVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihhKXtmb3IoO2EuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpfSl9LHUucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtyZXR1cm4gYi5tYXRjaGVzPWIubWF0Y2hlc3x8Yi5tc01hdGNoZXNTZWxlY3Rvcnx8Yi53ZWJraXRNYXRjaGVzU2VsZWN0b3IsYi5tYXRjaGVzKGF8fFwiKlwiKX07cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYSYmKGI9YSksYSBpbnN0YW5jZW9mIHUmJihiPWZ1bmN0aW9uKGIpe3JldHVybiBhLm5vZGVzLmluZGV4T2YoYikhPT0tMX0pLHUodGhpcy5ub2Rlcy5maWx0ZXIoYikpfSx1LnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbihiKXtyZXR1cm4gdShhfHxcIipcIixiKX0pfSx1LnByb3RvdHlwZS5maXJzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzWzBdfHwhMX0sdS5wcm90b3R5cGUuZ2VuZXJhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuL15cXHMqPHQoaHxyfGQpLy50ZXN0KGEpP3UoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpKS5odG1sKGEpLmNoaWxkcmVuKCkubm9kZXM6L15cXHMqPC8udGVzdChhKT91KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmh0bWwoYSkuY2hpbGRyZW4oKS5ub2Rlczpkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKX0sdS5wcm90b3R5cGUuaGFuZGxlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zbGljZShhcmd1bWVudHMpLm1hcChmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2Z1bmN0aW9uKGIpe2IucHJldmVudERlZmF1bHQoKSxhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX06YX0sdGhpcyk7cmV0dXJuIHRoaXMub24uYXBwbHkodGhpcyxhKX0sdS5wcm90b3R5cGUuaGFzQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pcyhcIi5cIit0aGlzLmFyZ3MoYXJndW1lbnRzKS5qb2luKFwiLlwiKSl9LHUucHJvdG90eXBlLmh0bWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWE/dGhpcy5maXJzdCgpLmlubmVySFRNTHx8XCJcIjp0aGlzLmVhY2goZnVuY3Rpb24oYil7Yi5pbm5lckhUTUw9YX0pfSx1LnByb3RvdHlwZS5pcz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5maWx0ZXIoYSkubGVuZ3RoPjB9LHUucHJvdG90eXBlLmlzSW5QYWdlPWZ1bmN0aW9uKGEpe3JldHVybiBhIT09ZG9jdW1lbnQuYm9keSYmZG9jdW1lbnQuYm9keS5jb250YWlucyhhKX0sdS5wcm90b3R5cGUubGFzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzW3RoaXMubGVuZ3RoLTFdfHwhMX0sdS5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKGEpe3JldHVybiBhP3UodGhpcy5hcnJheShhKSkudW5pcXVlKCk6dGhpc30sdS5wcm90b3R5cGUubm90PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4hdShiKS5pcyhhfHwhMCl9KX0sdS5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2hhcmcoYSxmdW5jdGlvbihhLGIpe3UoYS5fZT9hLl9lW2JdOltdKS5lYWNoKGZ1bmN0aW9uKGMpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMpfSl9KX0sdS5wcm90b3R5cGUub249ZnVuY3Rpb24oYSxiLGMpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKXt2YXIgZD1iO2I9ZnVuY3Rpb24oYSl7dmFyIGI9YXJndW1lbnRzO3UoYS5jdXJyZW50VGFyZ2V0KS5maW5kKGQpLmVhY2goZnVuY3Rpb24oZCl7aWYoZD09PWEudGFyZ2V0fHxkLmNvbnRhaW5zKGEudGFyZ2V0KSl7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiY3VycmVudFRhcmdldFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZH19KX1jYXRjaChlKXt9Yy5hcHBseShkLGIpfX0pfX12YXIgZT1mdW5jdGlvbihhKXtyZXR1cm4gYi5hcHBseSh0aGlzLFthXS5jb25jYXQoYS5kZXRhaWx8fFtdKSl9O3JldHVybiB0aGlzLmVhY2hhcmcoYSxmdW5jdGlvbihhLGIpe2EuYWRkRXZlbnRMaXN0ZW5lcihiLGUpLGEuX2U9YS5fZXx8e30sYS5fZVtiXT1hLl9lW2JdfHxbXSxhLl9lW2JdLnB1c2goZSl9KX0sdS5wcm90b3R5cGUucGFpcnM9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGIpe3ZhciBlPWE7YT17fSxhW2VdPWJ9cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGE/dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe2Zvcih2YXIgYyBpbiBhKWQoYixjLGFbY10pfSk6dGhpcy5sZW5ndGg/Yyh0aGlzLmZpcnN0KCksYSk6XCJcIn0sdS5wcm90b3R5cGUucGFyYW09ZnVuY3Rpb24oYSl7cmV0dXJuIE9iamVjdC5rZXlzKGEpLm1hcChmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy51cmkoYikrXCI9XCIrdGhpcy51cmkoYVtiXSl9LmJpbmQodGhpcykpLmpvaW4oXCImXCIpfSx1LnByb3RvdHlwZS5wYXJlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLnBhcmVudE5vZGV9KS5maWx0ZXIoYSl9LHUucHJvdG90eXBlLnByZXBlbmQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hZGphY2VudChhLGIsZnVuY3Rpb24oYSxiKXthLmluc2VydEJlZm9yZShiLGEuZmlyc3RDaGlsZCl9KX0sdS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihhKXthLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKX0pfSx1LnByb3RvdHlwZS5yZW1vdmVDbGFzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2hhcmcoYXJndW1lbnRzLGZ1bmN0aW9uKGEsYil7YS5jbGFzc0xpc3QucmVtb3ZlKGIpfSl9LHUucHJvdG90eXBlLnJlcGxhY2U9ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXTtyZXR1cm4gdGhpcy5hZGphY2VudChhLGIsZnVuY3Rpb24oYSxiKXtjPWMuY29uY2F0KHRoaXMuc2xpY2UoYi5jaGlsZHJlbikpLGEucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYixhKX0pLHUoYyl9LHUucHJvdG90eXBlLnNjcm9sbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZpcnN0KCkuc2Nyb2xsSW50b1ZpZXcoe2JlaGF2aW9yOlwic21vb3RoXCJ9KSx0aGlzfSx1LnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24oYSxiKXtpZihhPWEucmVwbGFjZSgvXlxccyovLFwiXCIpLnJlcGxhY2UoL1xccyokLyxcIlwiKSxiKXJldHVybiB0aGlzLnNlbGVjdC5ieUNzcyhhLGIpO2Zvcih2YXIgYyBpbiB0aGlzLnNlbGVjdG9ycylpZihiPWMuc3BsaXQoXCIvXCIpLG5ldyBSZWdFeHAoYlsxXSxiWzJdKS50ZXN0KGEpKXJldHVybiB0aGlzLnNlbGVjdG9yc1tjXShhKTtyZXR1cm4gdGhpcy5zZWxlY3QuYnlDc3MoYSl9LHUucHJvdG90eXBlLnNlbGVjdC5ieUNzcz1mdW5jdGlvbihhLGIpe3JldHVybihifHxkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChhKX0sdS5wcm90b3R5cGUuc2VsZWN0b3JzPXt9LHUucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcLltcXHdcXC1dKyQvXT1mdW5jdGlvbihhKXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhLnN1YnN0cmluZygxKSl9LHUucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcdyskL109ZnVuY3Rpb24oYSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpfSx1LnByb3RvdHlwZS5zZWxlY3RvcnNbL15cXCNbXFx3XFwtXSskL109ZnVuY3Rpb24oYSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEuc3Vic3RyaW5nKDEpKX0sdS5wcm90b3R5cGUuc2VsZWN0b3JzWy9ePC9dPWZ1bmN0aW9uKGEpe3JldHVybiB1KCkuZ2VuZXJhdGUoYSl9LHUucHJvdG90eXBlLnNlcmlhbGl6ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuc2xpY2UodGhpcy5maXJzdCgpLmVsZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24oYixjKXtyZXR1cm4hYy5uYW1lfHxjLmRpc2FibGVkfHxcImZpbGVcIj09PWMudHlwZT9iOi8oY2hlY2tib3h8cmFkaW8pLy50ZXN0KGMudHlwZSkmJiFjLmNoZWNrZWQ/YjpcInNlbGVjdC1tdWx0aXBsZVwiPT09Yy50eXBlPyh1KGMub3B0aW9ucykuZWFjaChmdW5jdGlvbihkKXtkLnNlbGVjdGVkJiYoYis9XCImXCIrYS51cmkoYy5uYW1lKStcIj1cIithLnVyaShkLnZhbHVlKSl9KSxiKTpiK1wiJlwiK2EudXJpKGMubmFtZSkrXCI9XCIrYS51cmkoYy52YWx1ZSl9LFwiXCIpLnNsaWNlKDEpfSx1LnByb3RvdHlwZS5zaWJsaW5ncz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbihhKS5ub3QodGhpcyl9LHUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maXJzdCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpfSx1LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihhKXtyZXR1cm4gYSYmMCE9PWEubGVuZ3RoJiZcInN0cmluZ1wiIT10eXBlb2YgYSYmXCJbb2JqZWN0IEZ1bmN0aW9uXVwiIT09YS50b1N0cmluZygpP2EubGVuZ3RoP1tdLnNsaWNlLmNhbGwoYS5ub2Rlc3x8YSk6W2FdOltdfSx1LnByb3RvdHlwZS5zdHI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYz9jLmNhbGwodGhpcyxhLGIpOmMudG9TdHJpbmcoKX19LHUucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWE/dGhpcy5maXJzdCgpLnRleHRDb250ZW50fHxcIlwiOnRoaXMuZWFjaChmdW5jdGlvbihiKXtiLnRleHRDb250ZW50PWF9KX0sdS5wcm90b3R5cGUudG9nZ2xlQ2xhc3M9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hIWI9PT1iP3RoaXNbYj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShhKTp0aGlzLmVhY2hhcmcoYSxmdW5jdGlvbihhLGIpe2EuY2xhc3NMaXN0LnRvZ2dsZShiKX0pfSx1LnByb3RvdHlwZS50cmlnZ2VyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2xpY2UoYXJndW1lbnRzKS5zbGljZSgxKTtyZXR1cm4gdGhpcy5lYWNoYXJnKGEsZnVuY3Rpb24oYSxjKXt2YXIgZCxlPXtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsZGV0YWlsOmJ9O3RyeXtkPW5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoYyxlKX1jYXRjaChmKXtkPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIiksZC5pbml0Q3VzdG9tRXZlbnQoYywhMCwhMCxiKX1hLmRpc3BhdGNoRXZlbnQoZCl9KX0sdS5wcm90b3R5cGUudW5pcXVlPWZ1bmN0aW9uKCl7cmV0dXJuIHUodGhpcy5ub2Rlcy5yZWR1Y2UoZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsIT09YiYmdm9pZCAwIT09YiYmYiE9PSExO3JldHVybiBjJiZhLmluZGV4T2YoYik9PT0tMT9hLmNvbmNhdChiKTphfSxbXSkpfSx1LnByb3RvdHlwZS51cmk9ZnVuY3Rpb24oYSl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChhKS5yZXBsYWNlKC8hL2csXCIlMjFcIikucmVwbGFjZSgvJy9nLFwiJTI3XCIpLnJlcGxhY2UoL1xcKC9nLFwiJTI4XCIpLnJlcGxhY2UoL1xcKS9nLFwiJTI5XCIpLnJlcGxhY2UoL1xcKi9nLFwiJTJBXCIpLnJlcGxhY2UoLyUyMC9nLFwiK1wiKX0sdS5wcm90b3R5cGUud3JhcD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2Zvcig7YS5maXJzdEVsZW1lbnRDaGlsZDspYT1hLmZpcnN0RWxlbWVudENoaWxkO3JldHVybiB1KGEpfXJldHVybiB0aGlzLm1hcChmdW5jdGlvbihjKXtyZXR1cm4gdShhKS5lYWNoKGZ1bmN0aW9uKGEpe2IoYSkuYXBwZW5kKGMuY2xvbmVOb2RlKCEwKSksYy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChhLGMpfSl9KX0sXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJihtb2R1bGUuZXhwb3J0cz17dTp1LGFqYXg6YWpheH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3VtYnJlbGxhanMvdW1icmVsbGEubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},2:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * validate v1.1.0: A lightweight form validation script that augments native HTML5 form validation elements and attributes.\n * (c) 2017 Chris Ferdinandi\n * MIT License\n * http://github.com/cferdinandi/validate\n */\n\n(function (root, factory) {\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory(root)),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if ( typeof exports === 'object' ) {\n\t\tmodule.exports = factory(root);\n\t} else {\n\t\troot.validate = factory(root);\n\t}\n})(typeof global !== 'undefined' ? global : this.window || this.global, (function (root) {\n\n\t'use strict';\n\n\t//\n\t// Variables\n\t//\n\n\tvar validate = {}; // Object for public APIs\n\tvar supports = 'querySelector' in document && 'addEventListener' in root; // Feature test\n\tvar settings;\n\n\t// Default settings\n\tvar defaults = {\n\n\t\t// Classes and Selectors\n\t\tselector: '[data-validate]',\n\t\tfieldClass: 'error',\n\t\terrorClass: 'error-message',\n\n\t\t// Messages\n\t\tmessageValueMissing: 'Please fill out this field.',\n\t\tmessageValueMissingSelect: 'Please select a value.',\n\t\tmessageValueMissingSelectMulti: 'Please select at least one value.',\n\t\tmessageTypeMismatchEmail: 'Please enter an email address.',\n\t\tmessageTypeMismatchURL: 'Please enter a URL.',\n\t\tmessageTooShort: 'Please lengthen this text to {minLength} characters or more. You are currently using {length} characters.',\n\t\tmessageTooLong: 'Please shorten this text to no more than {maxLength} characters. You are currently using {length} characters.',\n\t\tmessagePatternMismatch: 'Please match the requested format.',\n\t\tmessageBadInput: 'Please enter a number.',\n\t\tmessageStepMismatch: 'Please select a valid value.',\n\t\tmessageRangeOverflow: 'Please select a value that is no more than {max}.',\n\t\tmessageRangeUnderflow: 'Please select a value that is no less than {min}.',\n\t\tmessageGeneric: 'The value you entered for this field is invalid.',\n\n\t\t// Form Submission\n\t\tdisableSubmit: false,\n\t\tonSubmit: function () {},\n\n\t\t// Callbacks\n\t\tbeforeShowError: function () {},\n\t\tafterShowError: function () {},\n\t\tbeforeRemoveError: function () {},\n\t\tafterRemoveError: function () {},\n\n\t};\n\n\n\t//\n\t// Methods\n\t//\n\n\t// Element.matches() polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches =\n\t\t\tElement.prototype.matchesSelector ||\n\t\t\tElement.prototype.mozMatchesSelector ||\n\t\t\tElement.prototype.msMatchesSelector ||\n\t\t\tElement.prototype.oMatchesSelector ||\n\t\t\tElement.prototype.webkitMatchesSelector ||\n\t\t\tfunction(s) {\n\t\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s),\n\t\t\t\t\ti = matches.length;\n\t\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\t\treturn i > -1;\n\t\t\t};\n\t}\n\n\t/**\n\t * Merge two or more objects. Returns a new object.\n\t * @private\n\t * @param {Boolean}  deep     If true, do a deep (or recursive) merge [optional]\n\t * @param {Object}   objects  The objects to merge together\n\t * @returns {Object}          Merged values of defaults and options\n\t */\n\tvar extend = function () {\n\n\t\t// Variables\n\t\tvar extended = {};\n\t\tvar deep = false;\n\t\tvar i = 0;\n\t\tvar length = arguments.length;\n\n\t\t// Check if a deep merge\n\t\tif ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {\n\t\t\tdeep = arguments[0];\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge the object into the extended object\n\t\tvar merge = function (obj) {\n\t\t\tfor ( var prop in obj ) {\n\t\t\t\tif ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {\n\t\t\t\t\t// If deep merge and property is an object, merge properties\n\t\t\t\t\tif ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {\n\t\t\t\t\t\textended[prop] = extend( true, extended[prop], obj[prop] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\textended[prop] = obj[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Loop through each object and conduct a merge\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tvar obj = arguments[i];\n\t\t\tmerge(obj);\n\t\t}\n\n\t\treturn extended;\n\n\t};\n\n\t/**\n\t * Get the closest matching element up the DOM tree.\n\t * @private\n\t * @param  {Element} elem     Starting element\n\t * @param  {String}  selector Selector to match against\n\t * @return {Boolean|Element}  Returns null if not match found\n\t */\n\tvar getClosest = function ( elem, selector ) {\n\t\tfor ( ; elem && elem !== document; elem = elem.parentNode ) {\n\t\t\tif ( elem.matches( selector ) ) return elem;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Validate a form field\n\t * @public\n\t * @param  {Node}    field   The field to validate\n\t * @param  {Object}  options User options\n\t * @return {String}          The error message\n\t */\n\tvalidate.hasError = function (field, options) {\n\n\t\t// Merge user options with existing settings or defaults\n\t\tvar localSettings = extend(settings || defaults, options || {});\n\n\t\t// Don't validate submits, buttons, file and reset inputs, and disabled fields\n\t\tif (field.disabled || field.type === 'file' || field.type === 'reset' || field.type === 'submit' || field.type === 'button') return;\n\n\t\t// Get validity\n\t\tvar validity = field.validity;\n\n\t\t// If valid, return null\n\t\tif (validity.valid) return;\n\n\t\t// If field is required and empty\n\t\tif (validity.valueMissing) {\n\t\t\t\n\t\t\tif (field.type === 'select-multiple') return localSettings.messageValueMissingSelectMulti;\n\n\t\t\tif (field.type === 'select-one') return localSettings.messageValueMissingSelect;\n\n\t\t\treturn localSettings.messageValueMissing;\n\t\t}\n\n\t\t// If not the right type\n\t\tif (validity.typeMismatch) {\n\n\t\t\t// Email\n\t\t\tif (field.type === 'email') return localSettings.messageTypeMismatchEmail;\n\n\t\t\t// URL\n\t\t\tif (field.type === 'url') return localSettings.messageTypeMismatchURL;\n\n\t\t}\n\n\t\t// If too short\n\t\tif (validity.tooShort) return localSettings.messageTooShort.replace('{minLength}', field.getAttribute('minLength')).replace('{length}', field.value.length);\n\n\t\t// If too long\n\t\tif (validity.tooLong) return localSettings.messageTooLong.replace('{minLength}', field.getAttribute('maxLength')).replace('{length}', field.value.length);\n\n\t\t// If number input isn't a number\n\t\tif (validity.badInput) return localSettings.messageBadInput;\n\n\t\t// If a number value doesn't match the step interval\n\t\tif (validity.stepMismatch) return localSettings.messageStepMismatch;\n\n\t\t// If a number field is over the max\n\t\tif (validity.rangeOverflow) return localSettings.messageRangeOverflow.replace('{max}', field.getAttribute('max'));\n\n\t\t// If a number field is below the min\n\t\tif (validity.rangeUnderflow) return localSettings.messageRangeUnderflow.replace('{min}', field.getAttribute('min'));\n\n\t\t// If pattern doesn't match\n\t\tif (validity.patternMismatch) {\n\n\t\t\t// If pattern info is included, return custom error\n\t\t\tif (field.hasAttribute('title')) return field.getAttribute('title');\n\n\t\t\t// Otherwise, generic error\n\t\t\treturn localSettings.messagePatternMismatch;\n\n\t\t}\n\n\t\t// If all else fails, return a generic catchall error\n\t\treturn localSettings.messageGeneric;\n\n\t};\n\n\t/**\n\t * Show an error message on a field\n\t * @public\n\t * @param  {Node}   field   The field to show an error message for\n\t * @param  {String} error   The error message to show\n\t * @param  {Object} options User options\n\t */\n\tvalidate.showError = function (field, error, options) {\n\n\t\t// Merge user options with existing settings or defaults\n\t\tvar localSettings = extend(settings || defaults, options || {});\n\n\t\t// Before show error callback\n\t\tlocalSettings.beforeShowError(field, error);\n\n\t\t// Add error class to field\n\t\tfield.classList.add(localSettings.fieldClass);\n\n\t\t// If the field is a radio button and part of a group, error all and get the last item in the group\n\t\tif (field.type === 'radio' && field.name) {\n\t\t\tvar group = document.getElementsByName(field.name);\n\t\t\tif (group.length > 0) {\n\t\t\t\tfor (var i = 0; i < group.length; i++) {\n\t\t\t\t\tif (group[i].form !== field.form) continue; // Only check fields in current form\n\t\t\t\t\tgroup[i].classList.add(localSettings.fieldClass);\n\t\t\t\t}\n\t\t\t\tfield = group[group.length - 1];\n\t\t\t}\n\t\t}\n\n\t\t// Get field id or name\n\t\tvar id = field.id || field.name;\n\t\tif (!id) return;\n\n\t\t// Check if error message field already exists\n\t\t// If not, create one\n\t\tvar message = field.form.querySelector('.' + localSettings.errorClass + '#error-for-' + id );\n\t\tif (!message) {\n\t\t\tmessage = document.createElement('div');\n\t\t\tmessage.className = localSettings.errorClass;\n\t\t\tmessage.id = 'error-for-' + id;\n\n\t\t\t// If the field is a radio button or checkbox, insert error after the label\n\t\t\tvar label;\n\t\t\tif (field.type === 'radio' || field.type ==='checkbox') {\n\t\t\t\tlabel = field.form.querySelector('label[for=\"' + id + '\"]') || getClosest(field, 'label');\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.parentNode.insertBefore( message, label.nextSibling );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, insert it after the field\n\t\t\tif (!label) {\n\t\t\t\tfield.parentNode.insertBefore( message, field.nextSibling );\n\t\t\t}\n\t\t}\n\n\t\t// Add ARIA role to the field\n\t\tfield.setAttribute('aria-describedby', 'error-for-' + id);\n\n\t\t// Update error message\n\t\tmessage.innerHTML = error;\n\n\t\t// Remove any existing styles hiding the error message\n\t\tmessage.style.display = '';\n\t\tmessage.style.visibility = '';\n\n\t\t// After show error callback\n\t\tlocalSettings.afterShowError(field, error);\n\n\t};\n\n\t/**\n\t * Remove an error message from a field\n\t * @public\n\t * @param  {Node}   field   The field to remove the error from\n\t * @param  {Object} options User options\n\t */\n\tvalidate.removeError = function (field, options) {\n\n\t\t// Merge user options with existing settings or defaults\n\t\tvar localSettings = extend(settings || defaults, options || {});\n\n\t\t// Before remove error callback\n\t\tlocalSettings.beforeRemoveError(field);\n\n\t\t// Remove ARIA role from the field\n\t\tfield.removeAttribute('aria-describedby');\n\n\t\t// Remove error class to field\n\t\tfield.classList.remove(localSettings.fieldClass);\n\n\t\t// If the field is a radio button and part of a group, remove error from all and get the last item in the group\n\t\tif (field.type === 'radio' && field.name) {\n\t\t\tvar group = document.getElementsByName(field.name);\n\t\t\tif (group.length > 0) {\n\t\t\t\tfor (var i = 0; i < group.length; i++) {\n\t\t\t\t\tif (group[i].form !== field.form) continue; // Only check fields in current form\n\t\t\t\t\tgroup[i].classList.remove(localSettings.fieldClass);\n\t\t\t\t}\n\t\t\t\tfield = group[group.length - 1];\n\t\t\t}\n\t\t}\n\n\t\t// Get field id or name\n\t\tvar id = field.id || field.name;\n\t\tif (!id) return;\n\n\t\t// Check if an error message is in the DOM\n\t\tvar message = field.form.querySelector('.' + localSettings.errorClass + '#error-for-' + id + '');\n\t\tif (!message) return;\n\n\t\t// If so, hide it\n\t\tmessage.innerHTML = '';\n\t\tmessage.style.display = 'none';\n\t\tmessage.style.visibility = 'hidden';\n\n\t\t// After remove error callback\n\t\tlocalSettings.afterRemoveError(field);\n\n\t};\n\n\t/**\n\t * Add the `novalidate` attribute to all forms\n\t * @private\n\t * @param {Boolean} remove  If true, remove the `novalidate` attribute\n\t */\n\tvar addNoValidate = function (remove) {\n\t\tvar forms = document.querySelectorAll(settings.selector);\n\t\tfor (var i = 0; i < forms.length; i++) {\n\t\t\tif (remove) {\n\t\t\t\tforms[i].removeAttribute('novalidate');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tforms[i].setAttribute('novalidate', true);\n\t\t}\n\t};\n\n\t/**\n\t * Check field validity when it loses focus\n\t * @private\n\t * @param  {Event} event The blur event\n\t */\n\tvar blurHandler = function (event) {\n\n\t\t// Only run if the field is in a form to be validated\n\t\tif (!event.target.form || !event.target.form.matches(settings.selector)) return;\n\n\t\t// Validate the field\n\t\tvar error = validate.hasError(event.target);\n\n\t\t// If there's an error, show it\n\t\tif (error) {\n\t\t\tvalidate.showError(event.target, error);\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, remove any errors that exist\n\t\tvalidate.removeError(event.target);\n\n\t};\n\n\t/**\n\t * Check radio and checkbox field validity when clicked\n\t * @private\n\t * @param  {Event} event The click event\n\t */\n\tvar clickHandler = function (event) {\n\n\t\t// Only run if the field is in a form to be validated\n\t\tif (!event.target.form || !event.target.form.matches(settings.selector)) return;\n\n\t\t// Only run if the field is a checkbox or radio\n\t\tvar type = event.target.getAttribute('type');\n\t\tif (!(type === 'checkbox' || type === 'radio')) return;\n\n\t\t// Validate the field\n\t\tvar error = validate.hasError(event.target);\n\n\t\t// If there's an error, show it\n\t\tif (error) {\n\t\t\tvalidate.showError(event.target, error);\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, remove any errors that exist\n\t\tvalidate.removeError(event.target);\n\n\t};\n\n\t/**\n\t * Check all fields on submit\n\t * @private\n\t * @param  {Event} event  The submit event\n\t */\n\tvar submitHandler = function (event) {\n\n\t\t// Only run on forms flagged for validation\n\t\tif (!event.target.matches(settings.selector)) return;\n\n\t\t// Get all of the form elements\n\t\tvar fields = event.target.elements;\n\n\t\t// Validate each field\n\t\t// Store the first field with an error to a variable so we can bring it into focus later\n\t\tvar hasErrors;\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvar error = validate.hasError(fields[i]);\n\t\t\tif (error) {\n\t\t\t\tvalidate.showError(fields[i], error);\n\t\t\t\tif (!hasErrors) {\n\t\t\t\t\thasErrors = fields[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Prevent form from submitting if there are errors or submission is disabled\n\t\tif (hasErrors || settings.disableSubmit) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\t// If there are errrors, focus on first element with error\n\t\tif (hasErrors) {\n\t\t\thasErrors.focus();\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, submit the form\n\t\tsettings.onSubmit(event.target, fields);\n\n\t};\n\n\t/**\n\t * Destroy the current initialization.\n\t * @public\n\t */\n\tvalidate.destroy = function () {\n\n\t\t// If plugin isn't already initialized, stop\n\t\tif ( !settings ) return;\n\n\t\t// Remove event listeners\n\t\tdocument.removeEventListener('blur', blurHandler, false);\n\t\tdocument.removeEventListener('click', clickHandler, true);\n\t\tdocument.removeEventListener('submit', submitHandler, false);\n\n\t\t// Remove all errors\n\t\tvar fields = document.querySelectorAll(settings.errorClass);\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvalidate.removeError(fields[i]);\n\t\t}\n\n\t\t// Remove `novalidate` from forms\n\t\taddNoValidate(true);\n\n\t\t// Reset variables\n\t\tsettings = null;\n\n\t};\n\n\t/**\n\t * Initialize Validate\n\t * @public\n\t * @param {Object} options User settings\n\t */\n\tvalidate.init = function (options) {\n\n\t\t// feature test\n\t\tif (!supports) return;\n\n\t\t// Destroy any existing initializations\n\t\tvalidate.destroy();\n\n\t\t// Merge user options with defaults\n\t\tsettings = extend(defaults, options || {});\n\n\t\t// Add the `novalidate` attribute to all forms\n\t\taddNoValidate();\n\n\t\t// Event listeners\n\t\tdocument.addEventListener('blur', blurHandler, true);\n\t\tdocument.addEventListener('click', clickHandler, true);\n\t\tdocument.addEventListener('submit', submitHandler, false);\n\n\t};\n\n\n\t//\n\t// Public APIs\n\t//\n\n\treturn validate;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUvZGlzdC9qcy92YWxpZGF0ZS5qcz82MDBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI4Q0FBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFVBQVUsOENBQThDLE9BQU87QUFDakgsNkRBQTZELFVBQVUsc0NBQXNDLE9BQU87QUFDcEg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekUsc0VBQXNFLElBQUk7QUFDMUU7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQyxrQ0FBa0M7O0FBRWxDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFB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QUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEciLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdmFsaWRhdGUgdjEuMS4wOiBBIGxpZ2h0d2VpZ2h0IGZvcm0gdmFsaWRhdGlvbiBzY3JpcHQgdGhhdCBhdWdtZW50cyBuYXRpdmUgSFRNTDUgZm9ybSB2YWxpZGF0aW9uIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzLlxuICogKGMpIDIwMTcgQ2hyaXMgRmVyZGluYW5kaVxuICogTUlUIExpY2Vuc2VcbiAqIGh0dHA6Ly9naXRodWIuY29tL2NmZXJkaW5hbmRpL3ZhbGlkYXRlXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZShbXSwgZmFjdG9yeShyb290KSk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG5cdH0gZWxzZSB7XG5cdFx0cm9vdC52YWxpZGF0ZSA9IGZhY3Rvcnkocm9vdCk7XG5cdH1cbn0pKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdGhpcy53aW5kb3cgfHwgdGhpcy5nbG9iYWwsIChmdW5jdGlvbiAocm9vdCkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvL1xuXHQvLyBWYXJpYWJsZXNcblx0Ly9cblxuXHR2YXIgdmFsaWRhdGUgPSB7fTsgLy8gT2JqZWN0IGZvciBwdWJsaWMgQVBJc1xuXHR2YXIgc3VwcG9ydHMgPSAncXVlcnlTZWxlY3RvcicgaW4gZG9jdW1lbnQgJiYgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHJvb3Q7IC8vIEZlYXR1cmUgdGVzdFxuXHR2YXIgc2V0dGluZ3M7XG5cblx0Ly8gRGVmYXVsdCBzZXR0aW5nc1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cblx0XHQvLyBDbGFzc2VzIGFuZCBTZWxlY3RvcnNcblx0XHRzZWxlY3RvcjogJ1tkYXRhLXZhbGlkYXRlXScsXG5cdFx0ZmllbGRDbGFzczogJ2Vycm9yJyxcblx0XHRlcnJvckNsYXNzOiAnZXJyb3ItbWVzc2FnZScsXG5cblx0XHQvLyBNZXNzYWdlc1xuXHRcdG1lc3NhZ2VWYWx1ZU1pc3Npbmc6ICdQbGVhc2UgZmlsbCBvdXQgdGhpcyBmaWVsZC4nLFxuXHRcdG1lc3NhZ2VWYWx1ZU1pc3NpbmdTZWxlY3Q6ICdQbGVhc2Ugc2VsZWN0IGEgdmFsdWUuJyxcblx0XHRtZXNzYWdlVmFsdWVNaXNzaW5nU2VsZWN0TXVsdGk6ICdQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSB2YWx1ZS4nLFxuXHRcdG1lc3NhZ2VUeXBlTWlzbWF0Y2hFbWFpbDogJ1BsZWFzZSBlbnRlciBhbiBlbWFpbCBhZGRyZXNzLicsXG5cdFx0bWVzc2FnZVR5cGVNaXNtYXRjaFVSTDogJ1BsZWFzZSBlbnRlciBhIFVSTC4nLFxuXHRcdG1lc3NhZ2VUb29TaG9ydDogJ1BsZWFzZSBsZW5ndGhlbiB0aGlzIHRleHQgdG8ge21pbkxlbmd0aH0gY2hhcmFjdGVycyBvciBtb3JlLiBZb3UgYXJlIGN1cnJlbnRseSB1c2luZyB7bGVuZ3RofSBjaGFyYWN0ZXJzLicsXG5cdFx0bWVzc2FnZVRvb0xvbmc6ICdQbGVhc2Ugc2hvcnRlbiB0aGlzIHRleHQgdG8gbm8gbW9yZSB0aGFuIHttYXhMZW5ndGh9IGNoYXJhY3RlcnMuIFlvdSBhcmUgY3VycmVudGx5IHVzaW5nIHtsZW5ndGh9IGNoYXJhY3RlcnMuJyxcblx0XHRtZXNzYWdlUGF0dGVybk1pc21hdGNoOiAnUGxlYXNlIG1hdGNoIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LicsXG5cdFx0bWVzc2FnZUJhZElucHV0OiAnUGxlYXNlIGVudGVyIGEgbnVtYmVyLicsXG5cdFx0bWVzc2FnZVN0ZXBNaXNtYXRjaDogJ1BsZWFzZSBzZWxlY3QgYSB2YWxpZCB2YWx1ZS4nLFxuXHRcdG1lc3NhZ2VSYW5nZU92ZXJmbG93OiAnUGxlYXNlIHNlbGVjdCBhIHZhbHVlIHRoYXQgaXMgbm8gbW9yZSB0aGFuIHttYXh9LicsXG5cdFx0bWVzc2FnZVJhbmdlVW5kZXJmbG93OiAnUGxlYXNlIHNlbGVjdCBhIHZhbHVlIHRoYXQgaXMgbm8gbGVzcyB0aGFuIHttaW59LicsXG5cdFx0bWVzc2FnZUdlbmVyaWM6ICdUaGUgdmFsdWUgeW91IGVudGVyZWQgZm9yIHRoaXMgZmllbGQgaXMgaW52YWxpZC4nLFxuXG5cdFx0Ly8gRm9ybSBTdWJtaXNzaW9uXG5cdFx0ZGlzYWJsZVN1Ym1pdDogZmFsc2UsXG5cdFx0b25TdWJtaXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0YmVmb3JlU2hvd0Vycm9yOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRhZnRlclNob3dFcnJvcjogZnVuY3Rpb24gKCkge30sXG5cdFx0YmVmb3JlUmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICgpIHt9LFxuXHRcdGFmdGVyUmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdH07XG5cblxuXHQvL1xuXHQvLyBNZXRob2RzXG5cdC8vXG5cblx0Ly8gRWxlbWVudC5tYXRjaGVzKCkgcG9seWZpbGxcblx0aWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG5cdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG5cdFx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0RWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0ZnVuY3Rpb24ocykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSxcblx0XHRcdFx0XHRpID0gbWF0Y2hlcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG5cdFx0XHRcdHJldHVybiBpID4gLTE7XG5cdFx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlIHR3byBvciBtb3JlIG9iamVjdHMuIFJldHVybnMgYSBuZXcgb2JqZWN0LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59ICBkZWVwICAgICBJZiB0cnVlLCBkbyBhIGRlZXAgKG9yIHJlY3Vyc2l2ZSkgbWVyZ2UgW29wdGlvbmFsXVxuXHQgKiBAcGFyYW0ge09iamVjdH0gICBvYmplY3RzICBUaGUgb2JqZWN0cyB0byBtZXJnZSB0b2dldGhlclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgICAgICBNZXJnZWQgdmFsdWVzIG9mIGRlZmF1bHRzIGFuZCBvcHRpb25zXG5cdCAqL1xuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gVmFyaWFibGVzXG5cdFx0dmFyIGV4dGVuZGVkID0ge307XG5cdFx0dmFyIGRlZXAgPSBmYWxzZTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cblx0XHQvLyBDaGVjayBpZiBhIGRlZXAgbWVyZ2Vcblx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggYXJndW1lbnRzWzBdICkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyApIHtcblx0XHRcdGRlZXAgPSBhcmd1bWVudHNbMF07XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0Ly8gTWVyZ2UgdGhlIG9iamVjdCBpbnRvIHRoZSBleHRlbmRlZCBvYmplY3Rcblx0XHR2YXIgbWVyZ2UgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRmb3IgKCB2YXIgcHJvcCBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBvYmosIHByb3AgKSApIHtcblx0XHRcdFx0XHQvLyBJZiBkZWVwIG1lcmdlIGFuZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QsIG1lcmdlIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAoIGRlZXAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9ialtwcm9wXSkgPT09ICdbb2JqZWN0IE9iamVjdF0nICkge1xuXHRcdFx0XHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBleHRlbmQoIHRydWUsIGV4dGVuZGVkW3Byb3BdLCBvYmpbcHJvcF0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBvYmpbcHJvcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIExvb3AgdGhyb3VnaCBlYWNoIG9iamVjdCBhbmQgY29uZHVjdCBhIG1lcmdlXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0bWVyZ2Uob2JqKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXh0ZW5kZWQ7XG5cblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBjbG9zZXN0IG1hdGNoaW5nIGVsZW1lbnQgdXAgdGhlIERPTSB0cmVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtICAgICBTdGFydGluZyBlbGVtZW50XG5cdCAqIEBwYXJhbSAge1N0cmluZ30gIHNlbGVjdG9yIFNlbGVjdG9yIHRvIG1hdGNoIGFnYWluc3Rcblx0ICogQHJldHVybiB7Qm9vbGVhbnxFbGVtZW50fSAgUmV0dXJucyBudWxsIGlmIG5vdCBtYXRjaCBmb3VuZFxuXHQgKi9cblx0dmFyIGdldENsb3Nlc3QgPSBmdW5jdGlvbiAoIGVsZW0sIHNlbGVjdG9yICkge1xuXHRcdGZvciAoIDsgZWxlbSAmJiBlbGVtICE9PSBkb2N1bWVudDsgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICggZWxlbS5tYXRjaGVzKCBzZWxlY3RvciApICkgcmV0dXJuIGVsZW07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSBhIGZvcm0gZmllbGRcblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0gIHtOb2RlfSAgICBmaWVsZCAgIFRoZSBmaWVsZCB0byB2YWxpZGF0ZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zIFVzZXIgb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIFRoZSBlcnJvciBtZXNzYWdlXG5cdCAqL1xuXHR2YWxpZGF0ZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChmaWVsZCwgb3B0aW9ucykge1xuXG5cdFx0Ly8gTWVyZ2UgdXNlciBvcHRpb25zIHdpdGggZXhpc3Rpbmcgc2V0dGluZ3Mgb3IgZGVmYXVsdHNcblx0XHR2YXIgbG9jYWxTZXR0aW5ncyA9IGV4dGVuZChzZXR0aW5ncyB8fCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cblx0XHQvLyBEb24ndCB2YWxpZGF0ZSBzdWJtaXRzLCBidXR0b25zLCBmaWxlIGFuZCByZXNldCBpbnB1dHMsIGFuZCBkaXNhYmxlZCBmaWVsZHNcblx0XHRpZiAoZmllbGQuZGlzYWJsZWQgfHwgZmllbGQudHlwZSA9PT0gJ2ZpbGUnIHx8IGZpZWxkLnR5cGUgPT09ICdyZXNldCcgfHwgZmllbGQudHlwZSA9PT0gJ3N1Ym1pdCcgfHwgZmllbGQudHlwZSA9PT0gJ2J1dHRvbicpIHJldHVybjtcblxuXHRcdC8vIEdldCB2YWxpZGl0eVxuXHRcdHZhciB2YWxpZGl0eSA9IGZpZWxkLnZhbGlkaXR5O1xuXG5cdFx0Ly8gSWYgdmFsaWQsIHJldHVybiBudWxsXG5cdFx0aWYgKHZhbGlkaXR5LnZhbGlkKSByZXR1cm47XG5cblx0XHQvLyBJZiBmaWVsZCBpcyByZXF1aXJlZCBhbmQgZW1wdHlcblx0XHRpZiAodmFsaWRpdHkudmFsdWVNaXNzaW5nKSB7XG5cdFx0XHRcblx0XHRcdGlmIChmaWVsZC50eXBlID09PSAnc2VsZWN0LW11bHRpcGxlJykgcmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZVZhbHVlTWlzc2luZ1NlbGVjdE11bHRpO1xuXG5cdFx0XHRpZiAoZmllbGQudHlwZSA9PT0gJ3NlbGVjdC1vbmUnKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVmFsdWVNaXNzaW5nU2VsZWN0O1xuXG5cdFx0XHRyZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVmFsdWVNaXNzaW5nO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vdCB0aGUgcmlnaHQgdHlwZVxuXHRcdGlmICh2YWxpZGl0eS50eXBlTWlzbWF0Y2gpIHtcblxuXHRcdFx0Ly8gRW1haWxcblx0XHRcdGlmIChmaWVsZC50eXBlID09PSAnZW1haWwnKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVHlwZU1pc21hdGNoRW1haWw7XG5cblx0XHRcdC8vIFVSTFxuXHRcdFx0aWYgKGZpZWxkLnR5cGUgPT09ICd1cmwnKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVHlwZU1pc21hdGNoVVJMO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdG9vIHNob3J0XG5cdFx0aWYgKHZhbGlkaXR5LnRvb1Nob3J0KSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVG9vU2hvcnQucmVwbGFjZSgne21pbkxlbmd0aH0nLCBmaWVsZC5nZXRBdHRyaWJ1dGUoJ21pbkxlbmd0aCcpKS5yZXBsYWNlKCd7bGVuZ3RofScsIGZpZWxkLnZhbHVlLmxlbmd0aCk7XG5cblx0XHQvLyBJZiB0b28gbG9uZ1xuXHRcdGlmICh2YWxpZGl0eS50b29Mb25nKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVG9vTG9uZy5yZXBsYWNlKCd7bWluTGVuZ3RofScsIGZpZWxkLmdldEF0dHJpYnV0ZSgnbWF4TGVuZ3RoJykpLnJlcGxhY2UoJ3tsZW5ndGh9JywgZmllbGQudmFsdWUubGVuZ3RoKTtcblxuXHRcdC8vIElmIG51bWJlciBpbnB1dCBpc24ndCBhIG51bWJlclxuXHRcdGlmICh2YWxpZGl0eS5iYWRJbnB1dCkgcmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZUJhZElucHV0O1xuXG5cdFx0Ly8gSWYgYSBudW1iZXIgdmFsdWUgZG9lc24ndCBtYXRjaCB0aGUgc3RlcCBpbnRlcnZhbFxuXHRcdGlmICh2YWxpZGl0eS5zdGVwTWlzbWF0Y2gpIHJldHVybiBsb2NhbFNldHRpbmdzLm1lc3NhZ2VTdGVwTWlzbWF0Y2g7XG5cblx0XHQvLyBJZiBhIG51bWJlciBmaWVsZCBpcyBvdmVyIHRoZSBtYXhcblx0XHRpZiAodmFsaWRpdHkucmFuZ2VPdmVyZmxvdykgcmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZVJhbmdlT3ZlcmZsb3cucmVwbGFjZSgne21heH0nLCBmaWVsZC5nZXRBdHRyaWJ1dGUoJ21heCcpKTtcblxuXHRcdC8vIElmIGEgbnVtYmVyIGZpZWxkIGlzIGJlbG93IHRoZSBtaW5cblx0XHRpZiAodmFsaWRpdHkucmFuZ2VVbmRlcmZsb3cpIHJldHVybiBsb2NhbFNldHRpbmdzLm1lc3NhZ2VSYW5nZVVuZGVyZmxvdy5yZXBsYWNlKCd7bWlufScsIGZpZWxkLmdldEF0dHJpYnV0ZSgnbWluJykpO1xuXG5cdFx0Ly8gSWYgcGF0dGVybiBkb2Vzbid0IG1hdGNoXG5cdFx0aWYgKHZhbGlkaXR5LnBhdHRlcm5NaXNtYXRjaCkge1xuXG5cdFx0XHQvLyBJZiBwYXR0ZXJuIGluZm8gaXMgaW5jbHVkZWQsIHJldHVybiBjdXN0b20gZXJyb3Jcblx0XHRcdGlmIChmaWVsZC5oYXNBdHRyaWJ1dGUoJ3RpdGxlJykpIHJldHVybiBmaWVsZC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgZ2VuZXJpYyBlcnJvclxuXHRcdFx0cmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZVBhdHRlcm5NaXNtYXRjaDtcblxuXHRcdH1cblxuXHRcdC8vIElmIGFsbCBlbHNlIGZhaWxzLCByZXR1cm4gYSBnZW5lcmljIGNhdGNoYWxsIGVycm9yXG5cdFx0cmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZUdlbmVyaWM7XG5cblx0fTtcblxuXHQvKipcblx0ICogU2hvdyBhbiBlcnJvciBtZXNzYWdlIG9uIGEgZmllbGRcblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0gIHtOb2RlfSAgIGZpZWxkICAgVGhlIGZpZWxkIHRvIHNob3cgYW4gZXJyb3IgbWVzc2FnZSBmb3Jcblx0ICogQHBhcmFtICB7U3RyaW5nfSBlcnJvciAgIFRoZSBlcnJvciBtZXNzYWdlIHRvIHNob3dcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIFVzZXIgb3B0aW9uc1xuXHQgKi9cblx0dmFsaWRhdGUuc2hvd0Vycm9yID0gZnVuY3Rpb24gKGZpZWxkLCBlcnJvciwgb3B0aW9ucykge1xuXG5cdFx0Ly8gTWVyZ2UgdXNlciBvcHRpb25zIHdpdGggZXhpc3Rpbmcgc2V0dGluZ3Mgb3IgZGVmYXVsdHNcblx0XHR2YXIgbG9jYWxTZXR0aW5ncyA9IGV4dGVuZChzZXR0aW5ncyB8fCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cblx0XHQvLyBCZWZvcmUgc2hvdyBlcnJvciBjYWxsYmFja1xuXHRcdGxvY2FsU2V0dGluZ3MuYmVmb3JlU2hvd0Vycm9yKGZpZWxkLCBlcnJvcik7XG5cblx0XHQvLyBBZGQgZXJyb3IgY2xhc3MgdG8gZmllbGRcblx0XHRmaWVsZC5jbGFzc0xpc3QuYWRkKGxvY2FsU2V0dGluZ3MuZmllbGRDbGFzcyk7XG5cblx0XHQvLyBJZiB0aGUgZmllbGQgaXMgYSByYWRpbyBidXR0b24gYW5kIHBhcnQgb2YgYSBncm91cCwgZXJyb3IgYWxsIGFuZCBnZXQgdGhlIGxhc3QgaXRlbSBpbiB0aGUgZ3JvdXBcblx0XHRpZiAoZmllbGQudHlwZSA9PT0gJ3JhZGlvJyAmJiBmaWVsZC5uYW1lKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShmaWVsZC5uYW1lKTtcblx0XHRcdGlmIChncm91cC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZ3JvdXBbaV0uZm9ybSAhPT0gZmllbGQuZm9ybSkgY29udGludWU7IC8vIE9ubHkgY2hlY2sgZmllbGRzIGluIGN1cnJlbnQgZm9ybVxuXHRcdFx0XHRcdGdyb3VwW2ldLmNsYXNzTGlzdC5hZGQobG9jYWxTZXR0aW5ncy5maWVsZENsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWVsZCA9IGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEdldCBmaWVsZCBpZCBvciBuYW1lXG5cdFx0dmFyIGlkID0gZmllbGQuaWQgfHwgZmllbGQubmFtZTtcblx0XHRpZiAoIWlkKSByZXR1cm47XG5cblx0XHQvLyBDaGVjayBpZiBlcnJvciBtZXNzYWdlIGZpZWxkIGFscmVhZHkgZXhpc3RzXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0dmFyIG1lc3NhZ2UgPSBmaWVsZC5mb3JtLnF1ZXJ5U2VsZWN0b3IoJy4nICsgbG9jYWxTZXR0aW5ncy5lcnJvckNsYXNzICsgJyNlcnJvci1mb3ItJyArIGlkICk7XG5cdFx0aWYgKCFtZXNzYWdlKSB7XG5cdFx0XHRtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRtZXNzYWdlLmNsYXNzTmFtZSA9IGxvY2FsU2V0dGluZ3MuZXJyb3JDbGFzcztcblx0XHRcdG1lc3NhZ2UuaWQgPSAnZXJyb3ItZm9yLScgKyBpZDtcblxuXHRcdFx0Ly8gSWYgdGhlIGZpZWxkIGlzIGEgcmFkaW8gYnV0dG9uIG9yIGNoZWNrYm94LCBpbnNlcnQgZXJyb3IgYWZ0ZXIgdGhlIGxhYmVsXG5cdFx0XHR2YXIgbGFiZWw7XG5cdFx0XHRpZiAoZmllbGQudHlwZSA9PT0gJ3JhZGlvJyB8fCBmaWVsZC50eXBlID09PSdjaGVja2JveCcpIHtcblx0XHRcdFx0bGFiZWwgPSBmaWVsZC5mb3JtLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsW2Zvcj1cIicgKyBpZCArICdcIl0nKSB8fCBnZXRDbG9zZXN0KGZpZWxkLCAnbGFiZWwnKTtcblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIG1lc3NhZ2UsIGxhYmVsLm5leHRTaWJsaW5nICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgaXQgYWZ0ZXIgdGhlIGZpZWxkXG5cdFx0XHRpZiAoIWxhYmVsKSB7XG5cdFx0XHRcdGZpZWxkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBtZXNzYWdlLCBmaWVsZC5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCBBUklBIHJvbGUgdG8gdGhlIGZpZWxkXG5cdFx0ZmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgJ2Vycm9yLWZvci0nICsgaWQpO1xuXG5cdFx0Ly8gVXBkYXRlIGVycm9yIG1lc3NhZ2Vcblx0XHRtZXNzYWdlLmlubmVySFRNTCA9IGVycm9yO1xuXG5cdFx0Ly8gUmVtb3ZlIGFueSBleGlzdGluZyBzdHlsZXMgaGlkaW5nIHRoZSBlcnJvciBtZXNzYWdlXG5cdFx0bWVzc2FnZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cdFx0bWVzc2FnZS5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG5cblx0XHQvLyBBZnRlciBzaG93IGVycm9yIGNhbGxiYWNrXG5cdFx0bG9jYWxTZXR0aW5ncy5hZnRlclNob3dFcnJvcihmaWVsZCwgZXJyb3IpO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBlcnJvciBtZXNzYWdlIGZyb20gYSBmaWVsZFxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSAge05vZGV9ICAgZmllbGQgICBUaGUgZmllbGQgdG8gcmVtb3ZlIHRoZSBlcnJvciBmcm9tXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBVc2VyIG9wdGlvbnNcblx0ICovXG5cdHZhbGlkYXRlLnJlbW92ZUVycm9yID0gZnVuY3Rpb24gKGZpZWxkLCBvcHRpb25zKSB7XG5cblx0XHQvLyBNZXJnZSB1c2VyIG9wdGlvbnMgd2l0aCBleGlzdGluZyBzZXR0aW5ncyBvciBkZWZhdWx0c1xuXHRcdHZhciBsb2NhbFNldHRpbmdzID0gZXh0ZW5kKHNldHRpbmdzIHx8IGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuXHRcdC8vIEJlZm9yZSByZW1vdmUgZXJyb3IgY2FsbGJhY2tcblx0XHRsb2NhbFNldHRpbmdzLmJlZm9yZVJlbW92ZUVycm9yKGZpZWxkKTtcblxuXHRcdC8vIFJlbW92ZSBBUklBIHJvbGUgZnJvbSB0aGUgZmllbGRcblx0XHRmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuXHRcdC8vIFJlbW92ZSBlcnJvciBjbGFzcyB0byBmaWVsZFxuXHRcdGZpZWxkLmNsYXNzTGlzdC5yZW1vdmUobG9jYWxTZXR0aW5ncy5maWVsZENsYXNzKTtcblxuXHRcdC8vIElmIHRoZSBmaWVsZCBpcyBhIHJhZGlvIGJ1dHRvbiBhbmQgcGFydCBvZiBhIGdyb3VwLCByZW1vdmUgZXJyb3IgZnJvbSBhbGwgYW5kIGdldCB0aGUgbGFzdCBpdGVtIGluIHRoZSBncm91cFxuXHRcdGlmIChmaWVsZC50eXBlID09PSAncmFkaW8nICYmIGZpZWxkLm5hbWUpIHtcblx0XHRcdHZhciBncm91cCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGZpZWxkLm5hbWUpO1xuXHRcdFx0aWYgKGdyb3VwLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChncm91cFtpXS5mb3JtICE9PSBmaWVsZC5mb3JtKSBjb250aW51ZTsgLy8gT25seSBjaGVjayBmaWVsZHMgaW4gY3VycmVudCBmb3JtXG5cdFx0XHRcdFx0Z3JvdXBbaV0uY2xhc3NMaXN0LnJlbW92ZShsb2NhbFNldHRpbmdzLmZpZWxkQ2xhc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpZWxkID0gZ3JvdXBbZ3JvdXAubGVuZ3RoIC0gMV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGZpZWxkIGlkIG9yIG5hbWVcblx0XHR2YXIgaWQgPSBmaWVsZC5pZCB8fCBmaWVsZC5uYW1lO1xuXHRcdGlmICghaWQpIHJldHVybjtcblxuXHRcdC8vIENoZWNrIGlmIGFuIGVycm9yIG1lc3NhZ2UgaXMgaW4gdGhlIERPTVxuXHRcdHZhciBtZXNzYWdlID0gZmllbGQuZm9ybS5xdWVyeVNlbGVjdG9yKCcuJyArIGxvY2FsU2V0dGluZ3MuZXJyb3JDbGFzcyArICcjZXJyb3ItZm9yLScgKyBpZCArICcnKTtcblx0XHRpZiAoIW1lc3NhZ2UpIHJldHVybjtcblxuXHRcdC8vIElmIHNvLCBoaWRlIGl0XG5cdFx0bWVzc2FnZS5pbm5lckhUTUwgPSAnJztcblx0XHRtZXNzYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0bWVzc2FnZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cblx0XHQvLyBBZnRlciByZW1vdmUgZXJyb3IgY2FsbGJhY2tcblx0XHRsb2NhbFNldHRpbmdzLmFmdGVyUmVtb3ZlRXJyb3IoZmllbGQpO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCB0aGUgYG5vdmFsaWRhdGVgIGF0dHJpYnV0ZSB0byBhbGwgZm9ybXNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgIElmIHRydWUsIHJlbW92ZSB0aGUgYG5vdmFsaWRhdGVgIGF0dHJpYnV0ZVxuXHQgKi9cblx0dmFyIGFkZE5vVmFsaWRhdGUgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0dmFyIGZvcm1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZXR0aW5ncy5zZWxlY3Rvcik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHJlbW92ZSkge1xuXHRcdFx0XHRmb3Jtc1tpXS5yZW1vdmVBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRmb3Jtc1tpXS5zZXRBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnLCB0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGZpZWxkIHZhbGlkaXR5IHdoZW4gaXQgbG9zZXMgZm9jdXNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IFRoZSBibHVyIGV2ZW50XG5cdCAqL1xuXHR2YXIgYmx1ckhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuXHRcdC8vIE9ubHkgcnVuIGlmIHRoZSBmaWVsZCBpcyBpbiBhIGZvcm0gdG8gYmUgdmFsaWRhdGVkXG5cdFx0aWYgKCFldmVudC50YXJnZXQuZm9ybSB8fCAhZXZlbnQudGFyZ2V0LmZvcm0ubWF0Y2hlcyhzZXR0aW5ncy5zZWxlY3RvcikpIHJldHVybjtcblxuXHRcdC8vIFZhbGlkYXRlIHRoZSBmaWVsZFxuXHRcdHZhciBlcnJvciA9IHZhbGlkYXRlLmhhc0Vycm9yKGV2ZW50LnRhcmdldCk7XG5cblx0XHQvLyBJZiB0aGVyZSdzIGFuIGVycm9yLCBzaG93IGl0XG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR2YWxpZGF0ZS5zaG93RXJyb3IoZXZlbnQudGFyZ2V0LCBlcnJvcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCByZW1vdmUgYW55IGVycm9ycyB0aGF0IGV4aXN0XG5cdFx0dmFsaWRhdGUucmVtb3ZlRXJyb3IoZXZlbnQudGFyZ2V0KTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayByYWRpbyBhbmQgY2hlY2tib3ggZmllbGQgdmFsaWRpdHkgd2hlbiBjbGlja2VkXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAge0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnRcblx0ICovXG5cdHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuXHRcdC8vIE9ubHkgcnVuIGlmIHRoZSBmaWVsZCBpcyBpbiBhIGZvcm0gdG8gYmUgdmFsaWRhdGVkXG5cdFx0aWYgKCFldmVudC50YXJnZXQuZm9ybSB8fCAhZXZlbnQudGFyZ2V0LmZvcm0ubWF0Y2hlcyhzZXR0aW5ncy5zZWxlY3RvcikpIHJldHVybjtcblxuXHRcdC8vIE9ubHkgcnVuIGlmIHRoZSBmaWVsZCBpcyBhIGNoZWNrYm94IG9yIHJhZGlvXG5cdFx0dmFyIHR5cGUgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdFx0aWYgKCEodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKSkgcmV0dXJuO1xuXG5cdFx0Ly8gVmFsaWRhdGUgdGhlIGZpZWxkXG5cdFx0dmFyIGVycm9yID0gdmFsaWRhdGUuaGFzRXJyb3IoZXZlbnQudGFyZ2V0KTtcblxuXHRcdC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IsIHNob3cgaXRcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHZhbGlkYXRlLnNob3dFcnJvcihldmVudC50YXJnZXQsIGVycm9yKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIHJlbW92ZSBhbnkgZXJyb3JzIHRoYXQgZXhpc3Rcblx0XHR2YWxpZGF0ZS5yZW1vdmVFcnJvcihldmVudC50YXJnZXQpO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGFsbCBmaWVsZHMgb24gc3VibWl0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAge0V2ZW50fSBldmVudCAgVGhlIHN1Ym1pdCBldmVudFxuXHQgKi9cblx0dmFyIHN1Ym1pdEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuXHRcdC8vIE9ubHkgcnVuIG9uIGZvcm1zIGZsYWdnZWQgZm9yIHZhbGlkYXRpb25cblx0XHRpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHNldHRpbmdzLnNlbGVjdG9yKSkgcmV0dXJuO1xuXG5cdFx0Ly8gR2V0IGFsbCBvZiB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdHZhciBmaWVsZHMgPSBldmVudC50YXJnZXQuZWxlbWVudHM7XG5cblx0XHQvLyBWYWxpZGF0ZSBlYWNoIGZpZWxkXG5cdFx0Ly8gU3RvcmUgdGhlIGZpcnN0IGZpZWxkIHdpdGggYW4gZXJyb3IgdG8gYSB2YXJpYWJsZSBzbyB3ZSBjYW4gYnJpbmcgaXQgaW50byBmb2N1cyBsYXRlclxuXHRcdHZhciBoYXNFcnJvcnM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlcnJvciA9IHZhbGlkYXRlLmhhc0Vycm9yKGZpZWxkc1tpXSk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0dmFsaWRhdGUuc2hvd0Vycm9yKGZpZWxkc1tpXSwgZXJyb3IpO1xuXHRcdFx0XHRpZiAoIWhhc0Vycm9ycykge1xuXHRcdFx0XHRcdGhhc0Vycm9ycyA9IGZpZWxkc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgZm9ybSBmcm9tIHN1Ym1pdHRpbmcgaWYgdGhlcmUgYXJlIGVycm9ycyBvciBzdWJtaXNzaW9uIGlzIGRpc2FibGVkXG5cdFx0aWYgKGhhc0Vycm9ycyB8fCBzZXR0aW5ncy5kaXNhYmxlU3VibWl0KSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBlcnJyb3JzLCBmb2N1cyBvbiBmaXJzdCBlbGVtZW50IHdpdGggZXJyb3Jcblx0XHRpZiAoaGFzRXJyb3JzKSB7XG5cdFx0XHRoYXNFcnJvcnMuZm9jdXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIHN1Ym1pdCB0aGUgZm9ybVxuXHRcdHNldHRpbmdzLm9uU3VibWl0KGV2ZW50LnRhcmdldCwgZmllbGRzKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHRoZSBjdXJyZW50IGluaXRpYWxpemF0aW9uLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHR2YWxpZGF0ZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gSWYgcGx1Z2luIGlzbid0IGFscmVhZHkgaW5pdGlhbGl6ZWQsIHN0b3Bcblx0XHRpZiAoICFzZXR0aW5ncyApIHJldHVybjtcblxuXHRcdC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgYmx1ckhhbmRsZXIsIGZhbHNlKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VibWl0Jywgc3VibWl0SGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0Ly8gUmVtb3ZlIGFsbCBlcnJvcnNcblx0XHR2YXIgZmllbGRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZXR0aW5ncy5lcnJvckNsYXNzKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsaWRhdGUucmVtb3ZlRXJyb3IoZmllbGRzW2ldKTtcblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgYG5vdmFsaWRhdGVgIGZyb20gZm9ybXNcblx0XHRhZGROb1ZhbGlkYXRlKHRydWUpO1xuXG5cdFx0Ly8gUmVzZXQgdmFyaWFibGVzXG5cdFx0c2V0dGluZ3MgPSBudWxsO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgVmFsaWRhdGVcblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBVc2VyIHNldHRpbmdzXG5cdCAqL1xuXHR2YWxpZGF0ZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuXHRcdC8vIGZlYXR1cmUgdGVzdFxuXHRcdGlmICghc3VwcG9ydHMpIHJldHVybjtcblxuXHRcdC8vIERlc3Ryb3kgYW55IGV4aXN0aW5nIGluaXRpYWxpemF0aW9uc1xuXHRcdHZhbGlkYXRlLmRlc3Ryb3koKTtcblxuXHRcdC8vIE1lcmdlIHVzZXIgb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG5cdFx0c2V0dGluZ3MgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG5cdFx0Ly8gQWRkIHRoZSBgbm92YWxpZGF0ZWAgYXR0cmlidXRlIHRvIGFsbCBmb3Jtc1xuXHRcdGFkZE5vVmFsaWRhdGUoKTtcblxuXHRcdC8vIEV2ZW50IGxpc3RlbmVyc1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBibHVySGFuZGxlciwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHN1Ym1pdEhhbmRsZXIsIGZhbHNlKTtcblxuXHR9O1xuXG5cblx0Ly9cblx0Ly8gUHVibGljIEFQSXNcblx0Ly9cblxuXHRyZXR1cm4gdmFsaWRhdGU7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92YWxpZGF0ZS9kaXN0L2pzL3ZhbGlkYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},28:function(t,n,g){g(1),g(2),g(4),t.exports=g(0)},3:function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},4:function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! smooth-scroll v12.1.5 | (c) 2017 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */\n!(function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return t(e)}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof exports?module.exports=t(e):e.SmoothScroll=t(e)})("undefined"!=typeof global?global:"undefined"!=typeof window?window:this,(function(e){"use strict";var t="querySelector"in document&&"addEventListener"in e&&"requestAnimationFrame"in e&&"closest"in e.Element.prototype,n={ignore:"[data-scroll-ignore]",header:null,speed:500,offset:0,easing:"easeInOutCubic",customEasing:null,before:function(){},after:function(){}},o=function(){for(var e={},t=0,n=arguments.length;t<n;t++){var o=arguments[t];!(function(t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(o)}return e},a=function(t){return parseInt(e.getComputedStyle(t).height,10)},r=function(e){"#"===e.charAt(0)&&(e=e.substr(1));for(var t,n=String(e),o=n.length,a=-1,r="",i=n.charCodeAt(0);++a<o;){if(0===(t=n.charCodeAt(a)))throw new InvalidCharacterError("Invalid character: the input contains U+0000.");t>=1&&t<=31||127==t||0===a&&t>=48&&t<=57||1===a&&t>=48&&t<=57&&45===i?r+="\\\\"+t.toString(16)+" ":r+=t>=128||45===t||95===t||t>=48&&t<=57||t>=65&&t<=90||t>=97&&t<=122?n.charAt(a):"\\\\"+n.charAt(a)}return"#"+r},i=function(e,t){var n;return"easeInQuad"===e.easing&&(n=t*t),"easeOutQuad"===e.easing&&(n=t*(2-t)),"easeInOutQuad"===e.easing&&(n=t<.5?2*t*t:(4-2*t)*t-1),"easeInCubic"===e.easing&&(n=t*t*t),"easeOutCubic"===e.easing&&(n=--t*t*t+1),"easeInOutCubic"===e.easing&&(n=t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1),"easeInQuart"===e.easing&&(n=t*t*t*t),"easeOutQuart"===e.easing&&(n=1- --t*t*t*t),"easeInOutQuart"===e.easing&&(n=t<.5?8*t*t*t*t:1-8*--t*t*t*t),"easeInQuint"===e.easing&&(n=t*t*t*t*t),"easeOutQuint"===e.easing&&(n=1+--t*t*t*t*t),"easeInOutQuint"===e.easing&&(n=t<.5?16*t*t*t*t*t:1+16*--t*t*t*t*t),e.customEasing&&(n=e.customEasing(t)),n||t},u=function(){return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight)},c=function(e,t,n){var o=0;if(e.offsetParent)do{o+=e.offsetTop,e=e.offsetParent}while(e);return o=Math.max(o-t-n,0)},s=function(e){return e?a(e)+e.offsetTop:0},l=function(t,n,o){o||(t.focus(),document.activeElement.id!==t.id&&(t.setAttribute("tabindex","-1"),t.focus(),t.style.outline="none"),e.scrollTo(0,n))},f=function(t){return!!("matchMedia"in e&&e.matchMedia("(prefers-reduced-motion)").matches)};return function(a,d){var m,h,g,p,v,b,y,S={};S.cancelScroll=function(){cancelAnimationFrame(y)},S.animateScroll=function(t,a,r){var f=o(m||n,r||{}),d="[object Number]"===Object.prototype.toString.call(t),h=d||!t.tagName?null:t;if(d||h){var g=e.pageYOffset;f.header&&!p&&(p=document.querySelector(f.header)),v||(v=s(p));var b,y,E,I=d?t:c(h,v,parseInt("function"==typeof f.offset?f.offset():f.offset,10)),O=I-g,A=u(),C=0,w=function(n,o){var r=e.pageYOffset;if(n==o||r==o||(g<o&&e.innerHeight+r)>=A)return S.cancelScroll(),l(t,o,d),f.after(t,a),b=null,!0},Q=function(t){b||(b=t),C+=t-b,y=C/parseInt(f.speed,10),y=y>1?1:y,E=g+O*i(f,y),e.scrollTo(0,Math.floor(E)),w(E,I)||(e.requestAnimationFrame(Q),b=t)};0===e.pageYOffset&&e.scrollTo(0,0),f.before(t,a),S.cancelScroll(),e.requestAnimationFrame(Q)}};var E=function(e){h&&(h.id=h.getAttribute("data-scroll-id"),S.animateScroll(h,g),h=null,g=null)},I=function(t){if(!f()&&0===t.button&&!t.metaKey&&!t.ctrlKey&&(g=t.target.closest(a))&&"a"===g.tagName.toLowerCase()&&!t.target.closest(m.ignore)&&g.hostname===e.location.hostname&&g.pathname===e.location.pathname&&/#/.test(g.href)){var n;try{n=r(decodeURIComponent(g.hash))}catch(e){n=r(g.hash)}if("#"===n){t.preventDefault(),h=document.body;var o=h.id?h.id:"smooth-scroll-top";return h.setAttribute("data-scroll-id",o),h.id="",void(e.location.hash.substring(1)===o?E():e.location.hash=o)}h=document.querySelector(n),h&&(h.setAttribute("data-scroll-id",h.id),h.id="",g.hash===e.location.hash&&(t.preventDefault(),E()))}},O=function(e){b||(b=setTimeout((function(){b=null,v=s(p)}),66))};return S.destroy=function(){m&&(document.removeEventListener("click",I,!1),e.removeEventListener("resize",O,!1),S.cancelScroll(),m=null,h=null,g=null,p=null,v=null,b=null,y=null)},S.init=function(a){t&&(S.destroy(),m=o(n,a||{}),p=m.header?document.querySelector(m.header):null,v=s(p),document.addEventListener("click",I,!1),e.addEventListener("hashchange",E,!1),p&&e.addEventListener("resize",O,!1))},S.init(d),S}}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbC9kaXN0L2pzL3Ntb290aC1zY3JvbGwubWluLmpzP2RiNjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjhDQUFBO0FBQ0EsZ0JBQWdCLHVGQUE0RCxZQUFZO0FBQUEsc0tBQW9FLHdGQUF3RixhQUFhLDBIQUEwSCwwSEFBMEgsb0JBQW9CLGNBQWMsWUFBWSx3QkFBd0IsSUFBSSxLQUFLLG1CQUFtQixjQUFjLGdEQUFnRCxLQUFLLFNBQVMsZUFBZSxpREFBaUQsZUFBZSxtQ0FBbUMsNkRBQTZELE1BQU0sRUFBRSw0R0FBNEcsbU1BQW1NLFlBQVksaUJBQWlCLE1BQU0sMm1CQUEybUIsY0FBYyxvTkFBb04sbUJBQW1CLFFBQVEscUJBQXFCLGdDQUFnQyxTQUFTLDJCQUEyQixlQUFlLDRCQUE0QixtQkFBbUIsb0lBQW9JLGVBQWUsOEVBQThFLHFCQUFxQix1QkFBdUIsMEJBQTBCLHdCQUF3QixpQ0FBaUMsa0JBQWtCLGlGQUFpRixTQUFTLG9CQUFvQiwrREFBK0Qsb0hBQW9ILG9CQUFvQixpR0FBaUcsZUFBZSxzSUFBc0ksK0ZBQStGLGtCQUFrQiw4RUFBOEUsZUFBZSwwTkFBME4sTUFBTSxJQUFJLGdDQUFnQyxTQUFTLFlBQVksWUFBWSxtQ0FBbUMsb0NBQW9DLCtHQUErRyxtSUFBbUksZUFBZSw2QkFBNkIsY0FBYyxRQUFRLDRCQUE0Qix1SkFBdUosb0JBQW9CLDJCQUEyQiw4S0FBOEssY0FBYyxHIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc21vb3RoLXNjcm9sbCB2MTIuMS41IHwgKGMpIDIwMTcgQ2hyaXMgRmVyZGluYW5kaSB8IE1JVCBMaWNlbnNlIHwgaHR0cDovL2dpdGh1Yi5jb20vY2ZlcmRpbmFuZGkvc21vb3RoLXNjcm9sbCAqL1xuIShmdW5jdGlvbihlLHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sKGZ1bmN0aW9uKCl7cmV0dXJuIHQoZSl9KSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9dChlKTplLlNtb290aFNjcm9sbD10KGUpfSkoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcywoZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9XCJxdWVyeVNlbGVjdG9yXCJpbiBkb2N1bWVudCYmXCJhZGRFdmVudExpc3RlbmVyXCJpbiBlJiZcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiaW4gZSYmXCJjbG9zZXN0XCJpbiBlLkVsZW1lbnQucHJvdG90eXBlLG49e2lnbm9yZTpcIltkYXRhLXNjcm9sbC1pZ25vcmVdXCIsaGVhZGVyOm51bGwsc3BlZWQ6NTAwLG9mZnNldDowLGVhc2luZzpcImVhc2VJbk91dEN1YmljXCIsY3VzdG9tRWFzaW5nOm51bGwsYmVmb3JlOmZ1bmN0aW9uKCl7fSxhZnRlcjpmdW5jdGlvbigpe319LG89ZnVuY3Rpb24oKXtmb3IodmFyIGU9e30sdD0wLG49YXJndW1lbnRzLmxlbmd0aDt0PG47dCsrKXt2YXIgbz1hcmd1bWVudHNbdF07IShmdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gdCl0Lmhhc093blByb3BlcnR5KG4pJiYoZVtuXT10W25dKX0pKG8pfXJldHVybiBlfSxhPWZ1bmN0aW9uKHQpe3JldHVybiBwYXJzZUludChlLmdldENvbXB1dGVkU3R5bGUodCkuaGVpZ2h0LDEwKX0scj1mdW5jdGlvbihlKXtcIiNcIj09PWUuY2hhckF0KDApJiYoZT1lLnN1YnN0cigxKSk7Zm9yKHZhciB0LG49U3RyaW5nKGUpLG89bi5sZW5ndGgsYT0tMSxyPVwiXCIsaT1uLmNoYXJDb2RlQXQoMCk7KythPG87KXtpZigwPT09KHQ9bi5jaGFyQ29kZUF0KGEpKSl0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXI6IHRoZSBpbnB1dCBjb250YWlucyBVKzAwMDAuXCIpO3Q+PTEmJnQ8PTMxfHwxMjc9PXR8fDA9PT1hJiZ0Pj00OCYmdDw9NTd8fDE9PT1hJiZ0Pj00OCYmdDw9NTcmJjQ1PT09aT9yKz1cIlxcXFxcIit0LnRvU3RyaW5nKDE2KStcIiBcIjpyKz10Pj0xMjh8fDQ1PT09dHx8OTU9PT10fHx0Pj00OCYmdDw9NTd8fHQ+PTY1JiZ0PD05MHx8dD49OTcmJnQ8PTEyMj9uLmNoYXJBdChhKTpcIlxcXFxcIituLmNoYXJBdChhKX1yZXR1cm5cIiNcIityfSxpPWZ1bmN0aW9uKGUsdCl7dmFyIG47cmV0dXJuXCJlYXNlSW5RdWFkXCI9PT1lLmVhc2luZyYmKG49dCp0KSxcImVhc2VPdXRRdWFkXCI9PT1lLmVhc2luZyYmKG49dCooMi10KSksXCJlYXNlSW5PdXRRdWFkXCI9PT1lLmVhc2luZyYmKG49dDwuNT8yKnQqdDooNC0yKnQpKnQtMSksXCJlYXNlSW5DdWJpY1wiPT09ZS5lYXNpbmcmJihuPXQqdCp0KSxcImVhc2VPdXRDdWJpY1wiPT09ZS5lYXNpbmcmJihuPS0tdCp0KnQrMSksXCJlYXNlSW5PdXRDdWJpY1wiPT09ZS5lYXNpbmcmJihuPXQ8LjU/NCp0KnQqdDoodC0xKSooMip0LTIpKigyKnQtMikrMSksXCJlYXNlSW5RdWFydFwiPT09ZS5lYXNpbmcmJihuPXQqdCp0KnQpLFwiZWFzZU91dFF1YXJ0XCI9PT1lLmVhc2luZyYmKG49MS0gLS10KnQqdCp0KSxcImVhc2VJbk91dFF1YXJ0XCI9PT1lLmVhc2luZyYmKG49dDwuNT84KnQqdCp0KnQ6MS04Ki0tdCp0KnQqdCksXCJlYXNlSW5RdWludFwiPT09ZS5lYXNpbmcmJihuPXQqdCp0KnQqdCksXCJlYXNlT3V0UXVpbnRcIj09PWUuZWFzaW5nJiYobj0xKy0tdCp0KnQqdCp0KSxcImVhc2VJbk91dFF1aW50XCI9PT1lLmVhc2luZyYmKG49dDwuNT8xNip0KnQqdCp0KnQ6MSsxNiotLXQqdCp0KnQqdCksZS5jdXN0b21FYXNpbmcmJihuPWUuY3VzdG9tRWFzaW5nKHQpKSxufHx0fSx1PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCxkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KX0sYz1mdW5jdGlvbihlLHQsbil7dmFyIG89MDtpZihlLm9mZnNldFBhcmVudClkb3tvKz1lLm9mZnNldFRvcCxlPWUub2Zmc2V0UGFyZW50fXdoaWxlKGUpO3JldHVybiBvPU1hdGgubWF4KG8tdC1uLDApfSxzPWZ1bmN0aW9uKGUpe3JldHVybiBlP2EoZSkrZS5vZmZzZXRUb3A6MH0sbD1mdW5jdGlvbih0LG4sbyl7b3x8KHQuZm9jdXMoKSxkb2N1bWVudC5hY3RpdmVFbGVtZW50LmlkIT09dC5pZCYmKHQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIi0xXCIpLHQuZm9jdXMoKSx0LnN0eWxlLm91dGxpbmU9XCJub25lXCIpLGUuc2Nyb2xsVG8oMCxuKSl9LGY9ZnVuY3Rpb24odCl7cmV0dXJuISEoXCJtYXRjaE1lZGlhXCJpbiBlJiZlLm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIikubWF0Y2hlcyl9O3JldHVybiBmdW5jdGlvbihhLGQpe3ZhciBtLGgsZyxwLHYsYix5LFM9e307Uy5jYW5jZWxTY3JvbGw9ZnVuY3Rpb24oKXtjYW5jZWxBbmltYXRpb25GcmFtZSh5KX0sUy5hbmltYXRlU2Nyb2xsPWZ1bmN0aW9uKHQsYSxyKXt2YXIgZj1vKG18fG4scnx8e30pLGQ9XCJbb2JqZWN0IE51bWJlcl1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxoPWR8fCF0LnRhZ05hbWU/bnVsbDp0O2lmKGR8fGgpe3ZhciBnPWUucGFnZVlPZmZzZXQ7Zi5oZWFkZXImJiFwJiYocD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGYuaGVhZGVyKSksdnx8KHY9cyhwKSk7dmFyIGIseSxFLEk9ZD90OmMoaCx2LHBhcnNlSW50KFwiZnVuY3Rpb25cIj09dHlwZW9mIGYub2Zmc2V0P2Yub2Zmc2V0KCk6Zi5vZmZzZXQsMTApKSxPPUktZyxBPXUoKSxDPTAsdz1mdW5jdGlvbihuLG8pe3ZhciByPWUucGFnZVlPZmZzZXQ7aWYobj09b3x8cj09b3x8KGc8byYmZS5pbm5lckhlaWdodCtyKT49QSlyZXR1cm4gUy5jYW5jZWxTY3JvbGwoKSxsKHQsbyxkKSxmLmFmdGVyKHQsYSksYj1udWxsLCEwfSxRPWZ1bmN0aW9uKHQpe2J8fChiPXQpLEMrPXQtYix5PUMvcGFyc2VJbnQoZi5zcGVlZCwxMCkseT15PjE/MTp5LEU9ZytPKmkoZix5KSxlLnNjcm9sbFRvKDAsTWF0aC5mbG9vcihFKSksdyhFLEkpfHwoZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoUSksYj10KX07MD09PWUucGFnZVlPZmZzZXQmJmUuc2Nyb2xsVG8oMCwwKSxmLmJlZm9yZSh0LGEpLFMuY2FuY2VsU2Nyb2xsKCksZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoUSl9fTt2YXIgRT1mdW5jdGlvbihlKXtoJiYoaC5pZD1oLmdldEF0dHJpYnV0ZShcImRhdGEtc2Nyb2xsLWlkXCIpLFMuYW5pbWF0ZVNjcm9sbChoLGcpLGg9bnVsbCxnPW51bGwpfSxJPWZ1bmN0aW9uKHQpe2lmKCFmKCkmJjA9PT10LmJ1dHRvbiYmIXQubWV0YUtleSYmIXQuY3RybEtleSYmKGc9dC50YXJnZXQuY2xvc2VzdChhKSkmJlwiYVwiPT09Zy50YWdOYW1lLnRvTG93ZXJDYXNlKCkmJiF0LnRhcmdldC5jbG9zZXN0KG0uaWdub3JlKSYmZy5ob3N0bmFtZT09PWUubG9jYXRpb24uaG9zdG5hbWUmJmcucGF0aG5hbWU9PT1lLmxvY2F0aW9uLnBhdGhuYW1lJiYvIy8udGVzdChnLmhyZWYpKXt2YXIgbjt0cnl7bj1yKGRlY29kZVVSSUNvbXBvbmVudChnLmhhc2gpKX1jYXRjaChlKXtuPXIoZy5oYXNoKX1pZihcIiNcIj09PW4pe3QucHJldmVudERlZmF1bHQoKSxoPWRvY3VtZW50LmJvZHk7dmFyIG89aC5pZD9oLmlkOlwic21vb3RoLXNjcm9sbC10b3BcIjtyZXR1cm4gaC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXNjcm9sbC1pZFwiLG8pLGguaWQ9XCJcIix2b2lkKGUubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSk9PT1vP0UoKTplLmxvY2F0aW9uLmhhc2g9byl9aD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKG4pLGgmJihoLnNldEF0dHJpYnV0ZShcImRhdGEtc2Nyb2xsLWlkXCIsaC5pZCksaC5pZD1cIlwiLGcuaGFzaD09PWUubG9jYXRpb24uaGFzaCYmKHQucHJldmVudERlZmF1bHQoKSxFKCkpKX19LE89ZnVuY3Rpb24oZSl7Ynx8KGI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtiPW51bGwsdj1zKHApfSksNjYpKX07cmV0dXJuIFMuZGVzdHJveT1mdW5jdGlvbigpe20mJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixJLCExKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixPLCExKSxTLmNhbmNlbFNjcm9sbCgpLG09bnVsbCxoPW51bGwsZz1udWxsLHA9bnVsbCx2PW51bGwsYj1udWxsLHk9bnVsbCl9LFMuaW5pdD1mdW5jdGlvbihhKXt0JiYoUy5kZXN0cm95KCksbT1vKG4sYXx8e30pLHA9bS5oZWFkZXI/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihtLmhlYWRlcik6bnVsbCx2PXMocCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsSSwhMSksZS5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLEUsITEpLHAmJmUuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLE8sITEpKX0sUy5pbml0KGQpLFN9fSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGwvZGlzdC9qcy9zbW9vdGgtc2Nyb2xsLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')}});