!function(t){var n=window.webpackJsonp;window.webpackJsonp=function(e,g,l){for(var I,a,i,b=0,d=[];b<e.length;b++)a=e[b],c[a]&&d.push(c[a][0]),c[a]=0;for(I in g)Object.prototype.hasOwnProperty.call(g,I)&&(t[I]=g[I]);for(n&&n(e,g,l);d.length;)d.shift()();if(l)for(b=0;b<l.length;b++)i=B(B.s=l[b]);return i};var e={},c={2:0};function B(n){if(e[n])return e[n].exports;var c=e[n]={i:n,l:!1,exports:{}};return t[n].call(c.exports,c,c.exports,B),c.l=!0,c.exports}B.e=function(t){var n=c[t];if(0===n)return new Promise(function(t){t()});if(n)return n[2];var e=new Promise(function(e,B){n=c[t]=[e,B]});n[2]=e;var g=document.getElementsByTagName("head")[0],l=document.createElement("script");l.type="text/javascript",l.charset="utf-8",l.async=!0,l.timeout=12e4,B.nc&&l.setAttribute("nonce",B.nc),l.src=B.p+"js/"+t+".js";var I=setTimeout(a,12e4);function a(){l.onerror=l.onload=null,clearTimeout(I);var n=c[t];0!==n&&(n&&n[1](new Error("Loading chunk "+t+" failed.")),c[t]=void 0)}return l.onerror=l.onload=a,g.appendChild(l),e},B.m=t,B.c=e,B.d=function(t,n,e){B.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:e})},B.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return B.d(n,"a",n),n},B.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},B.p="/",B.oe=function(t){throw console.error(t),t},B(B.s=25)}({0:function(module,exports,__webpack_require__){eval("/* Riot v3.9.0, @license MIT */\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.riot = {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\nvar\n  // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n  // tags instances cache\n  __TAGS_CACHE = [],\n  // tags implementation cache\n  __TAG_IMPL = {},\n  YIELD_TAG = 'yield',\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n\n  // riot specific prefixes or attributes\n  ATTRS_PREFIX = 'riot-',\n\n  // Riot Directives\n  REF_DIRECTIVES = ['ref', 'data-ref'],\n  IS_DIRECTIVE = 'data-is',\n  CONDITIONAL_DIRECTIVE = 'if',\n  LOOP_DIRECTIVE = 'each',\n  LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n  SHOW_DIRECTIVE = 'show',\n  HIDE_DIRECTIVE = 'hide',\n  KEY_DIRECTIVE = 'key',\n  RIOT_EVENTS_KEY = '__riot-events__',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n\n  XLINK_NS = 'http://www.w3.org/1999/xlink',\n  SVG_NS = 'http://www.w3.org/2000/svg',\n  XLINK_REGEX = /^xlink:(\\w+)/,\n\n  WIN = typeof window === T_UNDEF ? undefined : window,\n\n  // special native tags that cannot be treated like the others\n  RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n  RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n  RE_EVENTS_PREFIX = /^on/,\n  RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n  // some DOM attributes must be normalized\n  CASE_SENSITIVE_ATTRIBUTES = {\n    'viewbox': 'viewBox',\n    'preserveaspectratio': 'preserveAspectRatio'\n  },\n  /**\n   * Matches boolean HTML attributes in the riot tag definition.\n   * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n   * @const {RegExp}\n   * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n   */\n  RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @returns { Object } DOM node just created\n */\nfunction makeElement(name) {\n  return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttribute(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\nvar styleNode;\n// Create cache and shortcut to the correct property\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\nvar needsInject = false;\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = ((function () {\n    // create a new style element with the correct type\n    var newNode = makeElement('style');\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n\n    setAttribute(newNode, 'type', 'text/css');\n    /* istanbul ignore next */\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    } else { document.head.appendChild(newNode); }\n\n    return newNode\n  }))();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n    needsInject = true;\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN || !needsInject) { return }\n    needsInject = false;\n    var style = Object.keys(byName)\n      .map(function (k) { return byName[k]; })\n      .concat(remainder).join('\\n');\n    /* istanbul ignore next */\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n}\n\n/**\n * The riot template engine\n * @version v3.0.8\n */\n\nvar skipRegex = (function () { //eslint-disable-line no-unused-vars\n\n  var beforeReChars = '[{(,;:?=|&!^~>%*/';\n\n  var beforeReWords = [\n    'case',\n    'default',\n    'do',\n    'else',\n    'in',\n    'instanceof',\n    'prefix',\n    'return',\n    'typeof',\n    'void',\n    'yield'\n  ];\n\n  var wordsLastChar = beforeReWords.reduce(function (s, w) {\n    return s + w.slice(-1)\n  }, '');\n\n  var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n  var RE_VN_CHAR = /[$\\w]/;\n\n  function prev (code, pos) {\n    while (--pos >= 0 && /\\s/.test(code[pos])){ }\n    return pos\n  }\n\n  function _skipRegex (code, start) {\n\n    var re = /.*/g;\n    var pos = re.lastIndex = start++;\n    var match = re.exec(code)[0].match(RE_REGEX);\n\n    if (match) {\n      var next = pos + match[0].length;\n\n      pos = prev(code, pos);\n      var c = code[pos];\n\n      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n        return next\n      }\n\n      if (c === '.') {\n\n        if (code[pos - 1] === '.') {\n          start = next;\n        }\n\n      } else if (c === '+' || c === '-') {\n\n        if (code[--pos] !== c ||\n            (pos = prev(code, pos)) < 0 ||\n            !RE_VN_CHAR.test(code[pos])) {\n          start = next;\n        }\n\n      } else if (~wordsLastChar.indexOf(c)) {\n\n        var end = pos + 1;\n\n        while (--pos >= 0 && RE_VN_CHAR.test(code[pos])){ }\n        if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n          start = next;\n        }\n      }\n    }\n\n    return start\n  }\n\n  return _skipRegex\n\n})();\n\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\n/* istanbul ignore next */\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCK2, REGLOB)\n    },\n\n    DEFAULT = '{ }';;;;;;;;;\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;;;;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];;;;;;\n\n    var qblocks = [];\n    var prevStr = '';\n    var mark, lastIndex;;\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      lastIndex = re.lastIndex;\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n\n          var ch = match[2];\n          var rech = FINDBRACES[ch];\n          var ix = 1;\n\n          rech.lastIndex = lastIndex;\n          while ((match = rech.exec(str))) {\n            if (match[1]) {\n              if (match[1] === ch) { ++ix; }\n              else if (!--ix) { break }\n            } else {\n              rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n            }\n          }\n          re.lastIndex = ix ? str.length : rech.lastIndex;\n          continue\n        }\n\n        if (!match[3]) {\n          re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    parts.qblocks = qblocks;\n\n    return parts\n\n    function unescapeStr (s) {\n      if (prevStr) {\n        s = prevStr + s;\n        prevStr = '';\n      }\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function pushQBlock(_pos, _lastIndex, slash) { //eslint-disable-line\n      if (slash) {\n        _lastIndex = skipRegex(str, _pos);\n      }\n\n      if (tmpl && _lastIndex > _pos + 2) {\n        mark = '\\u2057' + qblocks.length + '~';\n        qblocks.push(str.slice(_pos, _lastIndex));\n        prevStr += str.slice(start, _pos) + mark;\n        start = _lastIndex;\n      }\n      return _lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n  _brackets.skipRegex = skipRegex;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n  _brackets.S_QBLOCK2 = S_QBLOCK2;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\n/* istanbul ignore next */\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(\n      data, _logErr.bind({\n        data: data,\n        tmpl: str\n      })\n    )\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.__ && ctx.__.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n    else if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      console.error(err.message);\n      console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n      console.log(this.data); // eslint-disable-line\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var RE_DQUOTE = /\\u2057/g;\n  var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n    var qstr = parts.qblocks;\n    var expr;\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];;;\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr.length) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n      .replace(/\\s+/g, ' ').trim()\n      .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;;;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;;;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];;;\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;;;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.8';\n\n  return _tmpl\n\n})();\n\n/* istanbul ignore next */\nvar observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;;;;;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\n/**\n * Short alias for Object.getOwnPropertyDescriptor\n */\nfunction getPropDescriptor (o, k) {\n  return Object.getOwnPropertyDescriptor(o, k)\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } true if writable\n */\nfunction isWritable(obj, key) {\n  var descriptor = getPropDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj;\n  var i = 1;\n  var args = arguments;\n  var l = args.length;\n\n  for (; i < l; i++) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\n/**\n * Alias for Object.create\n */\nfunction create(src) {\n  return Object.create(src)\n}\n\nvar settings = extend(create(brackets.settings), {\n  skipAnonymousTags: true,\n  // handle the auto updates on any DOM event\n  autoUpdate: true\n})\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return [].slice.call((ctx || document).querySelectorAll(selector))\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Toggle the visibility of any DOM node\n * @param   { Object }  dom - DOM node we want to hide\n * @param   { Boolean } show - do we want to show it?\n */\n\nfunction toggleVisibility(dom, show) {\n  dom.style.display = show ? '' : 'none';\n  dom.hidden = show ? false : true;\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttribute(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction removeAttribute(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n * @param { Boolean } isSvg - svg tags should be treated a bit differently\n */\n/* istanbul ignore next */\nfunction setInnerHTML(container, html, isSvg) {\n  // innerHTML is not supported on svg tags so we neet to treat them differently\n  if (isSvg) {\n    var node = container.ownerDocument.importNode(\n      new DOMParser()\n        .parseFromString((\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\"), 'application/xml')\n        .documentElement,\n      true\n    );\n\n    container.appendChild(node);\n  } else {\n    container.innerHTML = html;\n  }\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttributes(html, fn) {\n  if (!html) { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFragment() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Convert a style object to a string\n * @param   { Object } style - style object we need to parse\n * @returns { String } resulting css string\n * @example\n * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n */\nfunction styleObjectToString(style) {\n  return Object.keys(style).reduce(function (acc, prop) {\n    return (acc + \" \" + prop + \": \" + (style[prop]) + \";\")\n  }, '')\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\n\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: makeElement,\n\tsetAttr: setAttribute,\n\ttoggleVisibility: toggleVisibility,\n\tgetAttr: getAttribute,\n\tremAttr: removeAttribute,\n\tsetInnerHTML: setInnerHTML,\n\twalkAttrs: walkAttributes,\n\tcreateFrag: createFragment,\n\tsafeInsert: safeInsert,\n\tstyleObjectToString: styleObjectToString,\n\twalkNodes: walkNodes\n});\n\n/**\n * Check against the null and undefined values\n * @param   { * }  value -\n * @returns {Boolean} -\n */\nfunction isNil(value) {\n  return isUndefined(value) || value === null\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isNil(value) || value === ''\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if a DOM node is an svg tag or part of an svg\n * @param   { HTMLElement }  el - node we want to test\n * @returns {Boolean} true if it's an svg node\n */\nfunction isSvg(el) {\n  var owner = el.ownerSVGElement;\n  return !!owner || owner === null\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check if the passed argument is a boolean attribute\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n\n\nvar check = Object.freeze({\n\tisBlank: isBlank,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisSvg: isSvg,\n\tisWritable: isWritable,\n\tisArray: isArray,\n\tisBoolAttr: isBoolAttr,\n\tisNil: isNil,\n\tisString: isString,\n\tisUndefined: isUndefined\n});\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1\n}\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n  var i = 0;\n  for (; i < len; i++) { fn(list[i], i); }\n  return list\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Function returning always a unique identifier\n * @returns { Number } - number from 0...n\n */\nvar uid = (function uid() {\n  var i = -1;\n  return function () { return ++i; }\n})()\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction define(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Warn a message via console\n * @param   {String} message - warning message\n */\nfunction warn(message) {\n  if (console && console.warn) { console.warn(message); }\n}\n\n\n\nvar misc = Object.freeze({\n\tcontains: contains,\n\teach: each,\n\tgetPropDescriptor: getPropDescriptor,\n\tstartsWith: startsWith,\n\tuid: uid,\n\tdefineProperty: define,\n\tobjectCreate: create,\n\textend: extend,\n\ttoCamel: toCamel,\n\twarn: warn\n});\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n * @param { Number } index - add the new item in a certain array position\n */\nfunction arrayishAdd(obj, key, value, ensureArray, index) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n  var hasIndex = !isUndefined(index);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else {\n    if (isArr) {\n      var oldIndex = dest.indexOf(value);\n      // this item never changed its position\n      if (oldIndex === index) { return }\n      // remove the item from its old position\n      if (oldIndex !== -1) { dest.splice(oldIndex, 1); }\n      // move or add the item\n      if (hasIndex) {\n        dest.splice(index, 0, value);\n      } else {\n        dest.push(value);\n      }\n    } else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction get(dom) {\n  return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) ||\n    getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getName(dom, skipDataIs) {\n  var child = get(dom);\n  var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n    namedTag : child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * Return a temporary context containing also the parent properties\n * @this Tag\n * @param { Tag } - temporary tag context containing all the parent properties\n */\nfunction inheritParentProps() {\n  if (this.parent) { return extend(create(this), this.parent) }\n  return this\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar\n  reHasYield  = /<yield\\b/i,\n  reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n  reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n  reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n  rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' },\n  tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n  GENERIC = 'div',\n  SVG = 'svg';;;;;;;;\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';;\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  /* istanbul ignore next */\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } isSvg - true if the root node is an svg\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, isSvg) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n  var  tagName = match && match[1].toLowerCase();\n  var el = makeElement(isSvg ? SVG : GENERIC);\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl, isSvg); }\n\n  return el\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParent(tag) {\n  var ptag = tag;\n  while (ptag.__.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this.__.parent;\n  var item = this.__.item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag.__.item;\n      ptag = ptag.__.parent;\n    } }\n\n  // override the event properties\n  /* istanbul ignore next */\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  /* istanbul ignore next */\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  // avoid auto updates\n  if (!settings.autoUpdate) { return }\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParent(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName;\n  var cb = handleEvent.bind(tag, dom, handler);\n\n  // avoid to bind twice the same event\n  // possible fix for #2332\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(RE_EVENTS_PREFIX, '');\n\n  // cache the listener into the listeners array\n  if (!contains(tag.__.listeners, dom)) { tag.__.listeners.push(dom); }\n  if (!dom[RIOT_EVENTS_KEY]) { dom[RIOT_EVENTS_KEY] = {}; }\n  if (dom[RIOT_EVENTS_KEY][name]) { dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]); }\n\n  dom[RIOT_EVENTS_KEY][name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChild(child, opts, innerHTML, parent) {\n  var tag = createTag(child, opts, innerHTML);\n  var tagName = opts.tagName || getName(opts.root, true);\n  var ptag = getImmediateCustomParent(parent);\n  // fix for the parent attribute in the looped elements\n  define(tag, 'parent', ptag);\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag.__.parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  return tag\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    var index = obj[key].indexOf(value);\n    if (index !== -1) { obj[key].splice(index, 1); }\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else if (obj[key] === value)\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder();\n  var tail = createDOMPlaceholder();\n  var frag = createFragment();\n  var sib;\n  var el;\n\n  this.root.insertBefore(head, this.root.firstChild);\n  this.root.appendChild(tail);\n\n  this.__.head = el = head;\n  this.__.tail = tail;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1.__.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target.__.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * makes a tag virtual and replaces a reference in the dom\n * @this Tag\n * @param { tag } the tag to make virtual\n * @param { ref } the dom reference location\n */\nfunction makeReplaceVirtual(tag, ref) {\n  var frag = createFragment();\n  makeVirtual.call(tag, frag);\n  ref.parentNode.replaceChild(frag, ref);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag }    parent - parent for tag creation\n * @param { String } tagName - tag implementation we want to use\n */\nfunction updateDataIs(expr, parent, tagName) {\n  var tag = expr.tag || expr.dom._tag;\n  var ref;\n\n  var ref$1 = tag ? tag.__ : {};\n  var head = ref$1.head;\n  var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n  if (tag && expr.tagName === tagName) {\n    tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (tag) {\n    // need placeholder before unmount\n    if(isVirtual) {\n      ref = createDOMPlaceholder();\n      head.parentNode.insertBefore(ref, head);\n    }\n\n    tag.unmount(true);\n  }\n\n  // unable to get the tag name\n  if (!isString(tagName)) { return }\n\n  expr.impl = __TAG_IMPL[tagName];\n\n  // unknown implementation\n  if (!expr.impl) { return }\n\n  expr.tag = tag = initChild(\n    expr.impl, {\n      root: expr.dom,\n      parent: parent,\n      tagName: tagName\n    },\n    expr.dom.innerHTML,\n    parent\n  );\n\n  each(expr.attrs, function (a) { return setAttribute(tag.root, a.name, a.value); });\n  expr.tagName = tagName;\n  tag.mount();\n\n  // root exist first time, after use placeholder\n  if (isVirtual) { makeReplaceVirtual(tag, ref || tag.root); }\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.__.onUnmount = function () {\n    var delName = tag.opts.dataIs;\n    arrayishRemove(tag.parent.tags, delName, tag);\n    arrayishRemove(tag.__.parent.tags, delName, tag);\n    tag.unmount();\n  };\n}\n\n/**\n * Nomalize any attribute removing the \"riot-\" prefix\n * @param   { String } attrName - original attribute name\n * @returns { String } valid html attribute name\n */\nfunction normalizeAttrName(attrName) {\n  if (!attrName) { return null }\n  attrName = attrName.replace(ATTRS_PREFIX, '');\n  if (CASE_SENSITIVE_ATTRIBUTES[attrName]) { attrName = CASE_SENSITIVE_ATTRIBUTES[attrName]; }\n  return attrName\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  if (this.root && getAttribute(this.root,'virtualized')) { return }\n\n  var dom = expr.dom;\n  // remove the riot- prefix\n  var attrName = normalizeAttrName(expr.attr);\n  var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n  var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n  var ref = this.__;\n  var isAnonymous = ref.isAnonymous;\n  var parent = dom && (expr.parent || dom.parentNode);\n  // detect the style attributes\n  var isStyleAttr = attrName === 'style';\n  var isClassAttr = attrName === 'class';\n\n  var value;\n\n  // if it's a tag we could totally skip the rest\n  if (expr._riot_id) {\n    if (expr.__.wasCreated) {\n      expr.update();\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n      if (isVirtual) {\n        makeReplaceVirtual(expr, expr.root);\n      }\n    }\n    return\n  }\n\n  // if this expression has the update method it means it can handle the DOM changes by itself\n  if (expr.update) { return expr.update() }\n\n  var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this;\n\n  // ...it seems to be a simple expression so we try to calculate its value\n  value = tmpl(expr.expr, context);\n\n  var hasValue = !isBlank(value);\n  var isObj = isObject(value);\n\n  // convert the style/class objects to strings\n  if (isObj) {\n    if (isClassAttr) {\n      value = tmpl(JSON.stringify(value), this);\n    } else if (isStyleAttr) {\n      value = styleObjectToString(value);\n    }\n  }\n\n  // remove original attribute\n  if (expr.attr && (!expr.wasParsedOnce || !hasValue || value === false)) {\n    // remove either riot-* attributes or just the attribute name\n    removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n  }\n\n  // for the boolean attributes we don't need the value\n  // we can convert it to checked=true to checked=checked\n  if (expr.bool) { value = value ? attrName : false; }\n  if (expr.isRtag) { return updateDataIs(expr, this, value) }\n  if (expr.wasParsedOnce && expr.value === value) { return }\n\n  // update the expression value\n  expr.value = value;\n  expr.wasParsedOnce = true;\n\n  // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n  if (isObj && !isClassAttr && !isStyleAttr && !isToggle) { return }\n  // avoid to render undefined/null values\n  if (!hasValue) { value = ''; }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (isToggle) {\n    toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n  // handle attributes\n  } else {\n    if (expr.bool) {\n      dom[attrName] = value;\n    }\n\n    if (attrName === 'value' && dom.value !== value) {\n      dom.value = value;\n    } else if (hasValue && value !== false) {\n      setAttribute(dom, attrName, value);\n    }\n\n    // make sure that in case of style changes\n    // the element stays hidden\n    if (isStyleAttr && dom.hidden) { toggleVisibility(dom, false); }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction update(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n  var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n\n  each(instAttrs, function (attr) {\n    if (attr.expr) { updateExpression.call(ctx, attr.expr); }\n    // normalize the attribute names\n    opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n/**\n * Update the tag expressions and options\n * @param { Tag } tag - tag object\n * @param { * } data - data we want to use to extend the tag properties\n * @param { Array } expressions - component expressions array\n * @returns { Tag } the current tag instance\n */\nfunction componentUpdate(tag, data, expressions) {\n  var __ = tag.__;\n  var nextOpts = {};\n  var canTrigger = tag.isMounted && !__.skipAnonymous;\n\n  // inherit properties from the parent tag\n  if (__.isAnonymous && __.parent) { extend(tag, __.parent); }\n  extend(tag, data);\n\n  updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n  if (\n    canTrigger &&\n    tag.isMounted &&\n    isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)\n  ) {\n    return tag\n  }\n\n  extend(tag.opts, nextOpts);\n\n  if (canTrigger) { tag.trigger('update', data); }\n  update.call(tag, expressions);\n  if (canTrigger) { tag.trigger('updated'); }\n\n  return tag\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction query(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + query(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mount$1(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2(name, tmpl, css, attrs, fn) {\n  if (css) { styleManager.add(css, name); }\n\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount(selector, tagName, opts) {\n  var tags = [];\n  var elem, allTags;;\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttribute(root, IS_DIRECTIVE), tag;;\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttribute(root, IS_DIRECTIVE, tagName);\n      }\n\n      tag = mount$1(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag)\n        { tags.push(tag); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = query() :\n      // or just the ones named like the selector\n      selector + query(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || query();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar mixins_id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin((\"__\" + (mixins_id++) + \"__\"), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error((\"Unregistered mixin: \" + name)) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$1() {\n  return each(__TAGS_CACHE, function (tag) { return tag.update(); })\n}\n\nfunction unregister(name) {\n  __TAG_IMPL[name] = null;\n}\n\nvar version = 'v3.9.0';\n\n\nvar core = Object.freeze({\n\tTag: Tag,\n\ttag: tag,\n\ttag2: tag2,\n\tmount: mount,\n\tmixin: mixin,\n\tupdate: update$1,\n\tunregister: unregister,\n\tversion: version\n});\n\n/**\n * Add a mixin to this tag\n * @returns { Tag } the current tag instance\n */\nfunction componentMixin(tag$$1) {\n  var mixins = [], len = arguments.length - 1;\n  while ( len-- > 0 ) mixins[ len ] = arguments[ len + 1 ];\n\n  each(mixins, function (mix) {\n    var instance;\n    var obj;\n    var props = [];\n\n    // properties blacklisted and will not be bound to the tag instance\n    var propsBlacklist = ['init', '__proto__'];\n\n    mix = isString(mix) ? mixin(mix) : mix;\n\n    // check if the mixin is a function\n    if (isFunction(mix)) {\n      // create the new mixin instance\n      instance = new mix();\n    } else { instance = mix; }\n\n    var proto = Object.getPrototypeOf(instance);\n\n    // build multilevel prototype inheritance chain property list\n    do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n    while (obj = Object.getPrototypeOf(obj || instance))\n\n    // loop the keys in the function prototype or the all object keys\n    each(props, function (key) {\n      // bind methods to tag\n      // allow mixins to override other properties/parent mixins\n      if (!contains(propsBlacklist, key)) {\n        // check for getters/setters\n        var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n        var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n        // apply method only if it does not already exist on the instance\n        if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n          Object.defineProperty(tag$$1, key, descriptor);\n        } else {\n          tag$$1[key] = isFunction(instance[key]) ?\n            instance[key].bind(tag$$1) :\n            instance[key];\n        }\n      }\n    });\n\n    // init method will be called automatically\n    if (instance.init)\n      { instance.init.bind(tag$$1)(tag$$1.opts); }\n  });\n\n  return tag$$1\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChild(tagName, newPos) {\n  var parent = this.parent;\n  var tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this.__.head;\n  var sib;\n  var frag = createFragment();\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1.__.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target.__.head);\n      break\n    }\n  }\n}\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n */\nfunction unmountRedundant(items, tags) {\n  var i = tags.length;\n  var j = items.length;\n\n  while (i > j) {\n    i--;\n    remove.apply(tags[i], [tags, i]);\n  }\n}\n\n\n/**\n * Remove a child tag\n * @this Tag\n * @param   { Array } tags - tags collection\n * @param   { Number } i - index of the tag to remove\n */\nfunction remove(tags, i) {\n  tags.splice(i, 1);\n  this.unmount();\n  arrayishRemove(this.parent, this, this.__.tagName, true);\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    moveChild.apply(this$1.tags[tagName], [tagName, i]);\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Return the value we want to use to lookup the postion of our items in the collection\n * @param   { String }  keyAttr         - lookup string or expression\n * @param   { * }       originalItem    - original item from the collection\n * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n * @returns { * } value that we will use to figure out the item position via collection.indexOf\n */\nfunction getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n  if (keyAttr) {\n    return hasKeyAttrExpr ?  tmpl(keyAttr, keyedItem) :  originalItem[keyAttr]\n  }\n\n  return originalItem\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n  var mustReorder = typeof getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n  var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n  var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n  var tagName = getName(dom);\n  var impl = __TAG_IMPL[tagName];\n  var parentNode = dom.parentNode;\n  var placeholder = createDOMPlaceholder();\n  var child = get(dom);\n  var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n  var tags = [];\n  var isLoop = true;\n  var innerHTML = dom.innerHTML;\n  var isAnonymous = !__TAG_IMPL[tagName];\n  var isVirtual = dom.tagName === 'VIRTUAL';\n  var oldItems = [];\n  var hasKeys;\n\n  // remove the each property from the original tag\n  removeAttribute(dom, LOOP_DIRECTIVE);\n  removeAttribute(dom, KEY_DIRECTIVE);\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { removeAttribute(dom, CONDITIONAL_DIRECTIVE); }\n\n  // insert a marked where the loop tags will be injected\n  parentNode.insertBefore(placeholder, dom);\n  parentNode.removeChild(dom);\n\n  expr.update = function updateEach() {\n    // get the new items collection\n    expr.value = tmpl(expr.val, parent);\n\n    var items = expr.value;\n    var frag = createFragment();\n    var isObject = !isArray(items) && !isString(items);\n    var root = placeholder.parentNode;\n    var tmpItems = [];\n\n    // if this DOM was removed the update here is useless\n    // this condition fixes also a weird async issue on IE in our unit test\n    if (!root) { return }\n\n    // object loop. any changes cause full redraw\n    if (isObject) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) { return mkitem(expr, items[key], key); }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function (item, i) {\n        if (expr.key && !isObject)\n          { return !!tmpl(ifExpr, mkitem(expr, item, i, parent)) }\n\n        return !!tmpl(ifExpr, extend(create(parent), item))\n      });\n    }\n\n    // loop all the new items\n    each(items, function (_item, i) {\n      var item = !hasKeys && expr.key ? mkitem(expr, _item, i) : _item;\n      var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr);\n      // reorder only if the items are objects\n      var doReorder = mustReorder && typeof _item === T_OBJECT && !hasKeys;\n      var oldPos = oldItems.indexOf(itemId);\n      var isNew = oldPos === -1;\n      var pos = !isNew && doReorder ? oldPos : i;\n      // does a tag exist in this position?\n      var tag = tags[pos];\n      var mustAppend = i >= oldItems.length;\n      var mustCreate =  doReorder && isNew || !doReorder && !tag;\n\n      // new tag\n      if (mustCreate) {\n        tag = createTag(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          tagName: tagName,\n          root: dom.cloneNode(isAnonymous),\n          item: item,\n          index: i,\n        }, innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n      } else if (pos !== i && doReorder) {\n        // move\n        if (keyAttr || contains(items, oldItems[pos])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n          // move the old tag instance\n          tags.splice(i, 0, tags.splice(pos, 1)[0]);\n          // move the old item\n          oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        }\n\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      extend(tag.__, {\n        item: item,\n        index: i,\n        parent: parent\n      });\n\n      tmpItems[i] = itemId;\n\n      if (!mustCreate) { tag.update(item); }\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags);\n\n    // clone the items array\n    oldItems = tmpItems.slice();\n\n    root.insertBefore(frag, placeholder);\n  };\n\n  expr.unmount = function () {\n    each(tags, function (t) { t.unmount(); });\n  };\n\n  return expr\n}\n\nvar RefExpr = {\n  init: function init(dom, parent, attrName, attrValue) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    return this\n  },\n  update: function update() {\n    var old = this.value;\n    var customParent = this.parent && getImmediateCustomParent(this.parent);\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.dom.__ref || this.tag || this.dom;\n\n    this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(old) && customParent) { arrayishRemove(customParent.refs, old, tagOrDom); }\n    if (!isBlank(this.value) && isString(this.value)) {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(\n        customParent.refs,\n        this.value,\n        tagOrDom,\n        // use an array if it's a looped node and the ref is not an expression\n        null,\n        this.parent.__.index\n      ); }\n\n      if (this.value !== old) {\n        setAttribute(this.dom, this.attr, this.value);\n      }\n    } else {\n      removeAttribute(this.dom, this.attr);\n    }\n\n    // cache the ref bound to this dom node\n    // to reuse it in future (see also #2329)\n    if (!this.dom.__ref) { this.dom.__ref = tagOrDom; }\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParent(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n  }\n}\n\n/**\n * Create a new ref directive\n * @param   { HTMLElement } dom - dom node having the ref attribute\n * @param   { Tag } context - tag instance where the DOM node is located\n * @param   { String } attrName - either 'ref' or 'data-ref'\n * @param   { String } attrValue - value of the ref attribute\n * @returns { RefExpr } a new RefExpr object\n */\nfunction createRefDirective(dom, tag, attrName, attrValue) {\n  return create(RefExpr).init(dom, tag, attrName, attrValue)\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function (expr) {\n    if (expr.unmount) { expr.unmount(true); }\n    else if (expr.tagName) { expr.tag.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\nvar IfExpr = {\n  init: function init(dom, tag, expr) {\n    removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n    extend(this, { tag: tag, expr: expr, stub: createDOMPlaceholder(), pristine: dom });\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update$$1() {\n    this.value = tmpl(this.expr, this.tag);\n\n    if (this.value && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n      this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n    } else if (!this.value && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode) {\n        this.current.parentNode.removeChild(this.current);\n      }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (this.value) { update.call(this.tag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n  }\n}\n\n/**\n * Create a new if directive\n * @param   { HTMLElement } dom - if root dom node\n * @param   { Tag } context - tag instance where the DOM node is located\n * @param   { String } attr - if expression\n * @returns { IFExpr } a new IfExpr object\n */\nfunction createIfDirective(dom, tag, attr) {\n  return create(IfExpr).init(dom, tag, attr)\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Array } all the expressions found\n */\nfunction parseExpressions(root, mustIncludeRoot) {\n  var this$1 = this;\n\n  var expressions = [];\n\n  walkNodes(root, function (dom) {\n    var type = dom.nodeType;\n    var attr;\n    var tagImpl;\n\n    if (!mustIncludeRoot && dom === root) { return }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { expressions.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return }\n\n    var isVirtual = dom.tagName === 'VIRTUAL';\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n      if(isVirtual) { setAttribute(dom, 'loopVirtual', true); } // ignore here, handled in _each\n      expressions.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n      expressions.push(createIfDirective(dom, this$1, attr));\n      return false\n    }\n\n    if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n      if (tmpl.hasExpr(attr)) {\n        expressions.push({\n          isRtag: true,\n          expr: attr,\n          dom: dom,\n          attrs: [].slice.call(dom.attributes)\n        });\n\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = get(dom);\n\n    if(isVirtual) {\n      if(getAttribute(dom, 'virtualized')) {dom.parentElement.removeChild(dom); } // tag created, remove from dom\n      if(!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual'))  // ok to create virtual tag\n        { tagImpl = { tmpl: dom.outerHTML }; }\n    }\n\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      if(isVirtual) { // handled in update\n        if (getAttribute(dom, IS_DIRECTIVE))\n          { warn((\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\")); }\n        // can not remove attribute like directives\n        // so flag for removal after creation to prevent maximum stack error\n        setAttribute(dom, 'virtualized', true);\n        var tag = createTag(\n          {tmpl: dom.outerHTML},\n          {root: dom, parent: this$1},\n          dom.innerHTML\n        );\n\n        expressions.push(tag); // no return, anonymous tag, keep parsing\n      } else {\n        expressions.push(\n          initChild(\n            tagImpl,\n            {\n              root: dom,\n              parent: this$1\n            },\n            dom.innerHTML,\n            this$1\n          )\n        );\n        return false\n      }\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n      if (!expr) { return }\n      expressions.push(expr);\n    }]);\n  });\n\n  return expressions\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    if (!attr) { return false }\n\n    var name = attr.name;\n    var bool = isBoolAttr(name);\n    var expr;\n\n    if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n      expr =  createRefDirective(dom, this$1, name, attr.value);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/**\n * Manage the mount state of a tag triggering also the observable events\n * @this Tag\n * @param { Boolean } value - ..of the isMounted flag\n */\nfunction setMountState(value) {\n  var ref = this.__;\n  var isAnonymous = ref.isAnonymous;\n\n  define(this, 'isMounted', value);\n\n  if (!isAnonymous) {\n    if (value) { this.trigger('mount'); }\n    else {\n      this.trigger('unmount');\n      this.off('*');\n      this.__.wasCreated = false;\n    }\n  }\n}\n\n/**\n * Mount the current tag instance\n * @returns { Tag } the current tag instance\n */\nfunction componentMount(tag$$1, dom, expressions, opts) {\n  var __ = tag$$1.__;\n  var root = __.root;\n  root._tag = tag$$1; // keep a reference to the tag just created\n\n  // Read all the attrs on this instance. This give us the info we need for updateOpts\n  parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n    if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = tag$$1; }\n    attr.expr = expr;\n    __.instAttrs.push(attr);\n  }]);\n\n  // update the root adding custom attributes coming from the compiler\n  walkAttributes(__.impl.attrs, function (k, v) { __.implAttrs.push({name: k, value: v}); });\n  parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n    if (expr) { expressions.push(expr); }\n    else { setAttribute(root, attr.name, attr.value); }\n  }]);\n\n  // initialiation\n  updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]);\n\n  // add global mixins\n  var globalMixin = mixin(GLOBAL_MIXIN);\n\n  if (globalMixin && !__.skipAnonymous) {\n    for (var i in globalMixin) {\n      if (globalMixin.hasOwnProperty(i)) {\n        tag$$1.mixin(globalMixin[i]);\n      }\n    }\n  }\n\n  if (__.impl.fn) { __.impl.fn.call(tag$$1, opts); }\n\n  if (!__.skipAnonymous) { tag$$1.trigger('before-mount'); }\n\n  // parse layout after init. fn may calculate args for nested custom tags\n  each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) { return expressions.push(e); });\n\n  tag$$1.update(__.item);\n\n  if (!__.isAnonymous && !__.isInline) {\n    while (dom.firstChild) { root.appendChild(dom.firstChild); }\n  }\n\n  define(tag$$1, 'root', root);\n\n  // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n  if (!__.skipAnonymous && tag$$1.parent) {\n    var p = getImmediateCustomParent(tag$$1.parent);\n    p.one(!p.isMounted ? 'mount' : 'updated', function () {\n      setMountState.call(tag$$1, true);\n    });\n  } else {\n    // otherwise it's not a child tag we can trigger its mount event\n    setMountState.call(tag$$1, true);\n  }\n\n  tag$$1.__.wasCreated = true;\n\n  return tag$$1\n}\n\n/**\n * Unmount the tag instance\n * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n * @returns { Tag } the current tag instance\n */\nfunction tagUnmount(tag, mustKeepRoot, expressions) {\n  var __ = tag.__;\n  var root = __.root;\n  var tagIndex = __TAGS_CACHE.indexOf(tag);\n  var p = root.parentNode;\n\n  if (!__.skipAnonymous) { tag.trigger('before-unmount'); }\n\n  // clear all attributes coming from the mounted tag\n  walkAttributes(__.impl.attrs, function (name) {\n    if (startsWith(name, ATTRS_PREFIX))\n      { name = name.slice(ATTRS_PREFIX.length); }\n\n    removeAttribute(root, name);\n  });\n\n  // remove all the event listeners\n  tag.__.listeners.forEach(function (dom) {\n    Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n      dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n    });\n  });\n\n  // remove tag instance from the global tags cache collection\n  if (tagIndex !== -1) { __TAGS_CACHE.splice(tagIndex, 1); }\n\n  // clean up the parent tags object\n  if (__.parent && !__.isAnonymous) {\n    var ptag = getImmediateCustomParent(__.parent);\n\n    if (__.isVirtual) {\n      Object\n        .keys(tag.tags)\n        .forEach(function (tagName) { return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]); });\n    } else {\n      arrayishRemove(ptag.tags, __.tagName, tag);\n    }\n  }\n\n  // unmount all the virtual directives\n  if (tag.__.virts) {\n    each(tag.__.virts, function (v) {\n      if (v.parentNode) { v.parentNode.removeChild(v); }\n    });\n  }\n\n  // allow expressions to unmount themselves\n  unmountAll(expressions);\n  each(__.instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n  // clear the tag html if it's necessary\n  if (mustKeepRoot) { setInnerHTML(root, ''); }\n  // otherwise detach the root tag from the DOM\n  else if (p) { p.removeChild(root); }\n\n  // custom internal unmount function to avoid relying on the observable\n  if (__.onUnmount) { __.onUnmount(); }\n\n  // weird fix for a weird edge case #2409 and #2436\n  // some users might use your software not as you've expected\n  // so I need to add these dirty hacks to mitigate unexpected issues\n  if (!tag.isMounted) { setMountState.call(tag, true); }\n\n  setMountState.call(tag, false);\n\n  delete root._tag;\n\n  return tag\n}\n\n/**\n * Tag creation factory function\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction createTag(impl, conf, innerHTML) {\n  if ( impl === void 0 ) impl = {};\n  if ( conf === void 0 ) conf = {};\n\n  var tag = conf.context || {};\n  var opts = extend({}, conf.opts);\n  var parent = conf.parent;\n  var isLoop = conf.isLoop;\n  var isAnonymous = !!conf.isAnonymous;\n  var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n  var item = conf.item;\n  // available only for the looped nodes\n  var index = conf.index;\n  // All attributes on the Tag when it's first parsed\n  var instAttrs = [];\n  // expressions on this type of Tag\n  var implAttrs = [];\n  var expressions = [];\n  var root = conf.root;\n  var tagName = conf.tagName || getName(root);\n  var isVirtual = tagName === 'virtual';\n  var isInline = !isVirtual && !impl.tmpl;\n  var dom;\n\n  // make this tag observable\n  if (!skipAnonymous) { observable(tag); }\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  define(tag, 'isMounted', false);\n\n  define(tag, '__', {\n    impl: impl,\n    root: root,\n    skipAnonymous: skipAnonymous,\n    implAttrs: implAttrs,\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    tagName: tagName,\n    index: index,\n    isLoop: isLoop,\n    isInline: isInline,\n    item: item,\n    parent: parent,\n    // tags having event listeners\n    // it would be better to use weak maps here but we can not introduce breaking changes now\n    listeners: [],\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    wasCreated: false,\n    tail: null,\n    head: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  define(tag, '_riot_id', uid()); // base 1 allows test !t._riot_id\n  define(tag, 'root', root);\n  extend(tag, { opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  define(tag, 'parent', parent || null);\n  define(tag, 'tags', {});\n  define(tag, 'refs', {});\n\n  if (isInline || isLoop && isAnonymous) {\n    dom = root;\n  } else {\n    if (!isVirtual) { root.innerHTML = ''; }\n    dom = mkdom(impl.tmpl, innerHTML, isSvg(root));\n  }\n\n  define(tag, 'update', function (data) { return componentUpdate(tag, data, expressions); });\n  define(tag, 'mixin', function () {\n    var mixins = [], len = arguments.length;\n    while ( len-- ) mixins[ len ] = arguments[ len ];\n\n    return componentMixin.apply(void 0, [ tag ].concat( mixins ));\n  });\n  define(tag, 'mount', function () { return componentMount(tag, dom, expressions, opts); });\n  define(tag, 'unmount', function (mustKeepRoot) { return tagUnmount(tag, mustKeepRoot, expressions); });\n\n  return tag\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mount$1(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName];\n  var implClass = __TAG_IMPL[tagName].class;\n  var context = ctx || (implClass ? create(implClass.prototype) : {});\n  // cache the inner HTML to fix #855\n  var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n  var conf = extend({ root: root, opts: opts, context: context }, { parent: opts ? opts.parent : null });\n  var tag;\n\n  if (impl && root) { tag = createTag(impl, conf, innerHTML); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n\n\nvar tags = Object.freeze({\n\tarrayishAdd: arrayishAdd,\n\tgetTagName: getName,\n\tinheritParentProps: inheritParentProps,\n\tmountTo: mount$1,\n\tselectTags: query,\n\tarrayishRemove: arrayishRemove,\n\tgetTag: get,\n\tinitChildTag: initChild,\n\tmoveChildTag: moveChild,\n\tmakeReplaceVirtual: makeReplaceVirtual,\n\tgetImmediateCustomParentTag: getImmediateCustomParent,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tunmountAll: unmountAll,\n\tcreateIfDirective: createIfDirective,\n\tcreateRefDirective: createRefDirective\n});\n\n/**\n * Riot public api\n */\nvar settings$1 = settings;\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\n// export the core props/methods\nvar Tag$1 = Tag;\nvar tag$1 = tag;\nvar tag2$1 = tag2;\nvar mount$2 = mount;\nvar mixin$1 = mixin;\nvar update$2 = update$1;\nvar unregister$1 = unregister;\nvar version$1 = version;\nvar observable$2 = observable;\n\nvar riot$1 = extend({}, core, {\n  observable: observable,\n  settings: settings$1,\n  util: util,\n})\n\nexports.settings = settings$1;\nexports.util = util;\nexports.Tag = Tag$1;\nexports.tag = tag$1;\nexports.tag2 = tag2$1;\nexports.mount = mount$2;\nexports.mixin = mixin$1;\nexports.update = update$2;\nexports.unregister = unregister$1;\nexports.version = version$1;\nexports.observable = observable$2;\nexports.default = riot$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmlvdC9yaW90LmpzP2ZhNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxHQUFHLEdBQUc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZDQUE2QztBQUNsRDtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0EsS0FBSyxPQUFPLG9DQUFvQzs7QUFFaEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QzFDO0FBQ0E7O0FBRUEseUNBQXlDLGdEQUFnRCxFQUFFO0FBQzNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxvQ0FBb0Msb0RBQW9ELEVBQUU7QUFDMUYsa0RBQWtELG1EQUFtRCxFQUFFOztBQUV2RztBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDLEdBQUcsb0NBQW9DO0FBQ3ZHOztBQUVBLHFCQUFxQix3Q0FBd0M7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7QUFFNUQsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogUmlvdCB2My45LjAsIEBsaWNlbnNlIE1JVCAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLnJpb3QgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaG9ydGVyIGFuZCBmYXN0IHdheSB0byBzZWxlY3QgYSBzaW5nbGUgbm9kZSBpbiB0aGUgRE9NXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHNlbGVjdG9yIC0gdW5pcXVlIGRvbSBzZWxlY3RvclxuICogQHBhcmFtICAgeyBPYmplY3QgfSBjdHggLSBET00gbm9kZSB3aGVyZSB0aGUgdGFyZ2V0IG9mIG91ciBzZWFyY2ggd2lsbCBpcyBsb2NhdGVkXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvbSBub2RlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uICQoc2VsZWN0b3IsIGN0eCkge1xuICByZXR1cm4gKGN0eCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvcihzZWxlY3Rvcilcbn1cblxudmFyXG4gIC8vIGJlIGF3YXJlLCBpbnRlcm5hbCB1c2FnZVxuICAvLyBBVFRFTlRJT046IHByZWZpeCB0aGUgZ2xvYmFsIGR5bmFtaWMgdmFyaWFibGVzIHdpdGggYF9fYFxuICAvLyB0YWdzIGluc3RhbmNlcyBjYWNoZVxuICBfX1RBR1NfQ0FDSEUgPSBbXSxcbiAgLy8gdGFncyBpbXBsZW1lbnRhdGlvbiBjYWNoZVxuICBfX1RBR19JTVBMID0ge30sXG4gIFlJRUxEX1RBRyA9ICd5aWVsZCcsXG5cbiAgLyoqXG4gICAqIENvbnN0XG4gICAqL1xuICBHTE9CQUxfTUlYSU4gPSAnX19nbG9iYWxfbWl4aW4nLFxuXG4gIC8vIHJpb3Qgc3BlY2lmaWMgcHJlZml4ZXMgb3IgYXR0cmlidXRlc1xuICBBVFRSU19QUkVGSVggPSAncmlvdC0nLFxuXG4gIC8vIFJpb3QgRGlyZWN0aXZlc1xuICBSRUZfRElSRUNUSVZFUyA9IFsncmVmJywgJ2RhdGEtcmVmJ10sXG4gIElTX0RJUkVDVElWRSA9ICdkYXRhLWlzJyxcbiAgQ09ORElUSU9OQUxfRElSRUNUSVZFID0gJ2lmJyxcbiAgTE9PUF9ESVJFQ1RJVkUgPSAnZWFjaCcsXG4gIExPT1BfTk9fUkVPUkRFUl9ESVJFQ1RJVkUgPSAnbm8tcmVvcmRlcicsXG4gIFNIT1dfRElSRUNUSVZFID0gJ3Nob3cnLFxuICBISURFX0RJUkVDVElWRSA9ICdoaWRlJyxcbiAgS0VZX0RJUkVDVElWRSA9ICdrZXknLFxuICBSSU9UX0VWRU5UU19LRVkgPSAnX19yaW90LWV2ZW50c19fJyxcblxuICAvLyBmb3IgdHlwZW9mID09ICcnIGNvbXBhcmlzb25zXG4gIFRfU1RSSU5HID0gJ3N0cmluZycsXG4gIFRfT0JKRUNUID0gJ29iamVjdCcsXG4gIFRfVU5ERUYgID0gJ3VuZGVmaW5lZCcsXG4gIFRfRlVOQ1RJT04gPSAnZnVuY3Rpb24nLFxuXG4gIFhMSU5LX05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICBTVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBYTElOS19SRUdFWCA9IC9eeGxpbms6KFxcdyspLyxcblxuICBXSU4gPSB0eXBlb2Ygd2luZG93ID09PSBUX1VOREVGID8gdW5kZWZpbmVkIDogd2luZG93LFxuXG4gIC8vIHNwZWNpYWwgbmF0aXZlIHRhZ3MgdGhhdCBjYW5ub3QgYmUgdHJlYXRlZCBsaWtlIHRoZSBvdGhlcnNcbiAgUkVfU1BFQ0lBTF9UQUdTID0gL14oPzp0KD86Ym9keXxoZWFkfGZvb3R8W3JoZF0pfGNhcHRpb258Y29sKD86Z3JvdXApP3xvcHQoPzppb258Z3JvdXApKSQvLFxuICBSRV9TUEVDSUFMX1RBR1NfTk9fT1BUSU9OID0gL14oPzp0KD86Ym9keXxoZWFkfGZvb3R8W3JoZF0pfGNhcHRpb258Y29sKD86Z3JvdXApPykkLyxcbiAgUkVfRVZFTlRTX1BSRUZJWCA9IC9eb24vLFxuICBSRV9IVE1MX0FUVFJTID0gLyhbLVxcd10rKSA/PSA/KD86XCIoW15cIl0qKXwnKFteJ10qKXwoe1tefV0qfSkpL2csXG4gIC8vIHNvbWUgRE9NIGF0dHJpYnV0ZXMgbXVzdCBiZSBub3JtYWxpemVkXG4gIENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVMgPSB7XG4gICAgJ3ZpZXdib3gnOiAndmlld0JveCcsXG4gICAgJ3ByZXNlcnZlYXNwZWN0cmF0aW8nOiAncHJlc2VydmVBc3BlY3RSYXRpbydcbiAgfSxcbiAgLyoqXG4gICAqIE1hdGNoZXMgYm9vbGVhbiBIVE1MIGF0dHJpYnV0ZXMgaW4gdGhlIHJpb3QgdGFnIGRlZmluaXRpb24uXG4gICAqIFdpdGggYSBsb25nIGxpc3QgbGlrZSB0aGlzLCBhIHJlZ2V4IGlzIGZhc3RlciB0aGFuIGBbXS5pbmRleE9mYCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgKiBAY29uc3Qge1JlZ0V4cH1cbiAgICogQHNlZSBbYXR0cmlidXRlcy5tZF0oaHR0cHM6Ly9naXRodWIuY29tL3Jpb3QvY29tcGlsZXIvYmxvYi9kZXYvZG9jL2F0dHJpYnV0ZXMubWQpXG4gICAqL1xuICBSRV9CT09MX0FUVFJTID0gL14oPzpkaXNhYmxlZHxjaGVja2VkfHJlYWRvbmx5fHJlcXVpcmVkfGFsbG93ZnVsbHNjcmVlbnxhdXRvKD86Zm9jdXN8cGxheSl8Y29tcGFjdHxjb250cm9sc3xkZWZhdWx0fGZvcm1ub3ZhbGlkYXRlfGhpZGRlbnxpc21hcHxpdGVtc2NvcGV8bG9vcHxtdWx0aXBsZXxtdXRlZHxubyg/OnJlc2l6ZXxzaGFkZXx2YWxpZGF0ZXx3cmFwKT98b3BlbnxyZXZlcnNlZHxzZWFtbGVzc3xzZWxlY3RlZHxzb3J0YWJsZXx0cnVlc3BlZWR8dHlwZW11c3RtYXRjaCkkLyxcbiAgLy8gdmVyc2lvbiMgZm9yIElFIDgtMTEsIDAgZm9yIG90aGVyc1xuICBJRV9WRVJTSU9OID0gKFdJTiAmJiBXSU4uZG9jdW1lbnQgfHwge30pLmRvY3VtZW50TW9kZSB8IDA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1xuXG4vKipcbiAqIENyZWF0ZSBhIGdlbmVyaWMgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIERPTSBub2RlIHdlIHdhbnQgdG8gY3JlYXRlXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IERPTSBub2RlIGp1c3QgY3JlYXRlZFxuICovXG5mdW5jdGlvbiBtYWtlRWxlbWVudChuYW1lKSB7XG4gIHJldHVybiBuYW1lID09PSAnc3ZnJyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxufVxuXG4vKipcbiAqIFNldCBhbnkgRE9NIGF0dHJpYnV0ZVxuICogQHBhcmFtIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2Ugd2FudCB0byB1cGRhdGVcbiAqIEBwYXJhbSB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNldFxuICogQHBhcmFtIHsgU3RyaW5nIH0gdmFsIC0gdmFsdWUgb2YgdGhlIHByb3BlcnR5IHdlIHdhbnQgdG8gc2V0XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShkb20sIG5hbWUsIHZhbCkge1xuICB2YXIgeGxpbmsgPSBYTElOS19SRUdFWC5leGVjKG5hbWUpO1xuICBpZiAoeGxpbmsgJiYgeGxpbmtbMV0pXG4gICAgeyBkb20uc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIHhsaW5rWzFdLCB2YWwpOyB9XG4gIGVsc2VcbiAgICB7IGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsKTsgfVxufVxuXG52YXIgc3R5bGVOb2RlO1xuLy8gQ3JlYXRlIGNhY2hlIGFuZCBzaG9ydGN1dCB0byB0aGUgY29ycmVjdCBwcm9wZXJ0eVxudmFyIGNzc1RleHRQcm9wO1xudmFyIGJ5TmFtZSA9IHt9O1xudmFyIHJlbWFpbmRlciA9IFtdO1xudmFyIG5lZWRzSW5qZWN0ID0gZmFsc2U7XG5cbi8vIHNraXAgdGhlIGZvbGxvd2luZyBjb2RlIG9uIHRoZSBzZXJ2ZXJcbmlmIChXSU4pIHtcbiAgc3R5bGVOb2RlID0gKChmdW5jdGlvbiAoKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHN0eWxlIGVsZW1lbnQgd2l0aCB0aGUgY29ycmVjdCB0eXBlXG4gICAgdmFyIG5ld05vZGUgPSBtYWtlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAvLyByZXBsYWNlIGFueSB1c2VyIG5vZGUgb3IgaW5zZXJ0IHRoZSBuZXcgb25lIGludG8gdGhlIGhlYWRcbiAgICB2YXIgdXNlck5vZGUgPSAkKCdzdHlsZVt0eXBlPXJpb3RdJyk7XG5cbiAgICBzZXRBdHRyaWJ1dGUobmV3Tm9kZSwgJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh1c2VyTm9kZSkge1xuICAgICAgaWYgKHVzZXJOb2RlLmlkKSB7IG5ld05vZGUuaWQgPSB1c2VyTm9kZS5pZDsgfVxuICAgICAgdXNlck5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgdXNlck5vZGUpO1xuICAgIH0gZWxzZSB7IGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7IH1cblxuICAgIHJldHVybiBuZXdOb2RlXG4gIH0pKSgpO1xuICBjc3NUZXh0UHJvcCA9IHN0eWxlTm9kZS5zdHlsZVNoZWV0O1xufVxuXG4vKipcbiAqIE9iamVjdCB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbmplY3QgYW5kIG1hbmFnZSB0aGUgY3NzIG9mIGV2ZXJ5IHRhZyBpbnN0YW5jZVxuICovXG52YXIgc3R5bGVNYW5hZ2VyID0ge1xuICBzdHlsZU5vZGU6IHN0eWxlTm9kZSxcbiAgLyoqXG4gICAqIFNhdmUgYSB0YWcgc3R5bGUgdG8gYmUgbGF0ZXIgaW5qZWN0ZWQgaW50byBET01cbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gY3NzIC0gY3NzIHN0cmluZ1xuICAgKiBAcGFyYW0geyBTdHJpbmcgfSBuYW1lIC0gaWYgaXQncyBwYXNzZWQgd2Ugd2lsbCBtYXAgdGhlIGNzcyB0byBhIHRhZ25hbWVcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gYWRkKGNzcywgbmFtZSkge1xuICAgIGlmIChuYW1lKSB7IGJ5TmFtZVtuYW1lXSA9IGNzczsgfVxuICAgIGVsc2UgeyByZW1haW5kZXIucHVzaChjc3MpOyB9XG4gICAgbmVlZHNJbmplY3QgPSB0cnVlO1xuICB9LFxuICAvKipcbiAgICogSW5qZWN0IGFsbCBwcmV2aW91c2x5IHNhdmVkIHRhZyBzdHlsZXMgaW50byBET01cbiAgICogaW5uZXJIVE1MIHNlZW1zIHNsb3c6IGh0dHA6Ly9qc3BlcmYuY29tL3Jpb3QtaW5zZXJ0LXN0eWxlXG4gICAqL1xuICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICBpZiAoIVdJTiB8fCAhbmVlZHNJbmplY3QpIHsgcmV0dXJuIH1cbiAgICBuZWVkc0luamVjdCA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IE9iamVjdC5rZXlzKGJ5TmFtZSlcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGJ5TmFtZVtrXTsgfSlcbiAgICAgIC5jb25jYXQocmVtYWluZGVyKS5qb2luKCdcXG4nKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChjc3NUZXh0UHJvcCkgeyBjc3NUZXh0UHJvcC5jc3NUZXh0ID0gc3R5bGU7IH1cbiAgICBlbHNlIHsgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlOyB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgcmlvdCB0ZW1wbGF0ZSBlbmdpbmVcbiAqIEB2ZXJzaW9uIHYzLjAuOFxuICovXG5cbnZhciBza2lwUmVnZXggPSAoZnVuY3Rpb24gKCkgeyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICB2YXIgYmVmb3JlUmVDaGFycyA9ICdbeygsOzo/PXwmIV5+PiUqLyc7XG5cbiAgdmFyIGJlZm9yZVJlV29yZHMgPSBbXG4gICAgJ2Nhc2UnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZG8nLFxuICAgICdlbHNlJyxcbiAgICAnaW4nLFxuICAgICdpbnN0YW5jZW9mJyxcbiAgICAncHJlZml4JyxcbiAgICAncmV0dXJuJyxcbiAgICAndHlwZW9mJyxcbiAgICAndm9pZCcsXG4gICAgJ3lpZWxkJ1xuICBdO1xuXG4gIHZhciB3b3Jkc0xhc3RDaGFyID0gYmVmb3JlUmVXb3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKHMsIHcpIHtcbiAgICByZXR1cm4gcyArIHcuc2xpY2UoLTEpXG4gIH0sICcnKTtcblxuICB2YXIgUkVfUkVHRVggPSAvXlxcLyg/PVteKj4vXSlbXlsvXFxcXF0qKD86KD86XFxcXC58XFxbKD86XFxcXC58W15cXF1cXFxcXSopKlxcXSlbXltcXFxcL10qKSo/XFwvW2dpbXV5XSovO1xuICB2YXIgUkVfVk5fQ0hBUiA9IC9bJFxcd10vO1xuXG4gIGZ1bmN0aW9uIHByZXYgKGNvZGUsIHBvcykge1xuICAgIHdoaWxlICgtLXBvcyA+PSAwICYmIC9cXHMvLnRlc3QoY29kZVtwb3NdKSl7IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICBmdW5jdGlvbiBfc2tpcFJlZ2V4IChjb2RlLCBzdGFydCkge1xuXG4gICAgdmFyIHJlID0gLy4qL2c7XG4gICAgdmFyIHBvcyA9IHJlLmxhc3RJbmRleCA9IHN0YXJ0Kys7XG4gICAgdmFyIG1hdGNoID0gcmUuZXhlYyhjb2RlKVswXS5tYXRjaChSRV9SRUdFWCk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBuZXh0ID0gcG9zICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXG4gICAgICBwb3MgPSBwcmV2KGNvZGUsIHBvcyk7XG4gICAgICB2YXIgYyA9IGNvZGVbcG9zXTtcblxuICAgICAgaWYgKHBvcyA8IDAgfHwgfmJlZm9yZVJlQ2hhcnMuaW5kZXhPZihjKSkge1xuICAgICAgICByZXR1cm4gbmV4dFxuICAgICAgfVxuXG4gICAgICBpZiAoYyA9PT0gJy4nKSB7XG5cbiAgICAgICAgaWYgKGNvZGVbcG9zIC0gMV0gPT09ICcuJykge1xuICAgICAgICAgIHN0YXJ0ID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGMgPT09ICcrJyB8fCBjID09PSAnLScpIHtcblxuICAgICAgICBpZiAoY29kZVstLXBvc10gIT09IGMgfHxcbiAgICAgICAgICAgIChwb3MgPSBwcmV2KGNvZGUsIHBvcykpIDwgMCB8fFxuICAgICAgICAgICAgIVJFX1ZOX0NIQVIudGVzdChjb2RlW3Bvc10pKSB7XG4gICAgICAgICAgc3RhcnQgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAofndvcmRzTGFzdENoYXIuaW5kZXhPZihjKSkge1xuXG4gICAgICAgIHZhciBlbmQgPSBwb3MgKyAxO1xuXG4gICAgICAgIHdoaWxlICgtLXBvcyA+PSAwICYmIFJFX1ZOX0NIQVIudGVzdChjb2RlW3Bvc10pKXsgfVxuICAgICAgICBpZiAofmJlZm9yZVJlV29yZHMuaW5kZXhPZihjb2RlLnNsaWNlKHBvcyArIDEsIGVuZCkpKSB7XG4gICAgICAgICAgc3RhcnQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICByZXR1cm4gX3NraXBSZWdleFxuXG59KSgpO1xuXG4vKipcbiAqIHJpb3QudXRpbC5icmFja2V0c1xuICpcbiAqIC0gYGJyYWNrZXRzICAgIGAgLSBSZXR1cm5zIGEgc3RyaW5nIG9yIHJlZ2V4IGJhc2VkIG9uIGl0cyBwYXJhbWV0ZXJcbiAqIC0gYGJyYWNrZXRzLnNldGAgLSBDaGFuZ2UgdGhlIGN1cnJlbnQgcmlvdCBicmFja2V0c1xuICpcbiAqIEBtb2R1bGVcbiAqL1xuXG4vKiBnbG9iYWwgcmlvdCAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIGJyYWNrZXRzID0gKGZ1bmN0aW9uIChVTkRFRikge1xuXG4gIHZhclxuICAgIFJFR0xPQiA9ICdnJyxcblxuICAgIFJfTUxDT01NUyA9IC9cXC9cXCpbXipdKlxcKisoPzpbXipcXC9dW14qXSpcXCorKSpcXC8vZyxcblxuICAgIFJfU1RSSU5HUyA9IC9cIlteXCJcXFxcXSooPzpcXFxcW1xcU1xcc11bXlwiXFxcXF0qKSpcInwnW14nXFxcXF0qKD86XFxcXFtcXFNcXHNdW14nXFxcXF0qKSonfGBbXmBcXFxcXSooPzpcXFxcW1xcU1xcc11bXmBcXFxcXSopKmAvZyxcblxuICAgIFNfUUJMT0NLUyA9IFJfU1RSSU5HUy5zb3VyY2UgKyAnfCcgK1xuICAgICAgLyg/OlxcYnJldHVyblxccyt8KD86WyRcXHdcXClcXF1dfFxcK1xcK3wtLSlcXHMqKFxcLykoPyFbKlxcL10pKS8uc291cmNlICsgJ3wnICtcbiAgICAgIC9cXC8oPz1bXipcXC9dKVteW1xcL1xcXFxdKig/Oig/OlxcWyg/OlxcXFwufFteXFxdXFxcXF0qKSpcXF18XFxcXC4pW15bXFwvXFxcXF0qKSo/KFtePF1cXC8pW2dpbV0qLy5zb3VyY2UsXG5cbiAgICBVTlNVUFBPUlRFRCA9IFJlZ0V4cCgnW1xcXFwnICsgJ3gwMC1cXFxceDFGPD5hLXpBLVowLTlcXCdcIiw7XFxcXFxcXFxdJyksXG5cbiAgICBORUVEX0VTQ0FQRSA9IC8oPz1bW1xcXSgpKis/Ll4kfF0pL2csXG5cbiAgICBTX1FCTE9DSzIgPSBSX1NUUklOR1Muc291cmNlICsgJ3wnICsgLyhcXC8pKD8hWypcXC9dKS8uc291cmNlLFxuXG4gICAgRklOREJSQUNFUyA9IHtcbiAgICAgICcoJzogUmVnRXhwKCcoWygpXSl8JyAgICsgU19RQkxPQ0syLCBSRUdMT0IpLFxuICAgICAgJ1snOiBSZWdFeHAoJyhbW1xcXFxdXSl8JyArIFNfUUJMT0NLMiwgUkVHTE9CKSxcbiAgICAgICd7JzogUmVnRXhwKCcoW3t9XSl8JyAgICsgU19RQkxPQ0syLCBSRUdMT0IpXG4gICAgfSxcblxuICAgIERFRkFVTFQgPSAneyB9Jzs7Ozs7Ozs7O1xuXG4gIHZhciBfcGFpcnMgPSBbXG4gICAgJ3snLCAnfScsXG4gICAgJ3snLCAnfScsXG4gICAgL3tbXn1dKn0vLFxuICAgIC9cXFxcKFt7fV0pL2csXG4gICAgL1xcXFwoeyl8ey9nLFxuICAgIFJlZ0V4cCgnXFxcXFxcXFwofSl8KFtbKHtdKXwofSl8JyArIFNfUUJMT0NLMiwgUkVHTE9CKSxcbiAgICBERUZBVUxULFxuICAgIC9eXFxzKntcXF4/XFxzKihbJFxcd10rKSg/OlxccyosXFxzKihcXFMrKSk/XFxzK2luXFxzKyhcXFMuKilcXHMqfS8sXG4gICAgLyhefFteXFxcXF0pez1bXFxTXFxzXSo/fS9cbiAgXTtcblxuICB2YXJcbiAgICBjYWNoZWRCcmFja2V0cyA9IFVOREVGLFxuICAgIF9yZWdleCxcbiAgICBfY2FjaGUgPSBbXSxcbiAgICBfc2V0dGluZ3M7Ozs7XG5cbiAgZnVuY3Rpb24gX2xvb3BiYWNrIChyZSkgeyByZXR1cm4gcmUgfVxuXG4gIGZ1bmN0aW9uIF9yZXdyaXRlIChyZSwgYnApIHtcbiAgICBpZiAoIWJwKSB7IGJwID0gX2NhY2hlOyB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICByZS5zb3VyY2UucmVwbGFjZSgvey9nLCBicFsyXSkucmVwbGFjZSgvfS9nLCBicFszXSksIHJlLmdsb2JhbCA/IFJFR0xPQiA6ICcnXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZSAocGFpcikge1xuICAgIGlmIChwYWlyID09PSBERUZBVUxUKSB7IHJldHVybiBfcGFpcnMgfVxuXG4gICAgdmFyIGFyciA9IHBhaXIuc3BsaXQoJyAnKTtcblxuICAgIGlmIChhcnIubGVuZ3RoICE9PSAyIHx8IFVOU1VQUE9SVEVELnRlc3QocGFpcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYnJhY2tldHMgXCInICsgcGFpciArICdcIicpXG4gICAgfVxuICAgIGFyciA9IGFyci5jb25jYXQocGFpci5yZXBsYWNlKE5FRURfRVNDQVBFLCAnXFxcXCcpLnNwbGl0KCcgJykpO1xuXG4gICAgYXJyWzRdID0gX3Jld3JpdGUoYXJyWzFdLmxlbmd0aCA+IDEgPyAve1tcXFNcXHNdKj99LyA6IF9wYWlyc1s0XSwgYXJyKTtcbiAgICBhcnJbNV0gPSBfcmV3cml0ZShwYWlyLmxlbmd0aCA+IDMgPyAvXFxcXCh7fH0pL2cgOiBfcGFpcnNbNV0sIGFycik7XG4gICAgYXJyWzZdID0gX3Jld3JpdGUoX3BhaXJzWzZdLCBhcnIpO1xuICAgIGFycls3XSA9IFJlZ0V4cCgnXFxcXFxcXFwoJyArIGFyclszXSArICcpfChbWyh7XSl8KCcgKyBhcnJbM10gKyAnKXwnICsgU19RQkxPQ0syLCBSRUdMT0IpO1xuICAgIGFycls4XSA9IHBhaXI7XG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgZnVuY3Rpb24gX2JyYWNrZXRzIChyZU9ySWR4KSB7XG4gICAgcmV0dXJuIHJlT3JJZHggaW5zdGFuY2VvZiBSZWdFeHAgPyBfcmVnZXgocmVPcklkeCkgOiBfY2FjaGVbcmVPcklkeF1cbiAgfVxuXG4gIF9icmFja2V0cy5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChzdHIsIHRtcGwsIF9icCkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBfYnAgaXMgZm9yIHRoZSBjb21waWxlclxuICAgIGlmICghX2JwKSB7IF9icCA9IF9jYWNoZTsgfVxuXG4gICAgdmFyXG4gICAgICBwYXJ0cyA9IFtdLFxuICAgICAgbWF0Y2gsXG4gICAgICBpc2V4cHIsXG4gICAgICBzdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlID0gX2JwWzZdOzs7Ozs7XG5cbiAgICB2YXIgcWJsb2NrcyA9IFtdO1xuICAgIHZhciBwcmV2U3RyID0gJyc7XG4gICAgdmFyIG1hcmssIGxhc3RJbmRleDs7XG5cbiAgICBpc2V4cHIgPSBzdGFydCA9IHJlLmxhc3RJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhzdHIpKSkge1xuXG4gICAgICBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICBwb3MgPSBtYXRjaC5pbmRleDtcblxuICAgICAgaWYgKGlzZXhwcikge1xuXG4gICAgICAgIGlmIChtYXRjaFsyXSkge1xuXG4gICAgICAgICAgdmFyIGNoID0gbWF0Y2hbMl07XG4gICAgICAgICAgdmFyIHJlY2ggPSBGSU5EQlJBQ0VTW2NoXTtcbiAgICAgICAgICB2YXIgaXggPSAxO1xuXG4gICAgICAgICAgcmVjaC5sYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlY2guZXhlYyhzdHIpKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gY2gpIHsgKytpeDsgfVxuICAgICAgICAgICAgICBlbHNlIGlmICghLS1peCkgeyBicmVhayB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNoLmxhc3RJbmRleCA9IHB1c2hRQmxvY2sobWF0Y2guaW5kZXgsIHJlY2gubGFzdEluZGV4LCBtYXRjaFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlLmxhc3RJbmRleCA9IGl4ID8gc3RyLmxlbmd0aCA6IHJlY2gubGFzdEluZGV4O1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1hdGNoWzNdKSB7XG4gICAgICAgICAgcmUubGFzdEluZGV4ID0gcHVzaFFCbG9jayhwb3MsIGxhc3RJbmRleCwgbWF0Y2hbNF0pO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgICB1bmVzY2FwZVN0cihzdHIuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICAgICAgICBzdGFydCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUgPSBfYnBbNiArIChpc2V4cHIgXj0gMSldO1xuICAgICAgICByZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyICYmIHN0YXJ0IDwgc3RyLmxlbmd0aCkge1xuICAgICAgdW5lc2NhcGVTdHIoc3RyLnNsaWNlKHN0YXJ0KSk7XG4gICAgfVxuXG4gICAgcGFydHMucWJsb2NrcyA9IHFibG9ja3M7XG5cbiAgICByZXR1cm4gcGFydHNcblxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlU3RyIChzKSB7XG4gICAgICBpZiAocHJldlN0cikge1xuICAgICAgICBzID0gcHJldlN0ciArIHM7XG4gICAgICAgIHByZXZTdHIgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0bXBsIHx8IGlzZXhwcikge1xuICAgICAgICBwYXJ0cy5wdXNoKHMgJiYgcy5yZXBsYWNlKF9icFs1XSwgJyQxJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdXNoUUJsb2NrKF9wb3MsIF9sYXN0SW5kZXgsIHNsYXNoKSB7IC8vZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKHNsYXNoKSB7XG4gICAgICAgIF9sYXN0SW5kZXggPSBza2lwUmVnZXgoc3RyLCBfcG9zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRtcGwgJiYgX2xhc3RJbmRleCA+IF9wb3MgKyAyKSB7XG4gICAgICAgIG1hcmsgPSAnXFx1MjA1NycgKyBxYmxvY2tzLmxlbmd0aCArICd+JztcbiAgICAgICAgcWJsb2Nrcy5wdXNoKHN0ci5zbGljZShfcG9zLCBfbGFzdEluZGV4KSk7XG4gICAgICAgIHByZXZTdHIgKz0gc3RyLnNsaWNlKHN0YXJ0LCBfcG9zKSArIG1hcms7XG4gICAgICAgIHN0YXJ0ID0gX2xhc3RJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfbGFzdEluZGV4XG4gICAgfVxuICB9O1xuXG4gIF9icmFja2V0cy5oYXNFeHByID0gZnVuY3Rpb24gaGFzRXhwciAoc3RyKSB7XG4gICAgcmV0dXJuIF9jYWNoZVs0XS50ZXN0KHN0cilcbiAgfTtcblxuICBfYnJhY2tldHMubG9vcEtleXMgPSBmdW5jdGlvbiBsb29wS2V5cyAoZXhwcikge1xuICAgIHZhciBtID0gZXhwci5tYXRjaChfY2FjaGVbOV0pO1xuXG4gICAgcmV0dXJuIG1cbiAgICAgID8geyBrZXk6IG1bMV0sIHBvczogbVsyXSwgdmFsOiBfY2FjaGVbMF0gKyBtWzNdLnRyaW0oKSArIF9jYWNoZVsxXSB9XG4gICAgICA6IHsgdmFsOiBleHByLnRyaW0oKSB9XG4gIH07XG5cbiAgX2JyYWNrZXRzLmFycmF5ID0gZnVuY3Rpb24gYXJyYXkgKHBhaXIpIHtcbiAgICByZXR1cm4gcGFpciA/IF9jcmVhdGUocGFpcikgOiBfY2FjaGVcbiAgfTtcblxuICBmdW5jdGlvbiBfcmVzZXQgKHBhaXIpIHtcbiAgICBpZiAoKHBhaXIgfHwgKHBhaXIgPSBERUZBVUxUKSkgIT09IF9jYWNoZVs4XSkge1xuICAgICAgX2NhY2hlID0gX2NyZWF0ZShwYWlyKTtcbiAgICAgIF9yZWdleCA9IHBhaXIgPT09IERFRkFVTFQgPyBfbG9vcGJhY2sgOiBfcmV3cml0ZTtcbiAgICAgIF9jYWNoZVs5XSA9IF9yZWdleChfcGFpcnNbOV0pO1xuICAgIH1cbiAgICBjYWNoZWRCcmFja2V0cyA9IHBhaXI7XG4gIH1cblxuICBmdW5jdGlvbiBfc2V0U2V0dGluZ3MgKG8pIHtcbiAgICB2YXIgYjtcblxuICAgIG8gPSBvIHx8IHt9O1xuICAgIGIgPSBvLmJyYWNrZXRzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAnYnJhY2tldHMnLCB7XG4gICAgICBzZXQ6IF9yZXNldCxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGVkQnJhY2tldHMgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfc2V0dGluZ3MgPSBvO1xuICAgIF9yZXNldChiKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYnJhY2tldHMsICdzZXR0aW5ncycsIHtcbiAgICBzZXQ6IF9zZXRTZXR0aW5ncyxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9zZXR0aW5ncyB9XG4gIH0pO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpbiB0aGUgYnJvd3NlciByaW90IGlzIGFsd2F5cyBpbiB0aGUgc2NvcGUgKi9cbiAgX2JyYWNrZXRzLnNldHRpbmdzID0gdHlwZW9mIHJpb3QgIT09ICd1bmRlZmluZWQnICYmIHJpb3Quc2V0dGluZ3MgfHwge307XG4gIF9icmFja2V0cy5zZXQgPSBfcmVzZXQ7XG4gIF9icmFja2V0cy5za2lwUmVnZXggPSBza2lwUmVnZXg7XG5cbiAgX2JyYWNrZXRzLlJfU1RSSU5HUyA9IFJfU1RSSU5HUztcbiAgX2JyYWNrZXRzLlJfTUxDT01NUyA9IFJfTUxDT01NUztcbiAgX2JyYWNrZXRzLlNfUUJMT0NLUyA9IFNfUUJMT0NLUztcbiAgX2JyYWNrZXRzLlNfUUJMT0NLMiA9IFNfUUJMT0NLMjtcblxuICByZXR1cm4gX2JyYWNrZXRzXG5cbn0pKCk7XG5cbi8qKlxuICogQG1vZHVsZSB0bXBsXG4gKlxuICogdG1wbCAgICAgICAgICAtIFJvb3QgZnVuY3Rpb24sIHJldHVybnMgdGhlIHRlbXBsYXRlIHZhbHVlLCByZW5kZXIgd2l0aCBkYXRhXG4gKiB0bXBsLmhhc0V4cHIgIC0gVGVzdCB0aGUgZXhpc3RlbmNlIG9mIGEgZXhwcmVzc2lvbiBpbnNpZGUgYSBzdHJpbmdcbiAqIHRtcGwubG9vcEtleXMgLSBHZXQgdGhlIGtleXMgZm9yIGFuICdlYWNoJyBsb29wICh1c2VkIGJ5IGBfZWFjaGApXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciB0bXBsID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgX2NhY2hlID0ge307XG5cbiAgZnVuY3Rpb24gX3RtcGwgKHN0ciwgZGF0YSkge1xuICAgIGlmICghc3RyKSB7IHJldHVybiBzdHIgfVxuXG4gICAgcmV0dXJuIChfY2FjaGVbc3RyXSB8fCAoX2NhY2hlW3N0cl0gPSBfY3JlYXRlKHN0cikpKS5jYWxsKFxuICAgICAgZGF0YSwgX2xvZ0Vyci5iaW5kKHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgdG1wbDogc3RyXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIF90bXBsLmhhc0V4cHIgPSBicmFja2V0cy5oYXNFeHByO1xuXG4gIF90bXBsLmxvb3BLZXlzID0gYnJhY2tldHMubG9vcEtleXM7XG5cbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgX3RtcGwuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgX2NhY2hlID0ge307IH07XG5cbiAgX3RtcGwuZXJyb3JIYW5kbGVyID0gbnVsbDtcblxuICBmdW5jdGlvbiBfbG9nRXJyIChlcnIsIGN0eCkge1xuXG4gICAgZXJyLnJpb3REYXRhID0ge1xuICAgICAgdGFnTmFtZTogY3R4ICYmIGN0eC5fXyAmJiBjdHguX18udGFnTmFtZSxcbiAgICAgIF9yaW90X2lkOiBjdHggJiYgY3R4Ll9yaW90X2lkICAvL2VzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgfTtcblxuICAgIGlmIChfdG1wbC5lcnJvckhhbmRsZXIpIHsgX3RtcGwuZXJyb3JIYW5kbGVyKGVycik7IH1cbiAgICBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgY29uc29sZS5sb2coJzwlcz4gJXMnLCBlcnIucmlvdERhdGEudGFnTmFtZSB8fCAnVW5rbm93biB0YWcnLCB0aGlzLnRtcGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZSAoc3RyKSB7XG4gICAgdmFyIGV4cHIgPSBfZ2V0VG1wbChzdHIpO1xuXG4gICAgaWYgKGV4cHIuc2xpY2UoMCwgMTEpICE9PSAndHJ5e3JldHVybiAnKSB7IGV4cHIgPSAncmV0dXJuICcgKyBleHByOyB9XG5cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdFJywgZXhwciArICc7JykgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuICB9XG5cbiAgdmFyIFJFX0RRVU9URSA9IC9cXHUyMDU3L2c7XG4gIHZhciBSRV9RQk1BUksgPSAvXFx1MjA1NyhcXGQrKX4vZztcblxuICBmdW5jdGlvbiBfZ2V0VG1wbCAoc3RyKSB7XG4gICAgdmFyIHBhcnRzID0gYnJhY2tldHMuc3BsaXQoc3RyLnJlcGxhY2UoUkVfRFFVT1RFLCAnXCInKSwgMSk7XG4gICAgdmFyIHFzdHIgPSBwYXJ0cy5xYmxvY2tzO1xuICAgIHZhciBleHByO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIgfHwgcGFydHNbMF0pIHtcbiAgICAgIHZhciBpLCBqLCBsaXN0ID0gW107OztcblxuICAgICAgZm9yIChpID0gaiA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgIGV4cHIgPSBwYXJ0c1tpXTtcblxuICAgICAgICBpZiAoZXhwciAmJiAoZXhwciA9IGkgJiAxXG5cbiAgICAgICAgICAgID8gX3BhcnNlRXhwcihleHByLCAxLCBxc3RyKVxuXG4gICAgICAgICAgICA6ICdcIicgKyBleHByXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxuP3xcXG4vZywgJ1xcXFxuJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICtcbiAgICAgICAgICAgICAgJ1wiJ1xuXG4gICAgICAgICAgKSkgeyBsaXN0W2orK10gPSBleHByOyB9XG5cbiAgICAgIH1cblxuICAgICAgZXhwciA9IGogPCAyID8gbGlzdFswXVxuICAgICAgICAgICA6ICdbJyArIGxpc3Quam9pbignLCcpICsgJ10uam9pbihcIlwiKSc7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBleHByID0gX3BhcnNlRXhwcihwYXJ0c1sxXSwgMCwgcXN0cik7XG4gICAgfVxuXG4gICAgaWYgKHFzdHIubGVuZ3RoKSB7XG4gICAgICBleHByID0gZXhwci5yZXBsYWNlKFJFX1FCTUFSSywgZnVuY3Rpb24gKF8sIHBvcykge1xuICAgICAgICByZXR1cm4gcXN0cltwb3NdXG4gICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9XG5cbiAgdmFyIFJFX0NTTkFNRSA9IC9eKD86KC0/W19BLVphLXpcXHhBMC1cXHhGRl1bLVxcd1xceEEwLVxceEZGXSopfFxcdTIwNTcoXFxkKyl+KTovO1xuICB2YXJcbiAgICBSRV9CUkVORCA9IHtcbiAgICAgICcoJzogL1soKV0vZyxcbiAgICAgICdbJzogL1tbXFxdXS9nLFxuICAgICAgJ3snOiAvW3t9XS9nXG4gICAgfTtcblxuICBmdW5jdGlvbiBfcGFyc2VFeHByIChleHByLCBhc1RleHQsIHFzdHIpIHtcblxuICAgIGV4cHIgPSBleHByXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKVxuICAgICAgLnJlcGxhY2UoL1xcID8oW1tcXCh7fSw/XFwuOl0pXFwgPy9nLCAnJDEnKTtcblxuICAgIGlmIChleHByKSB7XG4gICAgICB2YXJcbiAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICBjbnQgPSAwLFxuICAgICAgICBtYXRjaDs7O1xuXG4gICAgICB3aGlsZSAoZXhwciAmJlxuICAgICAgICAgICAgKG1hdGNoID0gZXhwci5tYXRjaChSRV9DU05BTUUpKSAmJlxuICAgICAgICAgICAgIW1hdGNoLmluZGV4XG4gICAgICAgICkge1xuICAgICAgICB2YXJcbiAgICAgICAgICBrZXksXG4gICAgICAgICAganNiLFxuICAgICAgICAgIHJlID0gLyx8KFtbeyhdKXwkL2c7OztcblxuICAgICAgICBleHByID0gUmVnRXhwLnJpZ2h0Q29udGV4dDtcbiAgICAgICAga2V5ICA9IG1hdGNoWzJdID8gcXN0clttYXRjaFsyXV0uc2xpY2UoMSwgLTEpLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykgOiBtYXRjaFsxXTtcblxuICAgICAgICB3aGlsZSAoanNiID0gKG1hdGNoID0gcmUuZXhlYyhleHByKSlbMV0pIHsgc2tpcEJyYWNlcyhqc2IsIHJlKTsgfVxuXG4gICAgICAgIGpzYiAgPSBleHByLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgZXhwciA9IFJlZ0V4cC5yaWdodENvbnRleHQ7XG5cbiAgICAgICAgbGlzdFtjbnQrK10gPSBfd3JhcEV4cHIoanNiLCAxLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBleHByID0gIWNudCA/IF93cmFwRXhwcihleHByLCBhc1RleHQpXG4gICAgICAgICAgIDogY250ID4gMSA/ICdbJyArIGxpc3Quam9pbignLCcpICsgJ10uam9pbihcIiBcIikudHJpbSgpJyA6IGxpc3RbMF07XG4gICAgfVxuICAgIHJldHVybiBleHByXG5cbiAgICBmdW5jdGlvbiBza2lwQnJhY2VzIChjaCwgcmUpIHtcbiAgICAgIHZhclxuICAgICAgICBtbSxcbiAgICAgICAgbHYgPSAxLFxuICAgICAgICBpciA9IFJFX0JSRU5EW2NoXTs7O1xuXG4gICAgICBpci5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICB3aGlsZSAobW0gPSBpci5leGVjKGV4cHIpKSB7XG4gICAgICAgIGlmIChtbVswXSA9PT0gY2gpIHsgKytsdjsgfVxuICAgICAgICBlbHNlIGlmICghLS1sdikgeyBicmVhayB9XG4gICAgICB9XG4gICAgICByZS5sYXN0SW5kZXggPSBsdiA/IGV4cHIubGVuZ3RoIDogaXIubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgYm90aFxuICB2YXIgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICBKU19DT05URVhUID0gJ1wiaW4gdGhpcz90aGlzOicgKyAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgPyAnZ2xvYmFsJyA6ICd3aW5kb3cnKSArICcpLicsXG4gICAgSlNfVkFSTkFNRSA9IC9bLHtdW1xcJFxcd10rKD89Oil8KF4gKnxbXiRcXHdcXC57XSkoPyEoPzp0eXBlb2Z8dHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZHxpbnxpbnN0YW5jZW9mfGlzKD86RmluaXRlfE5hTil8dm9pZHxOYU58bmV3fERhdGV8UmVnRXhwfE1hdGgpKD8hWyRcXHddKSkoWyRfQS1aYS16XVskXFx3XSopL2csXG4gICAgSlNfTk9QUk9QUyA9IC9eKD89KFxcLlskXFx3XSspKVxcMSg/OlteLlsoXXwkKS87OztcblxuICBmdW5jdGlvbiBfd3JhcEV4cHIgKGV4cHIsIGFzVGV4dCwga2V5KSB7XG4gICAgdmFyIHRiO1xuXG4gICAgZXhwciA9IGV4cHIucmVwbGFjZShKU19WQVJOQU1FLCBmdW5jdGlvbiAobWF0Y2gsIHAsIG12YXIsIHBvcywgcykge1xuICAgICAgaWYgKG12YXIpIHtcbiAgICAgICAgcG9zID0gdGIgPyAwIDogcG9zICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIGlmIChtdmFyICE9PSAndGhpcycgJiYgbXZhciAhPT0gJ2dsb2JhbCcgJiYgbXZhciAhPT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICBtYXRjaCA9IHAgKyAnKFwiJyArIG12YXIgKyBKU19DT05URVhUICsgbXZhcjtcbiAgICAgICAgICBpZiAocG9zKSB7IHRiID0gKHMgPSBzW3Bvc10pID09PSAnLicgfHwgcyA9PT0gJygnIHx8IHMgPT09ICdbJzsgfVxuICAgICAgICB9IGVsc2UgaWYgKHBvcykge1xuICAgICAgICAgIHRiID0gIUpTX05PUFJPUFMudGVzdChzLnNsaWNlKHBvcykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9KTtcblxuICAgIGlmICh0Yikge1xuICAgICAgZXhwciA9ICd0cnl7cmV0dXJuICcgKyBleHByICsgJ31jYXRjaChlKXtFKGUsdGhpcyl9JztcbiAgICB9XG5cbiAgICBpZiAoa2V5KSB7XG5cbiAgICAgIGV4cHIgPSAodGJcbiAgICAgICAgICA/ICdmdW5jdGlvbigpeycgKyBleHByICsgJ30uY2FsbCh0aGlzKScgOiAnKCcgKyBleHByICsgJyknXG4gICAgICAgICkgKyAnP1wiJyArIGtleSArICdcIjpcIlwiJztcblxuICAgIH0gZWxzZSBpZiAoYXNUZXh0KSB7XG5cbiAgICAgIGV4cHIgPSAnZnVuY3Rpb24odil7JyArICh0YlxuICAgICAgICAgID8gZXhwci5yZXBsYWNlKCdyZXR1cm4gJywgJ3Y9JykgOiAndj0oJyArIGV4cHIgKyAnKSdcbiAgICAgICAgKSArICc7cmV0dXJuIHZ8fHY9PT0wP3Y6XCJcIn0uY2FsbCh0aGlzKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHJcbiAgfVxuXG4gIF90bXBsLnZlcnNpb24gPSBicmFja2V0cy52ZXJzaW9uID0gJ3YzLjAuOCc7XG5cbiAgcmV0dXJuIF90bXBsXG5cbn0pKCk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgb2JzZXJ2YWJsZSA9IGZ1bmN0aW9uKGVsKSB7XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgb3JpZ2luYWwgb2JqZWN0IG9yIGNyZWF0ZSBhIG5ldyBlbXB0eSBvbmVcbiAgICogQHR5cGUgeyBPYmplY3QgfVxuICAgKi9cblxuICBlbCA9IGVsIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIHZhcmlhYmxlc1xuICAgKi9cbiAgdmFyIGNhbGxiYWNrcyA9IHt9LFxuICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlOztcblxuICAvKipcbiAgICogUHVibGljIEFwaVxuICAgKi9cblxuICAvLyBleHRlbmQgdGhlIGVsIG9iamVjdCBhZGRpbmcgdGhlIG9ic2VydmFibGUgbWV0aG9kc1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlbCwge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gYGV2ZW50YCBhbmRzXG4gICAgICogZXhlY3V0ZSB0aGUgYGNhbGxiYWNrYCBlYWNoIHRpbWUgYW4gZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEBwYXJhbSAgeyBTdHJpbmcgfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICogQHBhcmFtICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgKi9cbiAgICBvbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgeyAoY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrc1tldmVudF0gfHwgW10pLnB1c2goZm4pOyB9XG4gICAgICAgIHJldHVybiBlbFxuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBgZXZlbnRgIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXZlbnQgLSBldmVudCBpZFxuICAgICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgeyBPYmplY3QgfSBlbFxuICAgICAqL1xuICAgIG9mZjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgICBpZiAoZXZlbnQgPT0gJyonICYmICFmbikgeyBjYWxsYmFja3MgPSB7fTsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcnIgPSBjYWxsYmFja3NbZXZlbnRdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNiOyBjYiA9IGFyciAmJiBhcnJbaV07ICsraSkge1xuICAgICAgICAgICAgICBpZiAoY2IgPT0gZm4pIHsgYXJyLnNwbGljZShpLS0sIDEpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHsgZGVsZXRlIGNhbGxiYWNrc1tldmVudF07IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIHRvIHRoZSBnaXZlbiBgZXZlbnRgIGFuZFxuICAgICAqIGV4ZWN1dGUgdGhlIGBjYWxsYmFja2AgYXQgbW9zdCBvbmNlXG4gICAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICovXG4gICAgb25lOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICAgIGVsLm9mZihldmVudCwgb24pO1xuICAgICAgICAgIGZuLmFwcGx5KGVsLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5vbihldmVudCwgb24pXG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYWxsIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGxpc3RlbiB0b1xuICAgICAqIHRoZSBnaXZlbiBgZXZlbnRgXG4gICAgICogQHBhcmFtICAgeyBTdHJpbmcgfSBldmVudCAtIGV2ZW50IGlkXG4gICAgICogQHJldHVybnMgeyBPYmplY3QgfSBlbFxuICAgICAqL1xuICAgIHRyaWdnZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cblxuICAgICAgICAvLyBnZXR0aW5nIHRoZSBhcmd1bWVudHNcbiAgICAgICAgdmFyIGFyZ2xlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJnbGVuKSxcbiAgICAgICAgICBmbnMsXG4gICAgICAgICAgZm4sXG4gICAgICAgICAgaTs7Ozs7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2xlbjsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2kgKyAxXTsgLy8gc2tpcCBmaXJzdCBhcmd1bWVudFxuICAgICAgICB9XG5cbiAgICAgICAgZm5zID0gc2xpY2UuY2FsbChjYWxsYmFja3NbZXZlbnRdIHx8IFtdLCAwKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBmbiA9IGZuc1tpXTsgKytpKSB7XG4gICAgICAgICAgZm4uYXBwbHkoZWwsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrc1snKiddICYmIGV2ZW50ICE9ICcqJylcbiAgICAgICAgICB7IGVsLnRyaWdnZXIuYXBwbHkoZWwsIFsnKicsIGV2ZW50XS5jb25jYXQoYXJncykpOyB9XG5cbiAgICAgICAgcmV0dXJuIGVsXG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWxcblxufTtcblxuLyoqXG4gKiBTaG9ydCBhbGlhcyBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvclxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVzY3JpcHRvciAobywgaykge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBrKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyB1bmRlZmluZWRcbiAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVF9VTkRFRlxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgb2JqZWN0J3MgcHJvcGVydHkgY291bGQgYmUgb3ZlcnJpZGRlblxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgb2JqIC0gc291cmNlIG9iamVjdFxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAga2V5IC0gb2JqZWN0IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSB0cnVlIGlmIHdyaXRhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzV3JpdGFibGUob2JqLCBrZXkpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRQcm9wRGVzY3JpcHRvcihvYmosIGtleSk7XG4gIHJldHVybiBpc1VuZGVmaW5lZChvYmpba2V5XSkgfHwgZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLndyaXRhYmxlXG59XG5cbi8qKlxuICogRXh0ZW5kIGFueSBvYmplY3Qgd2l0aCBvdGhlciBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHNyYyAtIHNvdXJjZSBvYmplY3RcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gdGhlIHJlc3VsdGluZyBleHRlbmRlZCBvYmplY3RcbiAqXG4gKiB2YXIgb2JqID0geyBmb286ICdiYXonIH1cbiAqIGV4dGVuZChvYmosIHtiYXI6ICdiYXInLCBmb286ICdiYXInfSlcbiAqIGNvbnNvbGUubG9nKG9iaikgPT4ge2JhcjogJ2JhcicsIGZvbzogJ2Jhcid9XG4gKlxuICovXG5mdW5jdGlvbiBleHRlbmQoc3JjKSB7XG4gIHZhciBvYmo7XG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsID0gYXJncy5sZW5ndGg7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAob2JqID0gYXJnc1tpXSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGNvdWxkIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgaWYgKGlzV3JpdGFibGUoc3JjLCBrZXkpKVxuICAgICAgICAgIHsgc3JjW2tleV0gPSBvYmpba2V5XTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3JjXG59XG5cbi8qKlxuICogQWxpYXMgZm9yIE9iamVjdC5jcmVhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHNyYykge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShzcmMpXG59XG5cbnZhciBzZXR0aW5ncyA9IGV4dGVuZChjcmVhdGUoYnJhY2tldHMuc2V0dGluZ3MpLCB7XG4gIHNraXBBbm9ueW1vdXNUYWdzOiB0cnVlLFxuICAvLyBoYW5kbGUgdGhlIGF1dG8gdXBkYXRlcyBvbiBhbnkgRE9NIGV2ZW50XG4gIGF1dG9VcGRhdGU6IHRydWVcbn0pXG5cbi8qKlxuICogU2hvcnRlciBhbmQgZmFzdCB3YXkgdG8gc2VsZWN0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBET01cbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gc2VsZWN0b3IgLSBET00gc2VsZWN0b3JcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gY3R4IC0gRE9NIG5vZGUgd2hlcmUgdGhlIHRhcmdldHMgb2Ygb3VyIHNlYXJjaCB3aWxsIGlzIGxvY2F0ZWRcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZG9tIG5vZGVzIGZvdW5kXG4gKi9cbmZ1bmN0aW9uICQkKHNlbGVjdG9yLCBjdHgpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoKGN0eCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZG9jdW1lbnQgdGV4dCBub2RlXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IGNyZWF0ZSBhIHRleHQgbm9kZSB0byB1c2UgYXMgcGxhY2Vob2xkZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJylcbn1cblxuLyoqXG4gKiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgYW55IERPTSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9ICBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIGhpZGVcbiAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IHNob3cgLSBkbyB3ZSB3YW50IHRvIHNob3cgaXQ/XG4gKi9cblxuZnVuY3Rpb24gdG9nZ2xlVmlzaWJpbGl0eShkb20sIHNob3cpIHtcbiAgZG9tLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gJycgOiAnbm9uZSc7XG4gIGRvbS5oaWRkZW4gPSBzaG93ID8gZmFsc2UgOiB0cnVlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgYW55IERPTSBhdHRyaWJ1dGUgb24gYSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gcGFyc2VcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB3ZSB3YW50IHRvIGdldFxuICogQHJldHVybnMgeyBTdHJpbmcgfCB1bmRlZmluZWQgfSBuYW1lIG9mIHRoZSBub2RlIGF0dHJpYnV0ZSB3aGV0aGVyIGl0IGV4aXN0c1xuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZG9tLCBuYW1lKSB7XG4gIHJldHVybiBkb20uZ2V0QXR0cmlidXRlKG5hbWUpXG59XG5cbi8qKlxuICogUmVtb3ZlIGFueSBET00gYXR0cmlidXRlIGZyb20gYSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gdXBkYXRlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZG9tLCBuYW1lKSB7XG4gIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lciBodG1sIG9mIGFueSBET00gbm9kZSBTVkdzIGluY2x1ZGVkXG4gKiBAcGFyYW0geyBPYmplY3QgfSBjb250YWluZXIgLSBET00gbm9kZSB3aGVyZSB3ZSdsbCBpbmplY3QgbmV3IGh0bWxcbiAqIEBwYXJhbSB7IFN0cmluZyB9IGh0bWwgLSBodG1sIHRvIGluamVjdFxuICogQHBhcmFtIHsgQm9vbGVhbiB9IGlzU3ZnIC0gc3ZnIHRhZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgYSBiaXQgZGlmZmVyZW50bHlcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHNldElubmVySFRNTChjb250YWluZXIsIGh0bWwsIGlzU3ZnKSB7XG4gIC8vIGlubmVySFRNTCBpcyBub3Qgc3VwcG9ydGVkIG9uIHN2ZyB0YWdzIHNvIHdlIG5lZXQgdG8gdHJlYXQgdGhlbSBkaWZmZXJlbnRseVxuICBpZiAoaXNTdmcpIHtcbiAgICB2YXIgbm9kZSA9IGNvbnRhaW5lci5vd25lckRvY3VtZW50LmltcG9ydE5vZGUoXG4gICAgICBuZXcgRE9NUGFyc2VyKClcbiAgICAgICAgLnBhcnNlRnJvbVN0cmluZygoXCI8c3ZnIHhtbG5zPVxcXCJcIiArIFNWR19OUyArIFwiXFxcIj5cIiArIGh0bWwgKyBcIjwvc3ZnPlwiKSwgJ2FwcGxpY2F0aW9uL3htbCcpXG4gICAgICAgIC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufVxuXG4vKipcbiAqIE1pbmltaXplIHJpc2s6IG9ubHkgemVybyBvciBvbmUgX3NwYWNlXyBiZXR3ZWVuIGF0dHIgJiB2YWx1ZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGh0bWwgLSBodG1sIHN0cmluZyB3ZSB3YW50IHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbiB0byBhcHBseSBvbiBhbnkgYXR0cmlidXRlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIHdhbGtBdHRyaWJ1dGVzKGh0bWwsIGZuKSB7XG4gIGlmICghaHRtbCkgeyByZXR1cm4gfVxuICB2YXIgbTtcbiAgd2hpbGUgKG0gPSBSRV9IVE1MX0FUVFJTLmV4ZWMoaHRtbCkpXG4gICAgeyBmbihtWzFdLnRvTG93ZXJDYXNlKCksIG1bMl0gfHwgbVszXSB8fCBtWzRdKTsgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRvY3VtZW50IGZyYWdtZW50XG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvY3VtZW50IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG59XG5cbi8qKlxuICogSW5zZXJ0IHNhZmVseSBhIHRhZyB0byBmaXggIzE5NjIgIzE2NDlcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSByb290IC0gY2hpbGRyZW4gY29udGFpbmVyXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gY3VyciAtIG5vZGUgdG8gaW5zZXJ0XG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gbmV4dCAtIG5vZGUgdGhhdCBzaG91bGQgcHJlY2VlZCB0aGUgY3VycmVudCBub2RlIGluc2VydGVkXG4gKi9cbmZ1bmN0aW9uIHNhZmVJbnNlcnQocm9vdCwgY3VyciwgbmV4dCkge1xuICByb290Lmluc2VydEJlZm9yZShjdXJyLCBuZXh0LnBhcmVudE5vZGUgJiYgbmV4dCk7XG59XG5cbi8qKlxuICogQ29udmVydCBhIHN0eWxlIG9iamVjdCB0byBhIHN0cmluZ1xuICogQHBhcmFtICAgeyBPYmplY3QgfSBzdHlsZSAtIHN0eWxlIG9iamVjdCB3ZSBuZWVkIHRvIHBhcnNlXG4gKiBAcmV0dXJucyB7IFN0cmluZyB9IHJlc3VsdGluZyBjc3Mgc3RyaW5nXG4gKiBAZXhhbXBsZVxuICogc3R5bGVPYmplY3RUb1N0cmluZyh7IGNvbG9yOiAncmVkJywgaGVpZ2h0OiAnMTBweCd9KSAvLyA9PiAnY29sb3I6IHJlZDsgaGVpZ2h0OiAxMHB4J1xuICovXG5mdW5jdGlvbiBzdHlsZU9iamVjdFRvU3RyaW5nKHN0eWxlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3ApIHtcbiAgICByZXR1cm4gKGFjYyArIFwiIFwiICsgcHJvcCArIFwiOiBcIiArIChzdHlsZVtwcm9wXSkgKyBcIjtcIilcbiAgfSwgJycpXG59XG5cbi8qKlxuICogV2FsayBkb3duIHJlY3Vyc2l2ZWx5IGFsbCB0aGUgY2hpbGRyZW4gdGFncyBzdGFydGluZyBkb20gbm9kZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgIGRvbSAtIHN0YXJ0aW5nIG5vZGUgd2hlcmUgd2Ugd2lsbCBzdGFydCB0aGUgcmVjdXJzaW9uXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayB0byB0cmFuc2Zvcm0gdGhlIGNoaWxkIG5vZGUganVzdCBmb3VuZFxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgIGNvbnRleHQgLSBmbiBjYW4gb3B0aW9uYWxseSByZXR1cm4gYW4gb2JqZWN0LCB3aGljaCBpcyBwYXNzZWQgdG8gY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gd2Fsa05vZGVzKGRvbSwgZm4sIGNvbnRleHQpIHtcbiAgaWYgKGRvbSkge1xuICAgIHZhciByZXMgPSBmbihkb20sIGNvbnRleHQpO1xuICAgIHZhciBuZXh0O1xuICAgIC8vIHN0b3AgdGhlIHJlY3Vyc2lvblxuICAgIGlmIChyZXMgPT09IGZhbHNlKSB7IHJldHVybiB9XG5cbiAgICBkb20gPSBkb20uZmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgIG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICB3YWxrTm9kZXMoZG9tLCBmbiwgcmVzKTtcbiAgICAgIGRvbSA9IG5leHQ7XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgZG9tID0gT2JqZWN0LmZyZWV6ZSh7XG5cdCQkOiAkJCxcblx0JDogJCxcblx0Y3JlYXRlRE9NUGxhY2Vob2xkZXI6IGNyZWF0ZURPTVBsYWNlaG9sZGVyLFxuXHRta0VsOiBtYWtlRWxlbWVudCxcblx0c2V0QXR0cjogc2V0QXR0cmlidXRlLFxuXHR0b2dnbGVWaXNpYmlsaXR5OiB0b2dnbGVWaXNpYmlsaXR5LFxuXHRnZXRBdHRyOiBnZXRBdHRyaWJ1dGUsXG5cdHJlbUF0dHI6IHJlbW92ZUF0dHJpYnV0ZSxcblx0c2V0SW5uZXJIVE1MOiBzZXRJbm5lckhUTUwsXG5cdHdhbGtBdHRyczogd2Fsa0F0dHJpYnV0ZXMsXG5cdGNyZWF0ZUZyYWc6IGNyZWF0ZUZyYWdtZW50LFxuXHRzYWZlSW5zZXJ0OiBzYWZlSW5zZXJ0LFxuXHRzdHlsZU9iamVjdFRvU3RyaW5nOiBzdHlsZU9iamVjdFRvU3RyaW5nLFxuXHR3YWxrTm9kZXM6IHdhbGtOb2Rlc1xufSk7XG5cbi8qKlxuICogQ2hlY2sgYWdhaW5zdCB0aGUgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlc1xuICogQHBhcmFtICAgeyAqIH0gIHZhbHVlIC1cbiAqIEByZXR1cm5zIHtCb29sZWFufSAtXG4gKi9cbmZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gIHJldHVybiBpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGxcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgZW1wdHkuIERpZmZlcmVudCBmcm9tIGZhbHN5LCBiZWNhdXNlIHdlIGRvbnQgY29uc2lkZXIgMCBvciBmYWxzZSB0byBiZSBibGFua1xuICogQHBhcmFtIHsgKiB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gaXNOaWwodmFsdWUpIHx8IHZhbHVlID09PSAnJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtXG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVF9GVU5DVElPTlxufVxuXG4vKipcbiAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhbiBvYmplY3QsIGV4Y2x1ZGUgbnVsbFxuICogTk9URTogdXNlIGlzT2JqZWN0KHgpICYmICFpc0FycmF5KHgpIHRvIGV4Y2x1ZGVzIGFycmF5cy5cbiAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gVF9PQkpFQ1QgLy8gdHlwZW9mIG51bGwgaXMgJ29iamVjdCdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGFuIHN2ZyB0YWcgb3IgcGFydCBvZiBhbiBzdmdcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSAgZWwgLSBub2RlIHdlIHdhbnQgdG8gdGVzdFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQncyBhbiBzdmcgbm9kZVxuICovXG5mdW5jdGlvbiBpc1N2ZyhlbCkge1xuICB2YXIgb3duZXIgPSBlbC5vd25lclNWR0VsZW1lbnQ7XG4gIHJldHVybiAhIW93bmVyIHx8IG93bmVyID09PSBudWxsXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgcGFzc2VkIGFyZ3VtZW50IGlzIGEga2luZCBvZiBhcnJheVxuICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLVxuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBhIGJvb2xlYW4gYXR0cmlidXRlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNCb29sQXR0cih2YWx1ZSkge1xuICByZXR1cm4gUkVfQk9PTF9BVFRSUy50ZXN0KHZhbHVlKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIHN0cmluZ1xuICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLVxuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBUX1NUUklOR1xufVxuXG5cblxudmFyIGNoZWNrID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGlzQmxhbms6IGlzQmxhbmssXG5cdGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0aXNTdmc6IGlzU3ZnLFxuXHRpc1dyaXRhYmxlOiBpc1dyaXRhYmxlLFxuXHRpc0FycmF5OiBpc0FycmF5LFxuXHRpc0Jvb2xBdHRyOiBpc0Jvb2xBdHRyLFxuXHRpc05pbDogaXNOaWwsXG5cdGlzU3RyaW5nOiBpc1N0cmluZyxcblx0aXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkXG59KTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIGFycmF5IGNvbnRhaW5zIGFuIGl0ZW1cbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBhcnJheSAtIHRhcmdldCBhcnJheVxuICogQHBhcmFtICAgeyAqIH0gaXRlbSAtIGl0ZW0gdG8gdGVzdFxuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBjb250YWlucyhhcnJheSwgaXRlbSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTFcbn1cblxuLyoqXG4gKiBTcGVjaWFsaXplZCBmdW5jdGlvbiBmb3IgbG9vcGluZyBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gd2l0aCBgZWFjaD17fWBcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBsaXN0IC0gY29sbGVjdGlvbiBvZiBpdGVtc1xuICogQHBhcmFtICAge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gdGhlIGFycmF5IGxvb3BlZFxuICovXG5mdW5jdGlvbiBlYWNoKGxpc3QsIGZuKSB7XG4gIHZhciBsZW4gPSBsaXN0ID8gbGlzdC5sZW5ndGggOiAwO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHsgZm4obGlzdFtpXSwgaSk7IH1cbiAgcmV0dXJuIGxpc3Rcbn1cblxuLyoqXG4gKiBGYXN0ZXIgU3RyaW5nIHN0YXJ0c1dpdGggYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gc3RyIC0gc291cmNlIHN0cmluZ1xuICogQHBhcmFtICAgeyBTdHJpbmcgfSB2YWx1ZSAtIHRlc3Qgc3RyaW5nXG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCB2YWx1ZSkge1xuICByZXR1cm4gc3RyLnNsaWNlKDAsIHZhbHVlLmxlbmd0aCkgPT09IHZhbHVlXG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGFsd2F5cyBhIHVuaXF1ZSBpZGVudGlmaWVyXG4gKiBAcmV0dXJucyB7IE51bWJlciB9IC0gbnVtYmVyIGZyb20gMC4uLm5cbiAqL1xudmFyIHVpZCA9IChmdW5jdGlvbiB1aWQoKSB7XG4gIHZhciBpID0gLTE7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiArK2k7IH1cbn0pKClcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IGFuIGltbXV0YWJsZSBwcm9wZXJ0eVxuICogQHBhcmFtICAgeyBPYmplY3QgfSBlbCAtIG9iamVjdCB3aGVyZSB0aGUgbmV3IHByb3BlcnR5IHdpbGwgYmUgc2V0XG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IGtleSAtIG9iamVjdCBrZXkgd2hlcmUgdGhlIG5ldyBwcm9wZXJ0eSB3aWxsIGJlIHN0b3JlZFxuICogQHBhcmFtICAgeyAqIH0gdmFsdWUgLSB2YWx1ZSBvZiB0aGUgbmV3IHByb3BlcnR5XG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdGlvbnMgLSBzZXQgdGhlIHByb3Blcnkgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBvcHRpb25zXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IC0gdGhlIGluaXRpYWwgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGRlZmluZShlbCwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIGtleSwgZXh0ZW5kKHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LCBvcHRpb25zKSk7XG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgY29udGFpbmluZyBkYXNoZXMgdG8gY2FtZWwgY2FzZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBzdHIgLSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbXktc3RyaW5nIC0+IG15U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHRvQ2FtZWwoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvLShcXHcpL2csIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG59XG5cbi8qKlxuICogV2FybiBhIG1lc3NhZ2UgdmlhIGNvbnNvbGVcbiAqIEBwYXJhbSAgIHtTdHJpbmd9IG1lc3NhZ2UgLSB3YXJuaW5nIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgeyBjb25zb2xlLndhcm4obWVzc2FnZSk7IH1cbn1cblxuXG5cbnZhciBtaXNjID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNvbnRhaW5zOiBjb250YWlucyxcblx0ZWFjaDogZWFjaCxcblx0Z2V0UHJvcERlc2NyaXB0b3I6IGdldFByb3BEZXNjcmlwdG9yLFxuXHRzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuXHR1aWQ6IHVpZCxcblx0ZGVmaW5lUHJvcGVydHk6IGRlZmluZSxcblx0b2JqZWN0Q3JlYXRlOiBjcmVhdGUsXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHR0b0NhbWVsOiB0b0NhbWVsLFxuXHR3YXJuOiB3YXJuXG59KTtcblxuLyoqXG4gKiBTZXQgdGhlIHByb3BlcnR5IG9mIGFuIG9iamVjdCBmb3IgYSBnaXZlbiBrZXkuIElmIHNvbWV0aGluZyBhbHJlYWR5XG4gKiBleGlzdHMgdGhlcmUsIHRoZW4gaXQgYmVjb21lcyBhbiBhcnJheSBjb250YWluaW5nIGJvdGggdGhlIG9sZCBhbmQgbmV3IHZhbHVlLlxuICogQHBhcmFtIHsgT2JqZWN0IH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIHNldCB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSB7IFN0cmluZyB9IGtleSAtIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7IE9iamVjdCB9IHZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBzZXRcbiAqIEBwYXJhbSB7IEJvb2xlYW4gfSBlbnN1cmVBcnJheSAtIGVuc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSByZW1haW5zIGFuIGFycmF5XG4gKiBAcGFyYW0geyBOdW1iZXIgfSBpbmRleCAtIGFkZCB0aGUgbmV3IGl0ZW0gaW4gYSBjZXJ0YWluIGFycmF5IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGFycmF5aXNoQWRkKG9iaiwga2V5LCB2YWx1ZSwgZW5zdXJlQXJyYXksIGluZGV4KSB7XG4gIHZhciBkZXN0ID0gb2JqW2tleV07XG4gIHZhciBpc0FyciA9IGlzQXJyYXkoZGVzdCk7XG4gIHZhciBoYXNJbmRleCA9ICFpc1VuZGVmaW5lZChpbmRleCk7XG5cbiAgaWYgKGRlc3QgJiYgZGVzdCA9PT0gdmFsdWUpIHsgcmV0dXJuIH1cblxuICAvLyBpZiB0aGUga2V5IHdhcyBuZXZlciBzZXQsIHNldCBpdCBvbmNlXG4gIGlmICghZGVzdCAmJiBlbnN1cmVBcnJheSkgeyBvYmpba2V5XSA9IFt2YWx1ZV07IH1cbiAgZWxzZSBpZiAoIWRlc3QpIHsgb2JqW2tleV0gPSB2YWx1ZTsgfVxuICAvLyBpZiBpdCB3YXMgYW4gYXJyYXkgYW5kIG5vdCB5ZXQgc2V0XG4gIGVsc2Uge1xuICAgIGlmIChpc0Fycikge1xuICAgICAgdmFyIG9sZEluZGV4ID0gZGVzdC5pbmRleE9mKHZhbHVlKTtcbiAgICAgIC8vIHRoaXMgaXRlbSBuZXZlciBjaGFuZ2VkIGl0cyBwb3NpdGlvblxuICAgICAgaWYgKG9sZEluZGV4ID09PSBpbmRleCkgeyByZXR1cm4gfVxuICAgICAgLy8gcmVtb3ZlIHRoZSBpdGVtIGZyb20gaXRzIG9sZCBwb3NpdGlvblxuICAgICAgaWYgKG9sZEluZGV4ICE9PSAtMSkgeyBkZXN0LnNwbGljZShvbGRJbmRleCwgMSk7IH1cbiAgICAgIC8vIG1vdmUgb3IgYWRkIHRoZSBpdGVtXG4gICAgICBpZiAoaGFzSW5kZXgpIHtcbiAgICAgICAgZGVzdC5zcGxpY2UoaW5kZXgsIDAsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgb2JqW2tleV0gPSBbZGVzdCwgdmFsdWVdOyB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlY3QgdGhlIHRhZyBpbXBsZW1lbnRhdGlvbiBieSBhIERPTSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIG5lZWQgdG8gcGFyc2UgdG8gZ2V0IGl0cyB0YWcgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gaXQgcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgaW1wbGVtZW50YXRpb24gb2YgYSBjdXN0b20gdGFnICh0ZW1wbGF0ZSBhbmQgYm9vdCBmdW5jdGlvbilcbiAqL1xuZnVuY3Rpb24gZ2V0KGRvbSkge1xuICByZXR1cm4gZG9tLnRhZ05hbWUgJiYgX19UQUdfSU1QTFtnZXRBdHRyaWJ1dGUoZG9tLCBJU19ESVJFQ1RJVkUpIHx8XG4gICAgZ2V0QXR0cmlidXRlKGRvbSwgSVNfRElSRUNUSVZFKSB8fCBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpXVxufVxuXG4vKipcbiAqIEdldCB0aGUgdGFnIG5hbWUgb2YgYW55IERPTSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gcGFyc2VcbiAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IHNraXBEYXRhSXMgLSBoYWNrIHRvIGlnbm9yZSB0aGUgZGF0YS1pcyBhdHRyaWJ1dGUgd2hlbiBhdHRhY2hpbmcgdG8gcGFyZW50XG4gKiBAcmV0dXJucyB7IFN0cmluZyB9IG5hbWUgdG8gaWRlbnRpZnkgdGhpcyBkb20gbm9kZSBpbiByaW90XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUoZG9tLCBza2lwRGF0YUlzKSB7XG4gIHZhciBjaGlsZCA9IGdldChkb20pO1xuICB2YXIgbmFtZWRUYWcgPSAhc2tpcERhdGFJcyAmJiBnZXRBdHRyaWJ1dGUoZG9tLCBJU19ESVJFQ1RJVkUpO1xuICByZXR1cm4gbmFtZWRUYWcgJiYgIXRtcGwuaGFzRXhwcihuYW1lZFRhZykgP1xuICAgIG5hbWVkVGFnIDogY2hpbGQgPyBjaGlsZC5uYW1lIDogZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIFJldHVybiBhIHRlbXBvcmFyeSBjb250ZXh0IGNvbnRhaW5pbmcgYWxzbyB0aGUgcGFyZW50IHByb3BlcnRpZXNcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtIHsgVGFnIH0gLSB0ZW1wb3JhcnkgdGFnIGNvbnRleHQgY29udGFpbmluZyBhbGwgdGhlIHBhcmVudCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXRQYXJlbnRQcm9wcygpIHtcbiAgaWYgKHRoaXMucGFyZW50KSB7IHJldHVybiBleHRlbmQoY3JlYXRlKHRoaXMpLCB0aGlzLnBhcmVudCkgfVxuICByZXR1cm4gdGhpc1xufVxuXG4vKlxuICBJbmNsdWRlcyBoYWNrcyBuZWVkZWQgZm9yIHRoZSBJbnRlcm5ldCBFeHBsb3JlciB2ZXJzaW9uIDkgYW5kIGJlbG93XG4gIFNlZTogaHR0cDovL2thbmdheC5naXRodWIuaW8vY29tcGF0LXRhYmxlL2VzNS8jaWU4XG4gICAgICAgaHR0cDovL2NvZGVwbGFuZXQuaW8vZHJvcHBpbmctaWU4L1xuKi9cblxudmFyXG4gIHJlSGFzWWllbGQgID0gLzx5aWVsZFxcYi9pLFxuICByZVlpZWxkQWxsICA9IC88eWllbGRcXHMqKD86XFwvPnw+KFtcXFNcXHNdKj8pPFxcL3lpZWxkXFxzKj58PikvaWcsXG4gIHJlWWllbGRTcmMgID0gLzx5aWVsZFxccyt0bz1bJ1wiXShbXidcIj5dKilbJ1wiXVxccyo+KFtcXFNcXHNdKj8pPFxcL3lpZWxkXFxzKj4vaWcsXG4gIHJlWWllbGREZXN0ID0gLzx5aWVsZFxccytmcm9tPVsnXCJdPyhbLVxcd10rKVsnXCJdP1xccyooPzpcXC8+fD4oW1xcU1xcc10qPyk8XFwveWllbGRcXHMqPikvaWcsXG4gIHJvb3RFbHMgPSB7IHRyOiAndGJvZHknLCB0aDogJ3RyJywgdGQ6ICd0cicsIGNvbDogJ2NvbGdyb3VwJyB9LFxuICB0YmxUYWdzID0gSUVfVkVSU0lPTiAmJiBJRV9WRVJTSU9OIDwgMTAgPyBSRV9TUEVDSUFMX1RBR1MgOiBSRV9TUEVDSUFMX1RBR1NfTk9fT1BUSU9OLFxuICBHRU5FUklDID0gJ2RpdicsXG4gIFNWRyA9ICdzdmcnOzs7Ozs7OztcblxuXG4vKlxuICBDcmVhdGVzIHRoZSByb290IGVsZW1lbnQgZm9yIHRhYmxlIG9yIHNlbGVjdCBjaGlsZCBlbGVtZW50czpcbiAgdHIvdGgvdGQvdGhlYWQvdGZvb3QvdGJvZHkvY2FwdGlvbi9jb2wvY29sZ3JvdXAvb3B0aW9uL29wdGdyb3VwXG4qL1xuZnVuY3Rpb24gc3BlY2lhbFRhZ3MoZWwsIHRtcGwsIHRhZ05hbWUpIHtcblxuICB2YXJcbiAgICBzZWxlY3QgPSB0YWdOYW1lWzBdID09PSAnbycsXG4gICAgcGFyZW50ID0gc2VsZWN0ID8gJ3NlbGVjdD4nIDogJ3RhYmxlPic7O1xuXG4gIC8vIHRyaW0oKSBpcyBpbXBvcnRhbnQgaGVyZSwgdGhpcyBlbnN1cmVzIHdlIGRvbid0IGhhdmUgYXJ0aWZhY3RzLFxuICAvLyBzbyB3ZSBjYW4gY2hlY2sgaWYgd2UgaGF2ZSBvbmx5IG9uZSBlbGVtZW50IGluc2lkZSB0aGUgcGFyZW50XG4gIGVsLmlubmVySFRNTCA9ICc8JyArIHBhcmVudCArIHRtcGwudHJpbSgpICsgJzwvJyArIHBhcmVudDtcbiAgcGFyZW50ID0gZWwuZmlyc3RDaGlsZDtcblxuICAvLyByZXR1cm5zIHRoZSBpbW1lZGlhdGUgcGFyZW50IGlmIHRyL3RoL3RkL2NvbCBpcyB0aGUgb25seSBlbGVtZW50LCBpZiBub3RcbiAgLy8gcmV0dXJucyB0aGUgd2hvbGUgdHJlZSwgYXMgdGhpcyBjYW4gaW5jbHVkZSBhZGRpdGlvbmFsIGVsZW1lbnRzXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChzZWxlY3QpIHtcbiAgICBwYXJlbnQuc2VsZWN0ZWRJbmRleCA9IC0xOyAgLy8gZm9yIElFOSwgY29tcGF0aWJsZSB3L2N1cnJlbnQgcmlvdCBiZWhhdmlvclxuICB9IGVsc2Uge1xuICAgIC8vIGF2b2lkcyBpbnNlcnRpb24gb2YgY29pbnRhaW5lciBpbnNpZGUgY29udGFpbmVyIChleDogdGJvZHkgaW5zaWRlIHRib2R5KVxuICAgIHZhciB0bmFtZSA9IHJvb3RFbHNbdGFnTmFtZV07XG4gICAgaWYgKHRuYW1lICYmIHBhcmVudC5jaGlsZEVsZW1lbnRDb3VudCA9PT0gMSkgeyBwYXJlbnQgPSAkKHRuYW1lLCBwYXJlbnQpOyB9XG4gIH1cbiAgcmV0dXJuIHBhcmVudFxufVxuXG4vKlxuICBSZXBsYWNlIHRoZSB5aWVsZCB0YWcgZnJvbSBhbnkgdGFnIHRlbXBsYXRlIHdpdGggdGhlIGlubmVySFRNTCBvZiB0aGVcbiAgb3JpZ2luYWwgdGFnIGluIHRoZSBwYWdlXG4qL1xuZnVuY3Rpb24gcmVwbGFjZVlpZWxkKHRtcGwsIGh0bWwpIHtcbiAgLy8gZG8gbm90aGluZyBpZiBubyB5aWVsZFxuICBpZiAoIXJlSGFzWWllbGQudGVzdCh0bXBsKSkgeyByZXR1cm4gdG1wbCB9XG5cbiAgLy8gYmUgY2FyZWZ1bCB3aXRoICMxMzQzIC0gc3RyaW5nIG9uIHRoZSBzb3VyY2UgaGF2aW5nIGAkMWBcbiAgdmFyIHNyYyA9IHt9O1xuXG4gIGh0bWwgPSBodG1sICYmIGh0bWwucmVwbGFjZShyZVlpZWxkU3JjLCBmdW5jdGlvbiAoXywgcmVmLCB0ZXh0KSB7XG4gICAgc3JjW3JlZl0gPSBzcmNbcmVmXSB8fCB0ZXh0OyAgIC8vIHByZXNlcnZlIGZpcnN0IGRlZmluaXRpb25cbiAgICByZXR1cm4gJydcbiAgfSkudHJpbSgpO1xuXG4gIHJldHVybiB0bXBsXG4gICAgLnJlcGxhY2UocmVZaWVsZERlc3QsIGZ1bmN0aW9uIChfLCByZWYsIGRlZikgeyAgLy8geWllbGQgd2l0aCBmcm9tIC0gdG8gYXR0cnNcbiAgICAgIHJldHVybiBzcmNbcmVmXSB8fCBkZWYgfHwgJydcbiAgICB9KVxuICAgIC5yZXBsYWNlKHJlWWllbGRBbGwsIGZ1bmN0aW9uIChfLCBkZWYpIHsgICAgICAgIC8vIHlpZWxkIHdpdGhvdXQgYW55IFwiZnJvbVwiXG4gICAgICByZXR1cm4gaHRtbCB8fCBkZWYgfHwgJydcbiAgICB9KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBET00gZWxlbWVudCB0byB3cmFwIHRoZSBnaXZlbiBjb250ZW50LiBOb3JtYWxseSBhbiBgRElWYCwgYnV0IGNhbiBiZVxuICogYWxzbyBhIGBUQUJMRWAsIGBTRUxFQ1RgLCBgVEJPRFlgLCBgVFJgLCBvciBgQ09MR1JPVVBgIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtICAgeyBTdHJpbmcgfSB0bXBsICAtIFRoZSB0ZW1wbGF0ZSBjb21pbmcgZnJvbSB0aGUgY3VzdG9tIHRhZyBkZWZpbml0aW9uXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IGh0bWwgLSBIVE1MIGNvbnRlbnQgdGhhdCBjb21lcyBmcm9tIHRoZSBET00gZWxlbWVudCB3aGVyZSB5b3VcbiAqICAgICAgICAgICB3aWxsIG1vdW50IHRoZSB0YWcsIG1vc3RseSB0aGUgb3JpZ2luYWwgdGFnIGluIHRoZSBwYWdlXG4gKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1N2ZyAtIHRydWUgaWYgdGhlIHJvb3Qgbm9kZSBpcyBhbiBzdmdcbiAqIEByZXR1cm5zIHsgSFRNTEVsZW1lbnQgfSBET00gZWxlbWVudCB3aXRoIF90bXBsXyBtZXJnZWQgdGhyb3VnaCBgWUlFTERgIHdpdGggdGhlIF9odG1sXy5cbiAqL1xuZnVuY3Rpb24gbWtkb20odG1wbCwgaHRtbCwgaXNTdmcpIHtcbiAgdmFyIG1hdGNoICAgPSB0bXBsICYmIHRtcGwubWF0Y2goL15cXHMqPChbLVxcd10rKS8pO1xuICB2YXIgIHRhZ05hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgZWwgPSBtYWtlRWxlbWVudChpc1N2ZyA/IFNWRyA6IEdFTkVSSUMpO1xuXG4gIC8vIHJlcGxhY2UgYWxsIHRoZSB5aWVsZCB0YWdzIHdpdGggdGhlIHRhZyBpbm5lciBodG1sXG4gIHRtcGwgPSByZXBsYWNlWWllbGQodG1wbCwgaHRtbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHRibFRhZ3MudGVzdCh0YWdOYW1lKSlcbiAgICB7IGVsID0gc3BlY2lhbFRhZ3MoZWwsIHRtcGwsIHRhZ05hbWUpOyB9XG4gIGVsc2VcbiAgICB7IHNldElubmVySFRNTChlbCwgdG1wbCwgaXNTdmcpOyB9XG5cbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogTG9vcCBiYWNrd2FyZCBhbGwgdGhlIHBhcmVudHMgdHJlZSB0byBkZXRlY3QgdGhlIGZpcnN0IGN1c3RvbSBwYXJlbnQgdGFnXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHRhZyAtIGEgVGFnIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IHRoZSBpbnN0YW5jZSBvZiB0aGUgZmlyc3QgY3VzdG9tIHBhcmVudCB0YWcgZm91bmRcbiAqL1xuZnVuY3Rpb24gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRhZykge1xuICB2YXIgcHRhZyA9IHRhZztcbiAgd2hpbGUgKHB0YWcuX18uaXNBbm9ueW1vdXMpIHtcbiAgICBpZiAoIXB0YWcucGFyZW50KSB7IGJyZWFrIH1cbiAgICBwdGFnID0gcHRhZy5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHB0YWdcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIERPTSBldmVudHNcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSBkb20gLSBkb20gZWxlbWVudCB0YXJnZXQgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gaGFuZGxlciAtIHVzZXIgZnVuY3Rpb25cbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZSAtIGV2ZW50IG9iamVjdFxuICovXG5mdW5jdGlvbiBoYW5kbGVFdmVudChkb20sIGhhbmRsZXIsIGUpIHtcbiAgdmFyIHB0YWcgPSB0aGlzLl9fLnBhcmVudDtcbiAgdmFyIGl0ZW0gPSB0aGlzLl9fLml0ZW07XG5cbiAgaWYgKCFpdGVtKVxuICAgIHsgd2hpbGUgKHB0YWcgJiYgIWl0ZW0pIHtcbiAgICAgIGl0ZW0gPSBwdGFnLl9fLml0ZW07XG4gICAgICBwdGFnID0gcHRhZy5fXy5wYXJlbnQ7XG4gICAgfSB9XG5cbiAgLy8gb3ZlcnJpZGUgdGhlIGV2ZW50IHByb3BlcnRpZXNcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKGlzV3JpdGFibGUoZSwgJ2N1cnJlbnRUYXJnZXQnKSkgeyBlLmN1cnJlbnRUYXJnZXQgPSBkb207IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKGlzV3JpdGFibGUoZSwgJ3RhcmdldCcpKSB7IGUudGFyZ2V0ID0gZS5zcmNFbGVtZW50OyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChpc1dyaXRhYmxlKGUsICd3aGljaCcpKSB7IGUud2hpY2ggPSBlLmNoYXJDb2RlIHx8IGUua2V5Q29kZTsgfVxuXG4gIGUuaXRlbSA9IGl0ZW07XG5cbiAgaGFuZGxlci5jYWxsKHRoaXMsIGUpO1xuXG4gIC8vIGF2b2lkIGF1dG8gdXBkYXRlc1xuICBpZiAoIXNldHRpbmdzLmF1dG9VcGRhdGUpIHsgcmV0dXJuIH1cblxuICBpZiAoIWUucHJldmVudFVwZGF0ZSkge1xuICAgIHZhciBwID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRoaXMpO1xuICAgIC8vIGZpeGVzICMyMDgzXG4gICAgaWYgKHAuaXNNb3VudGVkKSB7IHAudXBkYXRlKCk7IH1cbiAgfVxufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBldmVudCB0byBhIERPTSBub2RlXG4gKiBAcGFyYW0geyBTdHJpbmcgfSBuYW1lIC0gZXZlbnQgbmFtZVxuICogQHBhcmFtIHsgRnVuY3Rpb24gfSBoYW5kbGVyIC0gZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGRvbSAtIGRvbSBub2RlXG4gKiBAcGFyYW0geyBUYWcgfSB0YWcgLSB0YWcgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gc2V0RXZlbnRIYW5kbGVyKG5hbWUsIGhhbmRsZXIsIGRvbSwgdGFnKSB7XG4gIHZhciBldmVudE5hbWU7XG4gIHZhciBjYiA9IGhhbmRsZUV2ZW50LmJpbmQodGFnLCBkb20sIGhhbmRsZXIpO1xuXG4gIC8vIGF2b2lkIHRvIGJpbmQgdHdpY2UgdGhlIHNhbWUgZXZlbnRcbiAgLy8gcG9zc2libGUgZml4IGZvciAjMjMzMlxuICBkb21bbmFtZV0gPSBudWxsO1xuXG4gIC8vIG5vcm1hbGl6ZSBldmVudCBuYW1lXG4gIGV2ZW50TmFtZSA9IG5hbWUucmVwbGFjZShSRV9FVkVOVFNfUFJFRklYLCAnJyk7XG5cbiAgLy8gY2FjaGUgdGhlIGxpc3RlbmVyIGludG8gdGhlIGxpc3RlbmVycyBhcnJheVxuICBpZiAoIWNvbnRhaW5zKHRhZy5fXy5saXN0ZW5lcnMsIGRvbSkpIHsgdGFnLl9fLmxpc3RlbmVycy5wdXNoKGRvbSk7IH1cbiAgaWYgKCFkb21bUklPVF9FVkVOVFNfS0VZXSkgeyBkb21bUklPVF9FVkVOVFNfS0VZXSA9IHt9OyB9XG4gIGlmIChkb21bUklPVF9FVkVOVFNfS0VZXVtuYW1lXSkgeyBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRvbVtSSU9UX0VWRU5UU19LRVldW25hbWVdKTsgfVxuXG4gIGRvbVtSSU9UX0VWRU5UU19LRVldW25hbWVdID0gY2I7XG4gIGRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2IsIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2hpbGQgdGFnIGluY2x1ZGluZyBpdCBjb3JyZWN0bHkgaW50byBpdHMgcGFyZW50XG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGNoaWxkIC0gY2hpbGQgdGFnIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdHMgLSB0YWcgb3B0aW9ucyBjb250YWluaW5nIHRoZSBET00gbm9kZSB3aGVyZSB0aGUgdGFnIHdpbGwgYmUgbW91bnRlZFxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBpbm5lckhUTUwgLSBpbm5lciBodG1sIG9mIHRoZSBjaGlsZCBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHBhcmVudCAtIGluc3RhbmNlIG9mIHRoZSBwYXJlbnQgdGFnIGluY2x1ZGluZyB0aGUgY2hpbGQgY3VzdG9tIHRhZ1xuICogQHJldHVybnMgeyBPYmplY3QgfSBpbnN0YW5jZSBvZiB0aGUgbmV3IGNoaWxkIHRhZyBqdXN0IGNyZWF0ZWRcbiAqL1xuZnVuY3Rpb24gaW5pdENoaWxkKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwsIHBhcmVudCkge1xuICB2YXIgdGFnID0gY3JlYXRlVGFnKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwpO1xuICB2YXIgdGFnTmFtZSA9IG9wdHMudGFnTmFtZSB8fCBnZXROYW1lKG9wdHMucm9vdCwgdHJ1ZSk7XG4gIHZhciBwdGFnID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHBhcmVudCk7XG4gIC8vIGZpeCBmb3IgdGhlIHBhcmVudCBhdHRyaWJ1dGUgaW4gdGhlIGxvb3BlZCBlbGVtZW50c1xuICBkZWZpbmUodGFnLCAncGFyZW50JywgcHRhZyk7XG4gIC8vIHN0b3JlIHRoZSByZWFsIHBhcmVudCB0YWdcbiAgLy8gaW4gc29tZSBjYXNlcyB0aGlzIGNvdWxkIGJlIGRpZmZlcmVudCBmcm9tIHRoZSBjdXN0b20gcGFyZW50IHRhZ1xuICAvLyBmb3IgZXhhbXBsZSBpbiBuZXN0ZWQgbG9vcHNcbiAgdGFnLl9fLnBhcmVudCA9IHBhcmVudDtcblxuICAvLyBhZGQgdGhpcyB0YWcgdG8gdGhlIGN1c3RvbSBwYXJlbnQgdGFnXG4gIGFycmF5aXNoQWRkKHB0YWcudGFncywgdGFnTmFtZSwgdGFnKTtcblxuICAvLyBhbmQgYWxzbyB0byB0aGUgcmVhbCBwYXJlbnQgdGFnXG4gIGlmIChwdGFnICE9PSBwYXJlbnQpXG4gICAgeyBhcnJheWlzaEFkZChwYXJlbnQudGFncywgdGFnTmFtZSwgdGFnKTsgfVxuXG4gIHJldHVybiB0YWdcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBvYmplY3QgYXQgYSBnaXZlbiBrZXkuIElmIHRoZSBrZXkgcG9pbnRzIHRvIGFuIGFycmF5LFxuICogdGhlbiB0aGUgaXRlbSBpcyBqdXN0IHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0geyBPYmplY3QgfSBvYmogLSBvYmplY3Qgb24gd2hpY2ggdG8gcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICogQHBhcmFtIHsgU3RyaW5nIH0ga2V5IC0gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHsgT2JqZWN0IH0gdmFsdWUgLSB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIHJlbW92ZWRcbiAqIEBwYXJhbSB7IEJvb2xlYW4gfSBlbnN1cmVBcnJheSAtIGVuc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSByZW1haW5zIGFuIGFycmF5XG4qL1xuZnVuY3Rpb24gYXJyYXlpc2hSZW1vdmUob2JqLCBrZXksIHZhbHVlLCBlbnN1cmVBcnJheSkge1xuICBpZiAoaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICB2YXIgaW5kZXggPSBvYmpba2V5XS5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7IG9ialtrZXldLnNwbGljZShpbmRleCwgMSk7IH1cbiAgICBpZiAoIW9ialtrZXldLmxlbmd0aCkgeyBkZWxldGUgb2JqW2tleV07IH1cbiAgICBlbHNlIGlmIChvYmpba2V5XS5sZW5ndGggPT09IDEgJiYgIWVuc3VyZUFycmF5KSB7IG9ialtrZXldID0gb2JqW2tleV1bMF07IH1cbiAgfSBlbHNlIGlmIChvYmpba2V5XSA9PT0gdmFsdWUpXG4gICAgeyBkZWxldGUgb2JqW2tleV07IH0gLy8gb3RoZXJ3aXNlIGp1c3QgZGVsZXRlIHRoZSBrZXlcbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBlbGVtZW50cyBmb3IgYSB2aXJ0dWFsIHRhZ1xuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0geyBOb2RlIH0gc3JjIC0gdGhlIG5vZGUgdGhhdCB3aWxsIGRvIHRoZSBpbnNlcnRpbmcgb3IgYXBwZW5kaW5nXG4gKiBAcGFyYW0geyBUYWcgfSB0YXJnZXQgLSBvbmx5IGlmIGluc2VydGluZywgaW5zZXJ0IGJlZm9yZSB0aGlzIHRhZydzIGZpcnN0IGNoaWxkXG4gKi9cbmZ1bmN0aW9uIG1ha2VWaXJ0dWFsKHNyYywgdGFyZ2V0KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBoZWFkID0gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKTtcbiAgdmFyIHRhaWwgPSBjcmVhdGVET01QbGFjZWhvbGRlcigpO1xuICB2YXIgZnJhZyA9IGNyZWF0ZUZyYWdtZW50KCk7XG4gIHZhciBzaWI7XG4gIHZhciBlbDtcblxuICB0aGlzLnJvb3QuaW5zZXJ0QmVmb3JlKGhlYWQsIHRoaXMucm9vdC5maXJzdENoaWxkKTtcbiAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRhaWwpO1xuXG4gIHRoaXMuX18uaGVhZCA9IGVsID0gaGVhZDtcbiAgdGhpcy5fXy50YWlsID0gdGFpbDtcblxuICB3aGlsZSAoZWwpIHtcbiAgICBzaWIgPSBlbC5uZXh0U2libGluZztcbiAgICBmcmFnLmFwcGVuZENoaWxkKGVsKTtcbiAgICB0aGlzJDEuX18udmlydHMucHVzaChlbCk7IC8vIGhvbGQgZm9yIHVubW91bnRpbmdcbiAgICBlbCA9IHNpYjtcbiAgfVxuXG4gIGlmICh0YXJnZXQpXG4gICAgeyBzcmMuaW5zZXJ0QmVmb3JlKGZyYWcsIHRhcmdldC5fXy5oZWFkKTsgfVxuICBlbHNlXG4gICAgeyBzcmMuYXBwZW5kQ2hpbGQoZnJhZyk7IH1cbn1cblxuLyoqXG4gKiBtYWtlcyBhIHRhZyB2aXJ0dWFsIGFuZCByZXBsYWNlcyBhIHJlZmVyZW5jZSBpbiB0aGUgZG9tXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSB7IHRhZyB9IHRoZSB0YWcgdG8gbWFrZSB2aXJ0dWFsXG4gKiBAcGFyYW0geyByZWYgfSB0aGUgZG9tIHJlZmVyZW5jZSBsb2NhdGlvblxuICovXG5mdW5jdGlvbiBtYWtlUmVwbGFjZVZpcnR1YWwodGFnLCByZWYpIHtcbiAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnbWVudCgpO1xuICBtYWtlVmlydHVhbC5jYWxsKHRhZywgZnJhZyk7XG4gIHJlZi5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChmcmFnLCByZWYpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBkeW5hbWljYWxseSBjcmVhdGVkIGRhdGEtaXMgdGFncyB3aXRoIGNoYW5naW5nIGV4cHJlc3Npb25zXG4gKiBAcGFyYW0geyBPYmplY3QgfSBleHByIC0gZXhwcmVzc2lvbiB0YWcgYW5kIGV4cHJlc3Npb24gaW5mb1xuICogQHBhcmFtIHsgVGFnIH0gICAgcGFyZW50IC0gcGFyZW50IGZvciB0YWcgY3JlYXRpb25cbiAqIEBwYXJhbSB7IFN0cmluZyB9IHRhZ05hbWUgLSB0YWcgaW1wbGVtZW50YXRpb24gd2Ugd2FudCB0byB1c2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGF0YUlzKGV4cHIsIHBhcmVudCwgdGFnTmFtZSkge1xuICB2YXIgdGFnID0gZXhwci50YWcgfHwgZXhwci5kb20uX3RhZztcbiAgdmFyIHJlZjtcblxuICB2YXIgcmVmJDEgPSB0YWcgPyB0YWcuX18gOiB7fTtcbiAgdmFyIGhlYWQgPSByZWYkMS5oZWFkO1xuICB2YXIgaXNWaXJ0dWFsID0gZXhwci5kb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuXG4gIGlmICh0YWcgJiYgZXhwci50YWdOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgdGFnLnVwZGF0ZSgpO1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3luYyBfcGFyZW50IHRvIGFjY29tbW9kYXRlIGNoYW5naW5nIHRhZ25hbWVzXG4gIGlmICh0YWcpIHtcbiAgICAvLyBuZWVkIHBsYWNlaG9sZGVyIGJlZm9yZSB1bm1vdW50XG4gICAgaWYoaXNWaXJ0dWFsKSB7XG4gICAgICByZWYgPSBjcmVhdGVET01QbGFjZWhvbGRlcigpO1xuICAgICAgaGVhZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShyZWYsIGhlYWQpO1xuICAgIH1cblxuICAgIHRhZy51bm1vdW50KHRydWUpO1xuICB9XG5cbiAgLy8gdW5hYmxlIHRvIGdldCB0aGUgdGFnIG5hbWVcbiAgaWYgKCFpc1N0cmluZyh0YWdOYW1lKSkgeyByZXR1cm4gfVxuXG4gIGV4cHIuaW1wbCA9IF9fVEFHX0lNUExbdGFnTmFtZV07XG5cbiAgLy8gdW5rbm93biBpbXBsZW1lbnRhdGlvblxuICBpZiAoIWV4cHIuaW1wbCkgeyByZXR1cm4gfVxuXG4gIGV4cHIudGFnID0gdGFnID0gaW5pdENoaWxkKFxuICAgIGV4cHIuaW1wbCwge1xuICAgICAgcm9vdDogZXhwci5kb20sXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHRhZ05hbWU6IHRhZ05hbWVcbiAgICB9LFxuICAgIGV4cHIuZG9tLmlubmVySFRNTCxcbiAgICBwYXJlbnRcbiAgKTtcblxuICBlYWNoKGV4cHIuYXR0cnMsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBzZXRBdHRyaWJ1dGUodGFnLnJvb3QsIGEubmFtZSwgYS52YWx1ZSk7IH0pO1xuICBleHByLnRhZ05hbWUgPSB0YWdOYW1lO1xuICB0YWcubW91bnQoKTtcblxuICAvLyByb290IGV4aXN0IGZpcnN0IHRpbWUsIGFmdGVyIHVzZSBwbGFjZWhvbGRlclxuICBpZiAoaXNWaXJ0dWFsKSB7IG1ha2VSZXBsYWNlVmlydHVhbCh0YWcsIHJlZiB8fCB0YWcucm9vdCk7IH1cblxuICAvLyBwYXJlbnQgaXMgdGhlIHBsYWNlaG9sZGVyIHRhZywgbm90IHRoZSBkeW5hbWljIHRhZyBzbyBjbGVhbiB1cFxuICBwYXJlbnQuX18ub25Vbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWxOYW1lID0gdGFnLm9wdHMuZGF0YUlzO1xuICAgIGFycmF5aXNoUmVtb3ZlKHRhZy5wYXJlbnQudGFncywgZGVsTmFtZSwgdGFnKTtcbiAgICBhcnJheWlzaFJlbW92ZSh0YWcuX18ucGFyZW50LnRhZ3MsIGRlbE5hbWUsIHRhZyk7XG4gICAgdGFnLnVubW91bnQoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBOb21hbGl6ZSBhbnkgYXR0cmlidXRlIHJlbW92aW5nIHRoZSBcInJpb3QtXCIgcHJlZml4XG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IGF0dHJOYW1lIC0gb3JpZ2luYWwgYXR0cmlidXRlIG5hbWVcbiAqIEByZXR1cm5zIHsgU3RyaW5nIH0gdmFsaWQgaHRtbCBhdHRyaWJ1dGUgbmFtZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBdHRyTmFtZShhdHRyTmFtZSkge1xuICBpZiAoIWF0dHJOYW1lKSB7IHJldHVybiBudWxsIH1cbiAgYXR0ck5hbWUgPSBhdHRyTmFtZS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpO1xuICBpZiAoQ0FTRV9TRU5TSVRJVkVfQVRUUklCVVRFU1thdHRyTmFtZV0pIHsgYXR0ck5hbWUgPSBDQVNFX1NFTlNJVElWRV9BVFRSSUJVVEVTW2F0dHJOYW1lXTsgfVxuICByZXR1cm4gYXR0ck5hbWVcbn1cblxuLyoqXG4gKiBVcGRhdGUgb24gc2luZ2xlIHRhZyBleHByZXNzaW9uXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGV4cHIgLSBleHByZXNzaW9uIGxvZ2ljXG4gKiBAcmV0dXJucyB7IHVuZGVmaW5lZCB9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUV4cHJlc3Npb24oZXhwcikge1xuICBpZiAodGhpcy5yb290ICYmIGdldEF0dHJpYnV0ZSh0aGlzLnJvb3QsJ3ZpcnR1YWxpemVkJykpIHsgcmV0dXJuIH1cblxuICB2YXIgZG9tID0gZXhwci5kb207XG4gIC8vIHJlbW92ZSB0aGUgcmlvdC0gcHJlZml4XG4gIHZhciBhdHRyTmFtZSA9IG5vcm1hbGl6ZUF0dHJOYW1lKGV4cHIuYXR0cik7XG4gIHZhciBpc1RvZ2dsZSA9IGNvbnRhaW5zKFtTSE9XX0RJUkVDVElWRSwgSElERV9ESVJFQ1RJVkVdLCBhdHRyTmFtZSk7XG4gIHZhciBpc1ZpcnR1YWwgPSBleHByLnJvb3QgJiYgZXhwci5yb290LnRhZ05hbWUgPT09ICdWSVJUVUFMJztcbiAgdmFyIHJlZiA9IHRoaXMuX187XG4gIHZhciBpc0Fub255bW91cyA9IHJlZi5pc0Fub255bW91cztcbiAgdmFyIHBhcmVudCA9IGRvbSAmJiAoZXhwci5wYXJlbnQgfHwgZG9tLnBhcmVudE5vZGUpO1xuICAvLyBkZXRlY3QgdGhlIHN0eWxlIGF0dHJpYnV0ZXNcbiAgdmFyIGlzU3R5bGVBdHRyID0gYXR0ck5hbWUgPT09ICdzdHlsZSc7XG4gIHZhciBpc0NsYXNzQXR0ciA9IGF0dHJOYW1lID09PSAnY2xhc3MnO1xuXG4gIHZhciB2YWx1ZTtcblxuICAvLyBpZiBpdCdzIGEgdGFnIHdlIGNvdWxkIHRvdGFsbHkgc2tpcCB0aGUgcmVzdFxuICBpZiAoZXhwci5fcmlvdF9pZCkge1xuICAgIGlmIChleHByLl9fLndhc0NyZWF0ZWQpIHtcbiAgICAgIGV4cHIudXBkYXRlKCk7XG4gICAgLy8gaWYgaXQgaGFzbid0IGJlZW4gbW91bnRlZCB5ZXQsIGRvIHRoYXQgbm93LlxuICAgIH0gZWxzZSB7XG4gICAgICBleHByLm1vdW50KCk7XG4gICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgIG1ha2VSZXBsYWNlVmlydHVhbChleHByLCBleHByLnJvb3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGlmIHRoaXMgZXhwcmVzc2lvbiBoYXMgdGhlIHVwZGF0ZSBtZXRob2QgaXQgbWVhbnMgaXQgY2FuIGhhbmRsZSB0aGUgRE9NIGNoYW5nZXMgYnkgaXRzZWxmXG4gIGlmIChleHByLnVwZGF0ZSkgeyByZXR1cm4gZXhwci51cGRhdGUoKSB9XG5cbiAgdmFyIGNvbnRleHQgPSBpc1RvZ2dsZSAmJiAhaXNBbm9ueW1vdXMgPyBpbmhlcml0UGFyZW50UHJvcHMuY2FsbCh0aGlzKSA6IHRoaXM7XG5cbiAgLy8gLi4uaXQgc2VlbXMgdG8gYmUgYSBzaW1wbGUgZXhwcmVzc2lvbiBzbyB3ZSB0cnkgdG8gY2FsY3VsYXRlIGl0cyB2YWx1ZVxuICB2YWx1ZSA9IHRtcGwoZXhwci5leHByLCBjb250ZXh0KTtcblxuICB2YXIgaGFzVmFsdWUgPSAhaXNCbGFuayh2YWx1ZSk7XG4gIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcblxuICAvLyBjb252ZXJ0IHRoZSBzdHlsZS9jbGFzcyBvYmplY3RzIHRvIHN0cmluZ3NcbiAgaWYgKGlzT2JqKSB7XG4gICAgaWYgKGlzQ2xhc3NBdHRyKSB7XG4gICAgICB2YWx1ZSA9IHRtcGwoSlNPTi5zdHJpbmdpZnkodmFsdWUpLCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGlzU3R5bGVBdHRyKSB7XG4gICAgICB2YWx1ZSA9IHN0eWxlT2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBvcmlnaW5hbCBhdHRyaWJ1dGVcbiAgaWYgKGV4cHIuYXR0ciAmJiAoIWV4cHIud2FzUGFyc2VkT25jZSB8fCAhaGFzVmFsdWUgfHwgdmFsdWUgPT09IGZhbHNlKSkge1xuICAgIC8vIHJlbW92ZSBlaXRoZXIgcmlvdC0qIGF0dHJpYnV0ZXMgb3IganVzdCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICByZW1vdmVBdHRyaWJ1dGUoZG9tLCBnZXRBdHRyaWJ1dGUoZG9tLCBleHByLmF0dHIpID8gZXhwci5hdHRyIDogYXR0ck5hbWUpO1xuICB9XG5cbiAgLy8gZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZXMgd2UgZG9uJ3QgbmVlZCB0aGUgdmFsdWVcbiAgLy8gd2UgY2FuIGNvbnZlcnQgaXQgdG8gY2hlY2tlZD10cnVlIHRvIGNoZWNrZWQ9Y2hlY2tlZFxuICBpZiAoZXhwci5ib29sKSB7IHZhbHVlID0gdmFsdWUgPyBhdHRyTmFtZSA6IGZhbHNlOyB9XG4gIGlmIChleHByLmlzUnRhZykgeyByZXR1cm4gdXBkYXRlRGF0YUlzKGV4cHIsIHRoaXMsIHZhbHVlKSB9XG4gIGlmIChleHByLndhc1BhcnNlZE9uY2UgJiYgZXhwci52YWx1ZSA9PT0gdmFsdWUpIHsgcmV0dXJuIH1cblxuICAvLyB1cGRhdGUgdGhlIGV4cHJlc3Npb24gdmFsdWVcbiAgZXhwci52YWx1ZSA9IHZhbHVlO1xuICBleHByLndhc1BhcnNlZE9uY2UgPSB0cnVlO1xuXG4gIC8vIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgKGFuZCBpdCdzIG5vdCBhIHN0eWxlIG9yIGNsYXNzIGF0dHJpYnV0ZSkgd2UgY2FuIG5vdCBkbyBtdWNoIG1vcmUgd2l0aCBpdFxuICBpZiAoaXNPYmogJiYgIWlzQ2xhc3NBdHRyICYmICFpc1N0eWxlQXR0ciAmJiAhaXNUb2dnbGUpIHsgcmV0dXJuIH1cbiAgLy8gYXZvaWQgdG8gcmVuZGVyIHVuZGVmaW5lZC9udWxsIHZhbHVlc1xuICBpZiAoIWhhc1ZhbHVlKSB7IHZhbHVlID0gJyc7IH1cblxuICAvLyB0ZXh0YXJlYSBhbmQgdGV4dCBub2RlcyBoYXZlIG5vIGF0dHJpYnV0ZSBuYW1lXG4gIGlmICghYXR0ck5hbWUpIHtcbiAgICAvLyBhYm91dCAjODE1IHcvbyByZXBsYWNlOiB0aGUgYnJvd3NlciBjb252ZXJ0cyB0aGUgdmFsdWUgdG8gYSBzdHJpbmcsXG4gICAgLy8gdGhlIGNvbXBhcmlzb24gYnkgXCI9PVwiIGRvZXMgdG9vLCBidXQgbm90IGluIHRoZSBzZXJ2ZXJcbiAgICB2YWx1ZSArPSAnJztcbiAgICAvLyB0ZXN0IGZvciBwYXJlbnQgYXZvaWRzIGVycm9yIHdpdGggaW52YWxpZCBhc3NpZ25tZW50IHRvIG5vZGVWYWx1ZVxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIC8vIGNhY2hlIHRoZSBwYXJlbnQgbm9kZSBiZWNhdXNlIHNvbWVob3cgaXQgd2lsbCBiZWNvbWUgbnVsbCBvbiBJRVxuICAgICAgLy8gb24gdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICBleHByLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICBwYXJlbnQudmFsdWUgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgIC8vICMxMTEzXG4gICAgICAgIGlmICghSUVfVkVSU0lPTikgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH0gIC8vICMxNjI1IElFIHRocm93cyBoZXJlLCBub2RlVmFsdWVcbiAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgYXZhaWxhYmxlIG9uICd1cGRhdGVkJ1xuICAgICAgZWxzZSB7IGRvbS5ub2RlVmFsdWUgPSB2YWx1ZTsgfVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG5cbiAgLy8gZXZlbnQgaGFuZGxlclxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBzZXRFdmVudEhhbmRsZXIoYXR0ck5hbWUsIHZhbHVlLCBkb20sIHRoaXMpO1xuICAvLyBzaG93IC8gaGlkZVxuICB9IGVsc2UgaWYgKGlzVG9nZ2xlKSB7XG4gICAgdG9nZ2xlVmlzaWJpbGl0eShkb20sIGF0dHJOYW1lID09PSBISURFX0RJUkVDVElWRSA/ICF2YWx1ZSA6IHZhbHVlKTtcbiAgLy8gaGFuZGxlIGF0dHJpYnV0ZXNcbiAgfSBlbHNlIHtcbiAgICBpZiAoZXhwci5ib29sKSB7XG4gICAgICBkb21bYXR0ck5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJOYW1lID09PSAndmFsdWUnICYmIGRvbS52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIGRvbS52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaGFzVmFsdWUgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUoZG9tLCBhdHRyTmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGluIGNhc2Ugb2Ygc3R5bGUgY2hhbmdlc1xuICAgIC8vIHRoZSBlbGVtZW50IHN0YXlzIGhpZGRlblxuICAgIGlmIChpc1N0eWxlQXR0ciAmJiBkb20uaGlkZGVuKSB7IHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBmYWxzZSk7IH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhbGwgdGhlIGV4cHJlc3Npb25zIGluIGEgVGFnIGluc3RhbmNlXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSB7IEFycmF5IH0gZXhwcmVzc2lvbnMgLSBleHByZXNzaW9uIHRoYXQgbXVzdCBiZSByZSBldmFsdWF0ZWRcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKGV4cHJlc3Npb25zKSB7XG4gIGVhY2goZXhwcmVzc2lvbnMsIHVwZGF0ZUV4cHJlc3Npb24uYmluZCh0aGlzKSk7XG59XG5cbi8qKlxuICogV2UgbmVlZCB0byB1cGRhdGUgb3B0cyBmb3IgdGhpcyB0YWcuIFRoYXQgcmVxdWlyZXMgdXBkYXRpbmcgdGhlIGV4cHJlc3Npb25zXG4gKiBpbiBhbnkgYXR0cmlidXRlcyBvbiB0aGUgdGFnLCBhbmQgdGhlbiBjb3B5aW5nIHRoZSByZXN1bHQgb250byBvcHRzLlxuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gaXNMb29wIC0gaXMgaXQgYSBsb29wIHRhZz9cbiAqIEBwYXJhbSAgIHsgVGFnIH0gIHBhcmVudCAtIHBhcmVudCB0YWcgbm9kZVxuICogQHBhcmFtICAgeyBCb29sZWFuIH0gIGlzQW5vbnltb3VzIC0gaXMgaXQgYSB0YWcgd2l0aG91dCBhbnkgaW1wbD8gKGEgdGFnIG5vdCByZWdpc3RlcmVkKVxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgb3B0cyAtIHRhZyBvcHRpb25zXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gIGluc3RBdHRycyAtIHRhZyBhdHRyaWJ1dGVzIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdHMoaXNMb29wLCBwYXJlbnQsIGlzQW5vbnltb3VzLCBvcHRzLCBpbnN0QXR0cnMpIHtcbiAgLy8gaXNBbm9ueW1vdXMgYGVhY2hgIHRhZ3MgdHJlYXQgYGRvbWAgYW5kIGByb290YCBkaWZmZXJlbnRseS4gSW4gdGhpcyBjYXNlXG4gIC8vIChhbmQgb25seSB0aGlzIGNhc2UpIHdlIGRvbid0IG5lZWQgdG8gZG8gdXBkYXRlT3B0cywgYmVjYXVzZSB0aGUgcmVndWxhciBwYXJzZVxuICAvLyB3aWxsIHVwZGF0ZSB0aG9zZSBhdHRycy4gUGx1cywgaXNBbm9ueW1vdXMgdGFncyBkb24ndCBuZWVkIG9wdHMgYW55d2F5XG4gIGlmIChpc0xvb3AgJiYgaXNBbm9ueW1vdXMpIHsgcmV0dXJuIH1cbiAgdmFyIGN0eCA9IGlzTG9vcCA/IGluaGVyaXRQYXJlbnRQcm9wcy5jYWxsKHRoaXMpIDogcGFyZW50IHx8IHRoaXM7XG5cbiAgZWFjaChpbnN0QXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgaWYgKGF0dHIuZXhwcikgeyB1cGRhdGVFeHByZXNzaW9uLmNhbGwoY3R4LCBhdHRyLmV4cHIpOyB9XG4gICAgLy8gbm9ybWFsaXplIHRoZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICBvcHRzW3RvQ2FtZWwoYXR0ci5uYW1lKS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpXSA9IGF0dHIuZXhwciA/IGF0dHIuZXhwci52YWx1ZSA6IGF0dHIudmFsdWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdGFnIGV4cHJlc3Npb25zIGFuZCBvcHRpb25zXG4gKiBAcGFyYW0geyBUYWcgfSB0YWcgLSB0YWcgb2JqZWN0XG4gKiBAcGFyYW0geyAqIH0gZGF0YSAtIGRhdGEgd2Ugd2FudCB0byB1c2UgdG8gZXh0ZW5kIHRoZSB0YWcgcHJvcGVydGllc1xuICogQHBhcmFtIHsgQXJyYXkgfSBleHByZXNzaW9ucyAtIGNvbXBvbmVudCBleHByZXNzaW9ucyBhcnJheVxuICogQHJldHVybnMgeyBUYWcgfSB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlKHRhZywgZGF0YSwgZXhwcmVzc2lvbnMpIHtcbiAgdmFyIF9fID0gdGFnLl9fO1xuICB2YXIgbmV4dE9wdHMgPSB7fTtcbiAgdmFyIGNhblRyaWdnZXIgPSB0YWcuaXNNb3VudGVkICYmICFfXy5za2lwQW5vbnltb3VzO1xuXG4gIC8vIGluaGVyaXQgcHJvcGVydGllcyBmcm9tIHRoZSBwYXJlbnQgdGFnXG4gIGlmIChfXy5pc0Fub255bW91cyAmJiBfXy5wYXJlbnQpIHsgZXh0ZW5kKHRhZywgX18ucGFyZW50KTsgfVxuICBleHRlbmQodGFnLCBkYXRhKTtcblxuICB1cGRhdGVPcHRzLmFwcGx5KHRhZywgW19fLmlzTG9vcCwgX18ucGFyZW50LCBfXy5pc0Fub255bW91cywgbmV4dE9wdHMsIF9fLmluc3RBdHRyc10pO1xuXG4gIGlmIChcbiAgICBjYW5UcmlnZ2VyICYmXG4gICAgdGFnLmlzTW91bnRlZCAmJlxuICAgIGlzRnVuY3Rpb24odGFnLnNob3VsZFVwZGF0ZSkgJiYgIXRhZy5zaG91bGRVcGRhdGUoZGF0YSwgbmV4dE9wdHMpXG4gICkge1xuICAgIHJldHVybiB0YWdcbiAgfVxuXG4gIGV4dGVuZCh0YWcub3B0cywgbmV4dE9wdHMpO1xuXG4gIGlmIChjYW5UcmlnZ2VyKSB7IHRhZy50cmlnZ2VyKCd1cGRhdGUnLCBkYXRhKTsgfVxuICB1cGRhdGUuY2FsbCh0YWcsIGV4cHJlc3Npb25zKTtcbiAgaWYgKGNhblRyaWdnZXIpIHsgdGFnLnRyaWdnZXIoJ3VwZGF0ZWQnKTsgfVxuXG4gIHJldHVybiB0YWdcbn1cblxuLyoqXG4gKiBHZXQgc2VsZWN0b3JzIGZvciB0YWdzXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIHRhZyBuYW1lcyB0byBzZWxlY3RcbiAqIEByZXR1cm5zIHsgU3RyaW5nIH0gc2VsZWN0b3JcbiAqL1xuZnVuY3Rpb24gcXVlcnkodGFncykge1xuICAvLyBzZWxlY3QgYWxsIHRhZ3NcbiAgaWYgKCF0YWdzKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfX1RBR19JTVBMKTtcbiAgICByZXR1cm4ga2V5cyArIHF1ZXJ5KGtleXMpXG4gIH1cblxuICByZXR1cm4gdGFnc1xuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuICEvW14tXFx3XS8udGVzdCh0KTsgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uIChsaXN0LCB0KSB7XG4gICAgICB2YXIgbmFtZSA9IHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gbGlzdCArIFwiLFtcIiArIElTX0RJUkVDVElWRSArIFwiPVxcXCJcIiArIG5hbWUgKyBcIlxcXCJdXCJcbiAgICB9LCAnJylcbn1cblxuLyoqXG4gKiBBbm90aGVyIHdheSB0byBjcmVhdGUgYSByaW90IHRhZyBhIGJpdCBtb3JlIGVzNiBmcmllbmRseVxuICogQHBhcmFtIHsgSFRNTEVsZW1lbnQgfSBlbCAtIHRhZyBET00gc2VsZWN0b3Igb3IgRE9NIG5vZGUvc1xuICogQHBhcmFtIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBsb2dpY1xuICogQHJldHVybnMgeyBUYWcgfSBuZXcgcmlvdCB0YWcgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gVGFnKGVsLCBvcHRzKSB7XG4gIC8vIGdldCB0aGUgdGFnIHByb3BlcnRpZXMgZnJvbSB0aGUgY2xhc3MgY29uc3RydWN0b3JcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gIHZhciB0bXBsID0gcmVmLnRtcGw7XG4gIHZhciBjc3MgPSByZWYuY3NzO1xuICB2YXIgYXR0cnMgPSByZWYuYXR0cnM7XG4gIHZhciBvbkNyZWF0ZSA9IHJlZi5vbkNyZWF0ZTtcbiAgLy8gcmVnaXN0ZXIgYSBuZXcgdGFnIGFuZCBjYWNoZSB0aGUgY2xhc3MgcHJvdG90eXBlXG4gIGlmICghX19UQUdfSU1QTFtuYW1lXSkge1xuICAgIHRhZyhuYW1lLCB0bXBsLCBjc3MsIGF0dHJzLCBvbkNyZWF0ZSk7XG4gICAgLy8gY2FjaGUgdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgX19UQUdfSU1QTFtuYW1lXS5jbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gIH1cblxuICAvLyBtb3VudCB0aGUgdGFnIHVzaW5nIHRoZSBjbGFzcyBpbnN0YW5jZVxuICBtb3VudCQxKGVsLCBuYW1lLCBvcHRzLCB0aGlzKTtcbiAgLy8gaW5qZWN0IHRoZSBjb21wb25lbnQgY3NzXG4gIGlmIChjc3MpIHsgc3R5bGVNYW5hZ2VyLmluamVjdCgpOyB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcmlvdCB0YWcgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBuYW1lIC0gbmFtZS9pZCBvZiB0aGUgbmV3IHJpb3QgdGFnXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgdG1wbCAtIHRhZyB0ZW1wbGF0ZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGNzcyAtIGN1c3RvbSB0YWcgY3NzXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgYXR0cnMgLSByb290IHRhZyBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSB1c2VyIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7IFN0cmluZyB9IG5hbWUvaWQgb2YgdGhlIHRhZyBqdXN0IGNyZWF0ZWRcbiAqL1xuZnVuY3Rpb24gdGFnKG5hbWUsIHRtcGwsIGNzcywgYXR0cnMsIGZuKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGF0dHJzKSkge1xuICAgIGZuID0gYXR0cnM7XG5cbiAgICBpZiAoL15bXFx3LV0rXFxzPz0vLnRlc3QoY3NzKSkge1xuICAgICAgYXR0cnMgPSBjc3M7XG4gICAgICBjc3MgPSAnJztcbiAgICB9IGVsc2VcbiAgICAgIHsgYXR0cnMgPSAnJzsgfVxuICB9XG5cbiAgaWYgKGNzcykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNzcykpXG4gICAgICB7IGZuID0gY3NzOyB9XG4gICAgZWxzZVxuICAgICAgeyBzdHlsZU1hbmFnZXIuYWRkKGNzcyk7IH1cbiAgfVxuXG4gIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIF9fVEFHX0lNUExbbmFtZV0gPSB7IG5hbWU6IG5hbWUsIHRtcGw6IHRtcGwsIGF0dHJzOiBhdHRycywgZm46IGZuIH07XG5cbiAgcmV0dXJuIG5hbWVcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcmlvdCB0YWcgaW1wbGVtZW50YXRpb24gKGZvciB1c2UgYnkgdGhlIGNvbXBpbGVyKVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIG5hbWUgLSBuYW1lL2lkIG9mIHRoZSBuZXcgcmlvdCB0YWdcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICB0bXBsIC0gdGFnIHRlbXBsYXRlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgY3NzIC0gY3VzdG9tIHRhZyBjc3NcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBhdHRycyAtIHJvb3QgdGFnIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIHVzZXIgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbmFtZS9pZCBvZiB0aGUgdGFnIGp1c3QgY3JlYXRlZFxuICovXG5mdW5jdGlvbiB0YWcyKG5hbWUsIHRtcGwsIGNzcywgYXR0cnMsIGZuKSB7XG4gIGlmIChjc3MpIHsgc3R5bGVNYW5hZ2VyLmFkZChjc3MsIG5hbWUpOyB9XG5cbiAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICByZXR1cm4gbmFtZVxufVxuXG4vKipcbiAqIE1vdW50IGEgdGFnIHVzaW5nIGEgc3BlY2lmaWMgdGFnIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gICB7ICogfSBzZWxlY3RvciAtIHRhZyBET00gc2VsZWN0b3Igb3IgRE9NIG5vZGUvc1xuICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIG5hbWVcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBsb2dpY1xuICogQHJldHVybnMgeyBBcnJheSB9IG5ldyB0YWdzIGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiBtb3VudChzZWxlY3RvciwgdGFnTmFtZSwgb3B0cykge1xuICB2YXIgdGFncyA9IFtdO1xuICB2YXIgZWxlbSwgYWxsVGFnczs7XG5cbiAgZnVuY3Rpb24gcHVzaFRhZ3NUbyhyb290KSB7XG4gICAgaWYgKHJvb3QudGFnTmFtZSkge1xuICAgICAgdmFyIHJpb3RUYWcgPSBnZXRBdHRyaWJ1dGUocm9vdCwgSVNfRElSRUNUSVZFKSwgdGFnOztcblxuICAgICAgLy8gaGF2ZSB0YWdOYW1lPyBmb3JjZSByaW90LXRhZyB0byBiZSB0aGUgc2FtZVxuICAgICAgaWYgKHRhZ05hbWUgJiYgcmlvdFRhZyAhPT0gdGFnTmFtZSkge1xuICAgICAgICByaW90VGFnID0gdGFnTmFtZTtcbiAgICAgICAgc2V0QXR0cmlidXRlKHJvb3QsIElTX0RJUkVDVElWRSwgdGFnTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRhZyA9IG1vdW50JDEocm9vdCwgcmlvdFRhZyB8fCByb290LnRhZ05hbWUudG9Mb3dlckNhc2UoKSwgb3B0cyk7XG5cbiAgICAgIGlmICh0YWcpXG4gICAgICAgIHsgdGFncy5wdXNoKHRhZyk7IH1cbiAgICB9IGVsc2UgaWYgKHJvb3QubGVuZ3RoKVxuICAgICAgeyBlYWNoKHJvb3QsIHB1c2hUYWdzVG8pOyB9IC8vIGFzc3VtZSBub2RlTGlzdFxuICB9XG5cbiAgLy8gaW5qZWN0IHN0eWxlcyBpbnRvIERPTVxuICBzdHlsZU1hbmFnZXIuaW5qZWN0KCk7XG5cbiAgaWYgKGlzT2JqZWN0KHRhZ05hbWUpKSB7XG4gICAgb3B0cyA9IHRhZ05hbWU7XG4gICAgdGFnTmFtZSA9IDA7XG4gIH1cblxuICAvLyBjcmF3bCB0aGUgRE9NIHRvIGZpbmQgdGhlIHRhZ1xuICBpZiAoaXNTdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3RvciA9PT0gJyonID9cbiAgICAgIC8vIHNlbGVjdCBhbGwgcmVnaXN0ZXJlZCB0YWdzXG4gICAgICAvLyAmIHRhZ3MgZm91bmQgd2l0aCB0aGUgcmlvdC10YWcgYXR0cmlidXRlIHNldFxuICAgICAgYWxsVGFncyA9IHF1ZXJ5KCkgOlxuICAgICAgLy8gb3IganVzdCB0aGUgb25lcyBuYW1lZCBsaWtlIHRoZSBzZWxlY3RvclxuICAgICAgc2VsZWN0b3IgKyBxdWVyeShzZWxlY3Rvci5zcGxpdCgvLCAqLykpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRvIHBhc3MgYWx3YXlzIGEgc2VsZWN0b3JcbiAgICAvLyB0byB0aGUgcXVlcnlTZWxlY3RvckFsbCBmdW5jdGlvblxuICAgIGVsZW0gPSBzZWxlY3RvciA/ICQkKHNlbGVjdG9yKSA6IFtdO1xuICB9XG4gIGVsc2VcbiAgICAvLyBwcm9iYWJseSB5b3UgaGF2ZSBwYXNzZWQgYWxyZWFkeSBhIHRhZyBvciBhIE5vZGVMaXN0XG4gICAgeyBlbGVtID0gc2VsZWN0b3I7IH1cblxuICAvLyBzZWxlY3QgYWxsIHRoZSByZWdpc3RlcmVkIGFuZCBtb3VudCB0aGVtIGluc2lkZSB0aGVpciByb290IGVsZW1lbnRzXG4gIGlmICh0YWdOYW1lID09PSAnKicpIHtcbiAgICAvLyBnZXQgYWxsIGN1c3RvbSB0YWdzXG4gICAgdGFnTmFtZSA9IGFsbFRhZ3MgfHwgcXVlcnkoKTtcbiAgICAvLyBpZiB0aGUgcm9vdCBlbHMgaXQncyBqdXN0IGEgc2luZ2xlIHRhZ1xuICAgIGlmIChlbGVtLnRhZ05hbWUpXG4gICAgICB7IGVsZW0gPSAkJCh0YWdOYW1lLCBlbGVtKTsgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gc2VsZWN0IGFsbCB0aGUgY2hpbGRyZW4gZm9yIGFsbCB0aGUgZGlmZmVyZW50IHJvb3QgZWxlbWVudHNcbiAgICAgIHZhciBub2RlTGlzdCA9IFtdO1xuXG4gICAgICBlYWNoKGVsZW0sIGZ1bmN0aW9uIChfZWwpIHsgcmV0dXJuIG5vZGVMaXN0LnB1c2goJCQodGFnTmFtZSwgX2VsKSk7IH0pO1xuXG4gICAgICBlbGVtID0gbm9kZUxpc3Q7XG4gICAgfVxuICAgIC8vIGdldCByaWQgb2YgdGhlIHRhZ05hbWVcbiAgICB0YWdOYW1lID0gMDtcbiAgfVxuXG4gIHB1c2hUYWdzVG8oZWxlbSk7XG5cbiAgcmV0dXJuIHRhZ3Ncbn1cblxuLy8gQ3JlYXRlIGEgbWl4aW4gdGhhdCBjb3VsZCBiZSBnbG9iYWxseSBzaGFyZWQgYWNyb3NzIGFsbCB0aGUgdGFnc1xudmFyIG1peGlucyA9IHt9O1xudmFyIGdsb2JhbHMgPSBtaXhpbnNbR0xPQkFMX01JWElOXSA9IHt9O1xudmFyIG1peGluc19pZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlL1JldHVybiBhIG1peGluIGJ5IGl0cyBuYW1lXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICBuYW1lIC0gbWl4aW4gbmFtZSAoZ2xvYmFsIG1peGluIGlmIG9iamVjdClcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gIG1peCAtIG1peGluIGxvZ2ljXG4gKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBnIC0gaXMgZ2xvYmFsP1xuICogQHJldHVybnMgeyBPYmplY3QgfSAgdGhlIG1peGluIGxvZ2ljXG4gKi9cbmZ1bmN0aW9uIG1peGluKG5hbWUsIG1peCwgZykge1xuICAvLyBVbm5hbWVkIGdsb2JhbFxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBtaXhpbigoXCJfX1wiICsgKG1peGluc19pZCsrKSArIFwiX19cIiksIG5hbWUsIHRydWUpO1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0b3JlID0gZyA/IGdsb2JhbHMgOiBtaXhpbnM7XG5cbiAgLy8gR2V0dGVyXG4gIGlmICghbWl4KSB7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHN0b3JlW25hbWVdKSlcbiAgICAgIHsgdGhyb3cgbmV3IEVycm9yKChcIlVucmVnaXN0ZXJlZCBtaXhpbjogXCIgKyBuYW1lKSkgfVxuXG4gICAgcmV0dXJuIHN0b3JlW25hbWVdXG4gIH1cblxuICAvLyBTZXR0ZXJcbiAgc3RvcmVbbmFtZV0gPSBpc0Z1bmN0aW9uKG1peCkgP1xuICAgIGV4dGVuZChtaXgucHJvdG90eXBlLCBzdG9yZVtuYW1lXSB8fCB7fSkgJiYgbWl4IDpcbiAgICBleHRlbmQoc3RvcmVbbmFtZV0gfHwge30sIG1peCk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFsbCB0aGUgdGFncyBpbnN0YW5jZXMgY3JlYXRlZFxuICogQHJldHVybnMgeyBBcnJheSB9IGFsbCB0aGUgdGFncyBpbnN0YW5jZXNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlJDEoKSB7XG4gIHJldHVybiBlYWNoKF9fVEFHU19DQUNIRSwgZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnLnVwZGF0ZSgpOyB9KVxufVxuXG5mdW5jdGlvbiB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgX19UQUdfSU1QTFtuYW1lXSA9IG51bGw7XG59XG5cbnZhciB2ZXJzaW9uID0gJ3YzLjkuMCc7XG5cblxudmFyIGNvcmUgPSBPYmplY3QuZnJlZXplKHtcblx0VGFnOiBUYWcsXG5cdHRhZzogdGFnLFxuXHR0YWcyOiB0YWcyLFxuXHRtb3VudDogbW91bnQsXG5cdG1peGluOiBtaXhpbixcblx0dXBkYXRlOiB1cGRhdGUkMSxcblx0dW5yZWdpc3RlcjogdW5yZWdpc3Rlcixcblx0dmVyc2lvbjogdmVyc2lvblxufSk7XG5cbi8qKlxuICogQWRkIGEgbWl4aW4gdG8gdGhpcyB0YWdcbiAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudE1peGluKHRhZyQkMSkge1xuICB2YXIgbWl4aW5zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIG1peGluc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICBlYWNoKG1peGlucywgZnVuY3Rpb24gKG1peCkge1xuICAgIHZhciBpbnN0YW5jZTtcbiAgICB2YXIgb2JqO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgLy8gcHJvcGVydGllcyBibGFja2xpc3RlZCBhbmQgd2lsbCBub3QgYmUgYm91bmQgdG8gdGhlIHRhZyBpbnN0YW5jZVxuICAgIHZhciBwcm9wc0JsYWNrbGlzdCA9IFsnaW5pdCcsICdfX3Byb3RvX18nXTtcblxuICAgIG1peCA9IGlzU3RyaW5nKG1peCkgPyBtaXhpbihtaXgpIDogbWl4O1xuXG4gICAgLy8gY2hlY2sgaWYgdGhlIG1peGluIGlzIGEgZnVuY3Rpb25cbiAgICBpZiAoaXNGdW5jdGlvbihtaXgpKSB7XG4gICAgICAvLyBjcmVhdGUgdGhlIG5ldyBtaXhpbiBpbnN0YW5jZVxuICAgICAgaW5zdGFuY2UgPSBuZXcgbWl4KCk7XG4gICAgfSBlbHNlIHsgaW5zdGFuY2UgPSBtaXg7IH1cblxuICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSk7XG5cbiAgICAvLyBidWlsZCBtdWx0aWxldmVsIHByb3RvdHlwZSBpbmhlcml0YW5jZSBjaGFpbiBwcm9wZXJ0eSBsaXN0XG4gICAgZG8geyBwcm9wcyA9IHByb3BzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmogfHwgaW5zdGFuY2UpKTsgfVxuICAgIHdoaWxlIChvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqIHx8IGluc3RhbmNlKSlcblxuICAgIC8vIGxvb3AgdGhlIGtleXMgaW4gdGhlIGZ1bmN0aW9uIHByb3RvdHlwZSBvciB0aGUgYWxsIG9iamVjdCBrZXlzXG4gICAgZWFjaChwcm9wcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgLy8gYmluZCBtZXRob2RzIHRvIHRhZ1xuICAgICAgLy8gYWxsb3cgbWl4aW5zIHRvIG92ZXJyaWRlIG90aGVyIHByb3BlcnRpZXMvcGFyZW50IG1peGluc1xuICAgICAgaWYgKCFjb250YWlucyhwcm9wc0JsYWNrbGlzdCwga2V5KSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgZ2V0dGVycy9zZXR0ZXJzXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0UHJvcERlc2NyaXB0b3IoaW5zdGFuY2UsIGtleSkgfHwgZ2V0UHJvcERlc2NyaXB0b3IocHJvdG8sIGtleSk7XG4gICAgICAgIHZhciBoYXNHZXR0ZXJTZXR0ZXIgPSBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCk7XG5cbiAgICAgICAgLy8gYXBwbHkgbWV0aG9kIG9ubHkgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBvbiB0aGUgaW5zdGFuY2VcbiAgICAgICAgaWYgKCF0YWckJDEuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBoYXNHZXR0ZXJTZXR0ZXIpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFnJCQxLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhZyQkMVtrZXldID0gaXNGdW5jdGlvbihpbnN0YW5jZVtrZXldKSA/XG4gICAgICAgICAgICBpbnN0YW5jZVtrZXldLmJpbmQodGFnJCQxKSA6XG4gICAgICAgICAgICBpbnN0YW5jZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpbml0IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5XG4gICAgaWYgKGluc3RhbmNlLmluaXQpXG4gICAgICB7IGluc3RhbmNlLmluaXQuYmluZCh0YWckJDEpKHRhZyQkMS5vcHRzKTsgfVxuICB9KTtcblxuICByZXR1cm4gdGFnJCQxXG59XG5cbi8qKlxuICogTW92ZSB0aGUgcG9zaXRpb24gb2YgYSBjdXN0b20gdGFnIGluIGl0cyBwYXJlbnQgdGFnXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGFnTmFtZSAtIGtleSB3aGVyZSB0aGUgdGFnIHdhcyBzdG9yZWRcbiAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gbmV3UG9zIC0gaW5kZXggd2hlcmUgdGhlIG5ldyB0YWcgd2lsbCBiZSBzdG9yZWRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkKHRhZ05hbWUsIG5ld1Bvcykge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIHZhciB0YWdzO1xuICAvLyBubyBwYXJlbnQgbm8gbW92ZVxuICBpZiAoIXBhcmVudCkgeyByZXR1cm4gfVxuXG4gIHRhZ3MgPSBwYXJlbnQudGFnc1t0YWdOYW1lXTtcblxuICBpZiAoaXNBcnJheSh0YWdzKSlcbiAgICB7IHRhZ3Muc3BsaWNlKG5ld1BvcywgMCwgdGFncy5zcGxpY2UodGFncy5pbmRleE9mKHRoaXMpLCAxKVswXSk7IH1cbiAgZWxzZSB7IGFycmF5aXNoQWRkKHBhcmVudC50YWdzLCB0YWdOYW1lLCB0aGlzKTsgfVxufVxuXG4vKipcbiAqIE1vdmUgdmlydHVhbCB0YWcgYW5kIGFsbCBjaGlsZCBub2Rlc1xuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0geyBOb2RlIH0gc3JjICAtIHRoZSBub2RlIHRoYXQgd2lsbCBkbyB0aGUgaW5zZXJ0aW5nXG4gKiBAcGFyYW0geyBUYWcgfSB0YXJnZXQgLSBpbnNlcnQgYmVmb3JlIHRoaXMgdGFnJ3MgZmlyc3QgY2hpbGRcbiAqL1xuZnVuY3Rpb24gbW92ZVZpcnR1YWwoc3JjLCB0YXJnZXQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVsID0gdGhpcy5fXy5oZWFkO1xuICB2YXIgc2liO1xuICB2YXIgZnJhZyA9IGNyZWF0ZUZyYWdtZW50KCk7XG5cbiAgd2hpbGUgKGVsKSB7XG4gICAgc2liID0gZWwubmV4dFNpYmxpbmc7XG4gICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gICAgZWwgPSBzaWI7XG4gICAgaWYgKGVsID09PSB0aGlzJDEuX18udGFpbCkge1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICBzcmMuaW5zZXJ0QmVmb3JlKGZyYWcsIHRhcmdldC5fXy5oZWFkKTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgaXRlbSBsb29wZWQgaW50byBhbiBvYmplY3QgdXNlZCB0byBleHRlbmQgdGhlIGNoaWxkIHRhZyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGV4cHIgLSBvYmplY3QgY29udGFpbmluZyB0aGUga2V5cyB1c2VkIHRvIGV4dGVuZCB0aGUgY2hpbGRyZW4gdGFnc1xuICogQHBhcmFtICAgeyAqIH0ga2V5IC0gdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBuZXcgb2JqZWN0IHJldHVybmVkXG4gKiBAcGFyYW0gICB7ICogfSB2YWwgLSB2YWx1ZSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gYmFzZSAtIHByb3RvdHlwZSBvYmplY3QgZm9yIHRoZSBuZXcgaXRlbVxuICogQHJldHVybnMgeyBPYmplY3QgfSAtIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCBpdGVtXG4gKlxuICogVGhlIHZhcmlhYmxlcyAna2V5JyBhbmQgJ3ZhbCcgYXJlIGFyYml0cmFyeS5cbiAqIFRoZXkgZGVwZW5kIG9uIHRoZSBjb2xsZWN0aW9uIHR5cGUgbG9vcGVkIChBcnJheSwgT2JqZWN0KVxuICogYW5kIG9uIHRoZSBleHByZXNzaW9uIHVzZWQgb24gdGhlIGVhY2ggdGFnXG4gKlxuICovXG5mdW5jdGlvbiBta2l0ZW0oZXhwciwga2V5LCB2YWwsIGJhc2UpIHtcbiAgdmFyIGl0ZW0gPSBiYXNlID8gY3JlYXRlKGJhc2UpIDoge307XG4gIGl0ZW1bZXhwci5rZXldID0ga2V5O1xuICBpZiAoZXhwci5wb3MpIHsgaXRlbVtleHByLnBvc10gPSB2YWw7IH1cbiAgcmV0dXJuIGl0ZW1cbn1cblxuLyoqXG4gKiBVbm1vdW50IHRoZSByZWR1bmRhbnQgdGFnc1xuICogQHBhcmFtICAgeyBBcnJheSB9IGl0ZW1zIC0gYXJyYXkgY29udGFpbmluZyB0aGUgY3VycmVudCBpdGVtcyB0byBsb29wXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBjaGlsZHJlbiB0YWdzXG4gKi9cbmZ1bmN0aW9uIHVubW91bnRSZWR1bmRhbnQoaXRlbXMsIHRhZ3MpIHtcbiAgdmFyIGkgPSB0YWdzLmxlbmd0aDtcbiAgdmFyIGogPSBpdGVtcy5sZW5ndGg7XG5cbiAgd2hpbGUgKGkgPiBqKSB7XG4gICAgaS0tO1xuICAgIHJlbW92ZS5hcHBseSh0YWdzW2ldLCBbdGFncywgaV0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBSZW1vdmUgYSBjaGlsZCB0YWdcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtICAgeyBBcnJheSB9IHRhZ3MgLSB0YWdzIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gaSAtIGluZGV4IG9mIHRoZSB0YWcgdG8gcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSh0YWdzLCBpKSB7XG4gIHRhZ3Muc3BsaWNlKGksIDEpO1xuICB0aGlzLnVubW91bnQoKTtcbiAgYXJyYXlpc2hSZW1vdmUodGhpcy5wYXJlbnQsIHRoaXMsIHRoaXMuX18udGFnTmFtZSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogTW92ZSB0aGUgbmVzdGVkIGN1c3RvbSB0YWdzIGluIG5vbiBjdXN0b20gbG9vcCB0YWdzXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gaSAtIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxvb3AgdGFnXG4gKi9cbmZ1bmN0aW9uIG1vdmVOZXN0ZWRUYWdzKGkpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZWFjaChPYmplY3Qua2V5cyh0aGlzLnRhZ3MpLCBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIG1vdmVDaGlsZC5hcHBseSh0aGlzJDEudGFnc1t0YWdOYW1lXSwgW3RhZ05hbWUsIGldKTtcbiAgfSk7XG59XG5cbi8qKlxuICogTW92ZSBhIGNoaWxkIHRhZ1xuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gcm9vdCAtIGRvbSBub2RlIGNvbnRhaW5pbmcgYWxsIHRoZSBsb29wIGNoaWxkcmVuXG4gKiBAcGFyYW0gICB7IFRhZyB9IG5leHRUYWcgLSBpbnN0YW5jZSBvZiB0aGUgbmV4dCB0YWcgcHJlY2VkaW5nIHRoZSBvbmUgd2Ugd2FudCB0byBtb3ZlXG4gKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1ZpcnR1YWwgLSBpcyBpdCBhIHZpcnR1YWwgdGFnP1xuICovXG5mdW5jdGlvbiBtb3ZlKHJvb3QsIG5leHRUYWcsIGlzVmlydHVhbCkge1xuICBpZiAoaXNWaXJ0dWFsKVxuICAgIHsgbW92ZVZpcnR1YWwuYXBwbHkodGhpcywgW3Jvb3QsIG5leHRUYWddKTsgfVxuICBlbHNlXG4gICAgeyBzYWZlSW5zZXJ0KHJvb3QsIHRoaXMucm9vdCwgbmV4dFRhZy5yb290KTsgfVxufVxuXG4vKipcbiAqIEluc2VydCBhbmQgbW91bnQgYSBjaGlsZCB0YWdcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBkb20gbm9kZSBjb250YWluaW5nIGFsbCB0aGUgbG9vcCBjaGlsZHJlblxuICogQHBhcmFtICAgeyBUYWcgfSBuZXh0VGFnIC0gaW5zdGFuY2Ugb2YgdGhlIG5leHQgdGFnIHByZWNlZGluZyB0aGUgb25lIHdlIHdhbnQgdG8gaW5zZXJ0XG4gKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1ZpcnR1YWwgLSBpcyBpdCBhIHZpcnR1YWwgdGFnP1xuICovXG5mdW5jdGlvbiBpbnNlcnQocm9vdCwgbmV4dFRhZywgaXNWaXJ0dWFsKSB7XG4gIGlmIChpc1ZpcnR1YWwpXG4gICAgeyBtYWtlVmlydHVhbC5hcHBseSh0aGlzLCBbcm9vdCwgbmV4dFRhZ10pOyB9XG4gIGVsc2VcbiAgICB7IHNhZmVJbnNlcnQocm9vdCwgdGhpcy5yb290LCBuZXh0VGFnLnJvb3QpOyB9XG59XG5cbi8qKlxuICogQXBwZW5kIGEgbmV3IHRhZyBpbnRvIHRoZSBET01cbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSBkb20gbm9kZSBjb250YWluaW5nIGFsbCB0aGUgbG9vcCBjaGlsZHJlblxuICogQHBhcmFtICAgeyBCb29sZWFuIH0gaXNWaXJ0dWFsIC0gaXMgaXQgYSB2aXJ0dWFsIHRhZz9cbiAqL1xuZnVuY3Rpb24gYXBwZW5kKHJvb3QsIGlzVmlydHVhbCkge1xuICBpZiAoaXNWaXJ0dWFsKVxuICAgIHsgbWFrZVZpcnR1YWwuY2FsbCh0aGlzLCByb290KTsgfVxuICBlbHNlXG4gICAgeyByb290LmFwcGVuZENoaWxkKHRoaXMucm9vdCk7IH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHZhbHVlIHdlIHdhbnQgdG8gdXNlIHRvIGxvb2t1cCB0aGUgcG9zdGlvbiBvZiBvdXIgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gIGtleUF0dHIgICAgICAgICAtIGxvb2t1cCBzdHJpbmcgb3IgZXhwcmVzc2lvblxuICogQHBhcmFtICAgeyAqIH0gICAgICAgb3JpZ2luYWxJdGVtICAgIC0gb3JpZ2luYWwgaXRlbSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9ICBrZXllZEl0ZW0gICAgICAgLSBvYmplY3QgY3JlYXRlZCBieSByaW90IHZpYSB7IGl0ZW0sIGkgaW4gY29sbGVjdGlvbiB9XG4gKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBoYXNLZXlBdHRyRXhwciAgLSBmbGFnIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGtleSBpcyBhbiBleHByZXNzaW9uXG4gKiBAcmV0dXJucyB7ICogfSB2YWx1ZSB0aGF0IHdlIHdpbGwgdXNlIHRvIGZpZ3VyZSBvdXQgdGhlIGl0ZW0gcG9zaXRpb24gdmlhIGNvbGxlY3Rpb24uaW5kZXhPZlxuICovXG5mdW5jdGlvbiBnZXRJdGVtSWQoa2V5QXR0ciwgb3JpZ2luYWxJdGVtLCBrZXllZEl0ZW0sIGhhc0tleUF0dHJFeHByKSB7XG4gIGlmIChrZXlBdHRyKSB7XG4gICAgcmV0dXJuIGhhc0tleUF0dHJFeHByID8gIHRtcGwoa2V5QXR0ciwga2V5ZWRJdGVtKSA6ICBvcmlnaW5hbEl0ZW1ba2V5QXR0cl1cbiAgfVxuXG4gIHJldHVybiBvcmlnaW5hbEl0ZW1cbn1cblxuLyoqXG4gKiBNYW5hZ2UgdGFncyBoYXZpbmcgdGhlICdlYWNoJ1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIERPTSBub2RlIHdlIG5lZWQgdG8gbG9vcFxuICogQHBhcmFtICAgeyBUYWcgfSBwYXJlbnQgLSBwYXJlbnQgdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBkb20gbm9kZSBpcyBjb250YWluZWRcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXhwciAtIHN0cmluZyBjb250YWluZWQgaW4gdGhlICdlYWNoJyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgZWFjaCBsb29wXG4gKi9cbmZ1bmN0aW9uIF9lYWNoKGRvbSwgcGFyZW50LCBleHByKSB7XG4gIHZhciBtdXN0UmVvcmRlciA9IHR5cGVvZiBnZXRBdHRyaWJ1dGUoZG9tLCBMT09QX05PX1JFT1JERVJfRElSRUNUSVZFKSAhPT0gVF9TVFJJTkcgfHwgcmVtb3ZlQXR0cmlidXRlKGRvbSwgTE9PUF9OT19SRU9SREVSX0RJUkVDVElWRSk7XG4gIHZhciBrZXlBdHRyID0gZ2V0QXR0cmlidXRlKGRvbSwgS0VZX0RJUkVDVElWRSk7XG4gIHZhciBoYXNLZXlBdHRyRXhwciA9IGtleUF0dHIgPyB0bXBsLmhhc0V4cHIoa2V5QXR0cikgOiBmYWxzZTtcbiAgdmFyIHRhZ05hbWUgPSBnZXROYW1lKGRvbSk7XG4gIHZhciBpbXBsID0gX19UQUdfSU1QTFt0YWdOYW1lXTtcbiAgdmFyIHBhcmVudE5vZGUgPSBkb20ucGFyZW50Tm9kZTtcbiAgdmFyIHBsYWNlaG9sZGVyID0gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKTtcbiAgdmFyIGNoaWxkID0gZ2V0KGRvbSk7XG4gIHZhciBpZkV4cHIgPSBnZXRBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpO1xuICB2YXIgdGFncyA9IFtdO1xuICB2YXIgaXNMb29wID0gdHJ1ZTtcbiAgdmFyIGlubmVySFRNTCA9IGRvbS5pbm5lckhUTUw7XG4gIHZhciBpc0Fub255bW91cyA9ICFfX1RBR19JTVBMW3RhZ05hbWVdO1xuICB2YXIgaXNWaXJ0dWFsID0gZG9tLnRhZ05hbWUgPT09ICdWSVJUVUFMJztcbiAgdmFyIG9sZEl0ZW1zID0gW107XG4gIHZhciBoYXNLZXlzO1xuXG4gIC8vIHJlbW92ZSB0aGUgZWFjaCBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCB0YWdcbiAgcmVtb3ZlQXR0cmlidXRlKGRvbSwgTE9PUF9ESVJFQ1RJVkUpO1xuICByZW1vdmVBdHRyaWJ1dGUoZG9tLCBLRVlfRElSRUNUSVZFKTtcblxuICAvLyBwYXJzZSB0aGUgZWFjaCBleHByZXNzaW9uXG4gIGV4cHIgPSB0bXBsLmxvb3BLZXlzKGV4cHIpO1xuICBleHByLmlzTG9vcCA9IHRydWU7XG5cbiAgaWYgKGlmRXhwcikgeyByZW1vdmVBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpOyB9XG5cbiAgLy8gaW5zZXJ0IGEgbWFya2VkIHdoZXJlIHRoZSBsb29wIHRhZ3Mgd2lsbCBiZSBpbmplY3RlZFxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShwbGFjZWhvbGRlciwgZG9tKTtcbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuXG4gIGV4cHIudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlRWFjaCgpIHtcbiAgICAvLyBnZXQgdGhlIG5ldyBpdGVtcyBjb2xsZWN0aW9uXG4gICAgZXhwci52YWx1ZSA9IHRtcGwoZXhwci52YWwsIHBhcmVudCk7XG5cbiAgICB2YXIgaXRlbXMgPSBleHByLnZhbHVlO1xuICAgIHZhciBmcmFnID0gY3JlYXRlRnJhZ21lbnQoKTtcbiAgICB2YXIgaXNPYmplY3QgPSAhaXNBcnJheShpdGVtcykgJiYgIWlzU3RyaW5nKGl0ZW1zKTtcbiAgICB2YXIgcm9vdCA9IHBsYWNlaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgdmFyIHRtcEl0ZW1zID0gW107XG5cbiAgICAvLyBpZiB0aGlzIERPTSB3YXMgcmVtb3ZlZCB0aGUgdXBkYXRlIGhlcmUgaXMgdXNlbGVzc1xuICAgIC8vIHRoaXMgY29uZGl0aW9uIGZpeGVzIGFsc28gYSB3ZWlyZCBhc3luYyBpc3N1ZSBvbiBJRSBpbiBvdXIgdW5pdCB0ZXN0XG4gICAgaWYgKCFyb290KSB7IHJldHVybiB9XG5cbiAgICAvLyBvYmplY3QgbG9vcC4gYW55IGNoYW5nZXMgY2F1c2UgZnVsbCByZWRyYXdcbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIGhhc0tleXMgPSBpdGVtcyB8fCBmYWxzZTtcbiAgICAgIGl0ZW1zID0gaGFzS2V5cyA/XG4gICAgICAgIE9iamVjdC5rZXlzKGl0ZW1zKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbWtpdGVtKGV4cHIsIGl0ZW1zW2tleV0sIGtleSk7IH0pIDogW107XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0tleXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaWZFeHByKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBpZiAoZXhwci5rZXkgJiYgIWlzT2JqZWN0KVxuICAgICAgICAgIHsgcmV0dXJuICEhdG1wbChpZkV4cHIsIG1raXRlbShleHByLCBpdGVtLCBpLCBwYXJlbnQpKSB9XG5cbiAgICAgICAgcmV0dXJuICEhdG1wbChpZkV4cHIsIGV4dGVuZChjcmVhdGUocGFyZW50KSwgaXRlbSkpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBsb29wIGFsbCB0aGUgbmV3IGl0ZW1zXG4gICAgZWFjaChpdGVtcywgZnVuY3Rpb24gKF9pdGVtLCBpKSB7XG4gICAgICB2YXIgaXRlbSA9ICFoYXNLZXlzICYmIGV4cHIua2V5ID8gbWtpdGVtKGV4cHIsIF9pdGVtLCBpKSA6IF9pdGVtO1xuICAgICAgdmFyIGl0ZW1JZCA9IGdldEl0ZW1JZChrZXlBdHRyLCBfaXRlbSwgaXRlbSwgaGFzS2V5QXR0ckV4cHIpO1xuICAgICAgLy8gcmVvcmRlciBvbmx5IGlmIHRoZSBpdGVtcyBhcmUgb2JqZWN0c1xuICAgICAgdmFyIGRvUmVvcmRlciA9IG11c3RSZW9yZGVyICYmIHR5cGVvZiBfaXRlbSA9PT0gVF9PQkpFQ1QgJiYgIWhhc0tleXM7XG4gICAgICB2YXIgb2xkUG9zID0gb2xkSXRlbXMuaW5kZXhPZihpdGVtSWQpO1xuICAgICAgdmFyIGlzTmV3ID0gb2xkUG9zID09PSAtMTtcbiAgICAgIHZhciBwb3MgPSAhaXNOZXcgJiYgZG9SZW9yZGVyID8gb2xkUG9zIDogaTtcbiAgICAgIC8vIGRvZXMgYSB0YWcgZXhpc3QgaW4gdGhpcyBwb3NpdGlvbj9cbiAgICAgIHZhciB0YWcgPSB0YWdzW3Bvc107XG4gICAgICB2YXIgbXVzdEFwcGVuZCA9IGkgPj0gb2xkSXRlbXMubGVuZ3RoO1xuICAgICAgdmFyIG11c3RDcmVhdGUgPSAgZG9SZW9yZGVyICYmIGlzTmV3IHx8ICFkb1Jlb3JkZXIgJiYgIXRhZztcblxuICAgICAgLy8gbmV3IHRhZ1xuICAgICAgaWYgKG11c3RDcmVhdGUpIHtcbiAgICAgICAgdGFnID0gY3JlYXRlVGFnKGltcGwsIHtcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICBpc0xvb3A6IGlzTG9vcCxcbiAgICAgICAgICBpc0Fub255bW91czogaXNBbm9ueW1vdXMsXG4gICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICByb290OiBkb20uY2xvbmVOb2RlKGlzQW5vbnltb3VzKSxcbiAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICB9LCBpbm5lckhUTUwpO1xuXG4gICAgICAgIC8vIG1vdW50IHRoZSB0YWdcbiAgICAgICAgdGFnLm1vdW50KCk7XG5cbiAgICAgICAgaWYgKG11c3RBcHBlbmQpXG4gICAgICAgICAgeyBhcHBlbmQuYXBwbHkodGFnLCBbZnJhZyB8fCByb290LCBpc1ZpcnR1YWxdKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBpbnNlcnQuYXBwbHkodGFnLCBbcm9vdCwgdGFnc1tpXSwgaXNWaXJ0dWFsXSk7IH1cblxuICAgICAgICBpZiAoIW11c3RBcHBlbmQpIHsgb2xkSXRlbXMuc3BsaWNlKGksIDAsIGl0ZW0pOyB9XG4gICAgICAgIHRhZ3Muc3BsaWNlKGksIDAsIHRhZyk7XG4gICAgICAgIGlmIChjaGlsZCkgeyBhcnJheWlzaEFkZChwYXJlbnQudGFncywgdGFnTmFtZSwgdGFnLCB0cnVlKTsgfVxuICAgICAgfSBlbHNlIGlmIChwb3MgIT09IGkgJiYgZG9SZW9yZGVyKSB7XG4gICAgICAgIC8vIG1vdmVcbiAgICAgICAgaWYgKGtleUF0dHIgfHwgY29udGFpbnMoaXRlbXMsIG9sZEl0ZW1zW3Bvc10pKSB7XG4gICAgICAgICAgbW92ZS5hcHBseSh0YWcsIFtyb290LCB0YWdzW2ldLCBpc1ZpcnR1YWxdKTtcbiAgICAgICAgICAvLyBtb3ZlIHRoZSBvbGQgdGFnIGluc3RhbmNlXG4gICAgICAgICAgdGFncy5zcGxpY2UoaSwgMCwgdGFncy5zcGxpY2UocG9zLCAxKVswXSk7XG4gICAgICAgICAgLy8gbW92ZSB0aGUgb2xkIGl0ZW1cbiAgICAgICAgICBvbGRJdGVtcy5zcGxpY2UoaSwgMCwgb2xkSXRlbXMuc3BsaWNlKHBvcywgMSlbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb3NpdGlvbiBhdHRyaWJ1dGUgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmIChleHByLnBvcykgeyB0YWdbZXhwci5wb3NdID0gaTsgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBsb29wIHRhZ3MgYXJlIG5vdCBjdXN0b21cbiAgICAgICAgLy8gd2UgbmVlZCB0byBtb3ZlIGFsbCB0aGVpciBjdXN0b20gdGFncyBpbnRvIHRoZSByaWdodCBwb3NpdGlvblxuICAgICAgICBpZiAoIWNoaWxkICYmIHRhZy50YWdzKSB7IG1vdmVOZXN0ZWRUYWdzLmNhbGwodGFnLCBpKTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBjYWNoZSB0aGUgb3JpZ2luYWwgaXRlbSB0byB1c2UgaXQgaW4gdGhlIGV2ZW50cyBib3VuZCB0byB0aGlzIG5vZGVcbiAgICAgIC8vIGFuZCBpdHMgY2hpbGRyZW5cbiAgICAgIGV4dGVuZCh0YWcuX18sIHtcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICB9KTtcblxuICAgICAgdG1wSXRlbXNbaV0gPSBpdGVtSWQ7XG5cbiAgICAgIGlmICghbXVzdENyZWF0ZSkgeyB0YWcudXBkYXRlKGl0ZW0pOyB9XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgdGhlIHJlZHVuZGFudCB0YWdzXG4gICAgdW5tb3VudFJlZHVuZGFudChpdGVtcywgdGFncyk7XG5cbiAgICAvLyBjbG9uZSB0aGUgaXRlbXMgYXJyYXlcbiAgICBvbGRJdGVtcyA9IHRtcEl0ZW1zLnNsaWNlKCk7XG5cbiAgICByb290Lmluc2VydEJlZm9yZShmcmFnLCBwbGFjZWhvbGRlcik7XG4gIH07XG5cbiAgZXhwci51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGVhY2godGFncywgZnVuY3Rpb24gKHQpIHsgdC51bm1vdW50KCk7IH0pO1xuICB9O1xuXG4gIHJldHVybiBleHByXG59XG5cbnZhciBSZWZFeHByID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbSwgcGFyZW50LCBhdHRyTmFtZSwgYXR0clZhbHVlKSB7XG4gICAgdGhpcy5kb20gPSBkb207XG4gICAgdGhpcy5hdHRyID0gYXR0ck5hbWU7XG4gICAgdGhpcy5yYXdWYWx1ZSA9IGF0dHJWYWx1ZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmhhc0V4cCA9IHRtcGwuaGFzRXhwcihhdHRyVmFsdWUpO1xuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBvbGQgPSB0aGlzLnZhbHVlO1xuICAgIHZhciBjdXN0b21QYXJlbnQgPSB0aGlzLnBhcmVudCAmJiBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnQodGhpcy5wYXJlbnQpO1xuICAgIC8vIGlmIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQgaXMgYSBjdXN0b20gdGFnLCB0aGVuIHdlIHNldCB0aGUgdGFnIGl0c2VsZiwgcmF0aGVyIHRoYW4gRE9NXG4gICAgdmFyIHRhZ09yRG9tID0gdGhpcy5kb20uX19yZWYgfHwgdGhpcy50YWcgfHwgdGhpcy5kb207XG5cbiAgICB0aGlzLnZhbHVlID0gdGhpcy5oYXNFeHAgPyB0bXBsKHRoaXMucmF3VmFsdWUsIHRoaXMucGFyZW50KSA6IHRoaXMucmF3VmFsdWU7XG5cbiAgICAvLyB0aGUgbmFtZSBjaGFuZ2VkLCBzbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBvbGQga2V5IChpZiBwcmVzZW50KVxuICAgIGlmICghaXNCbGFuayhvbGQpICYmIGN1c3RvbVBhcmVudCkgeyBhcnJheWlzaFJlbW92ZShjdXN0b21QYXJlbnQucmVmcywgb2xkLCB0YWdPckRvbSk7IH1cbiAgICBpZiAoIWlzQmxhbmsodGhpcy52YWx1ZSkgJiYgaXNTdHJpbmcodGhpcy52YWx1ZSkpIHtcbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgcmVmcyBvZiBwYXJlbnQgdGFnICh0aGlzIGJlaGF2aW9yIHdhcyBjaGFuZ2VkID49My4wKVxuICAgICAgaWYgKGN1c3RvbVBhcmVudCkgeyBhcnJheWlzaEFkZChcbiAgICAgICAgY3VzdG9tUGFyZW50LnJlZnMsXG4gICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgIHRhZ09yRG9tLFxuICAgICAgICAvLyB1c2UgYW4gYXJyYXkgaWYgaXQncyBhIGxvb3BlZCBub2RlIGFuZCB0aGUgcmVmIGlzIG5vdCBhbiBleHByZXNzaW9uXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMucGFyZW50Ll9fLmluZGV4XG4gICAgICApOyB9XG5cbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBvbGQpIHtcbiAgICAgICAgc2V0QXR0cmlidXRlKHRoaXMuZG9tLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUodGhpcy5kb20sIHRoaXMuYXR0cik7XG4gICAgfVxuXG4gICAgLy8gY2FjaGUgdGhlIHJlZiBib3VuZCB0byB0aGlzIGRvbSBub2RlXG4gICAgLy8gdG8gcmV1c2UgaXQgaW4gZnV0dXJlIChzZWUgYWxzbyAjMjMyOSlcbiAgICBpZiAoIXRoaXMuZG9tLl9fcmVmKSB7IHRoaXMuZG9tLl9fcmVmID0gdGFnT3JEb207IH1cbiAgfSxcbiAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICB2YXIgdGFnT3JEb20gPSB0aGlzLnRhZyB8fCB0aGlzLmRvbTtcbiAgICB2YXIgY3VzdG9tUGFyZW50ID0gdGhpcy5wYXJlbnQgJiYgZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50KHRoaXMucGFyZW50KTtcbiAgICBpZiAoIWlzQmxhbmsodGhpcy52YWx1ZSkgJiYgY3VzdG9tUGFyZW50KVxuICAgICAgeyBhcnJheWlzaFJlbW92ZShjdXN0b21QYXJlbnQucmVmcywgdGhpcy52YWx1ZSwgdGFnT3JEb20pOyB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcmVmIGRpcmVjdGl2ZVxuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IGRvbSAtIGRvbSBub2RlIGhhdmluZyB0aGUgcmVmIGF0dHJpYnV0ZVxuICogQHBhcmFtICAgeyBUYWcgfSBjb250ZXh0IC0gdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBET00gbm9kZSBpcyBsb2NhdGVkXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IGF0dHJOYW1lIC0gZWl0aGVyICdyZWYnIG9yICdkYXRhLXJlZidcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gYXR0clZhbHVlIC0gdmFsdWUgb2YgdGhlIHJlZiBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHsgUmVmRXhwciB9IGEgbmV3IFJlZkV4cHIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlZkRpcmVjdGl2ZShkb20sIHRhZywgYXR0ck5hbWUsIGF0dHJWYWx1ZSkge1xuICByZXR1cm4gY3JlYXRlKFJlZkV4cHIpLmluaXQoZG9tLCB0YWcsIGF0dHJOYW1lLCBhdHRyVmFsdWUpXG59XG5cbi8qKlxuICogVHJpZ2dlciB0aGUgdW5tb3VudCBtZXRob2Qgb24gYWxsIHRoZSBleHByZXNzaW9uc1xuICogQHBhcmFtICAgeyBBcnJheSB9IGV4cHJlc3Npb25zIC0gRE9NIGV4cHJlc3Npb25zXG4gKi9cbmZ1bmN0aW9uIHVubW91bnRBbGwoZXhwcmVzc2lvbnMpIHtcbiAgZWFjaChleHByZXNzaW9ucywgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICBpZiAoZXhwci51bm1vdW50KSB7IGV4cHIudW5tb3VudCh0cnVlKTsgfVxuICAgIGVsc2UgaWYgKGV4cHIudGFnTmFtZSkgeyBleHByLnRhZy51bm1vdW50KHRydWUpOyB9XG4gICAgZWxzZSBpZiAoZXhwci51bm1vdW50KSB7IGV4cHIudW5tb3VudCgpOyB9XG4gIH0pO1xufVxuXG52YXIgSWZFeHByID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbSwgdGFnLCBleHByKSB7XG4gICAgcmVtb3ZlQXR0cmlidXRlKGRvbSwgQ09ORElUSU9OQUxfRElSRUNUSVZFKTtcbiAgICBleHRlbmQodGhpcywgeyB0YWc6IHRhZywgZXhwcjogZXhwciwgc3R1YjogY3JlYXRlRE9NUGxhY2Vob2xkZXIoKSwgcHJpc3RpbmU6IGRvbSB9KTtcbiAgICB2YXIgcCA9IGRvbS5wYXJlbnROb2RlO1xuICAgIHAuaW5zZXJ0QmVmb3JlKHRoaXMuc3R1YiwgZG9tKTtcbiAgICBwLnJlbW92ZUNoaWxkKGRvbSk7XG5cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICB0aGlzLnZhbHVlID0gdG1wbCh0aGlzLmV4cHIsIHRoaXMudGFnKTtcblxuICAgIGlmICh0aGlzLnZhbHVlICYmICF0aGlzLmN1cnJlbnQpIHsgLy8gaW5zZXJ0XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnByaXN0aW5lLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHRoaXMuc3R1Yi5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmN1cnJlbnQsIHRoaXMuc3R1Yik7XG4gICAgICB0aGlzLmV4cHJlc3Npb25zID0gcGFyc2VFeHByZXNzaW9ucy5hcHBseSh0aGlzLnRhZywgW3RoaXMuY3VycmVudCwgdHJ1ZV0pO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMudmFsdWUgJiYgdGhpcy5jdXJyZW50KSB7IC8vIHJlbW92ZVxuICAgICAgdW5tb3VudEFsbCh0aGlzLmV4cHJlc3Npb25zKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuX3RhZykge1xuICAgICAgICB0aGlzLmN1cnJlbnQuX3RhZy51bm1vdW50KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY3VycmVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgdGhpcy5leHByZXNzaW9ucyA9IFtdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZhbHVlKSB7IHVwZGF0ZS5jYWxsKHRoaXMudGFnLCB0aGlzLmV4cHJlc3Npb25zKTsgfVxuICB9LFxuICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIHVubW91bnRBbGwodGhpcy5leHByZXNzaW9ucyB8fCBbXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaWYgZGlyZWN0aXZlXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gZG9tIC0gaWYgcm9vdCBkb20gbm9kZVxuICogQHBhcmFtICAgeyBUYWcgfSBjb250ZXh0IC0gdGFnIGluc3RhbmNlIHdoZXJlIHRoZSBET00gbm9kZSBpcyBsb2NhdGVkXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IGF0dHIgLSBpZiBleHByZXNzaW9uXG4gKiBAcmV0dXJucyB7IElGRXhwciB9IGEgbmV3IElmRXhwciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSWZEaXJlY3RpdmUoZG9tLCB0YWcsIGF0dHIpIHtcbiAgcmV0dXJuIGNyZWF0ZShJZkV4cHIpLmluaXQoZG9tLCB0YWcsIGF0dHIpXG59XG5cbi8qKlxuICogV2FsayB0aGUgdGFnIERPTSB0byBkZXRlY3QgdGhlIGV4cHJlc3Npb25zIHRvIGV2YWx1YXRlXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSByb290IC0gcm9vdCB0YWcgd2hlcmUgd2Ugd2lsbCBzdGFydCBkaWdnaW5nIHRoZSBleHByZXNzaW9uc1xuICogQHBhcmFtICAgeyBCb29sZWFuIH0gbXVzdEluY2x1ZGVSb290IC0gZmxhZyB0byBkZWNpZGUgd2hldGhlciB0aGUgcm9vdCBtdXN0IGJlIHBhcnNlZCBhcyB3ZWxsXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gYWxsIHRoZSBleHByZXNzaW9ucyBmb3VuZFxuICovXG5mdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25zKHJvb3QsIG11c3RJbmNsdWRlUm9vdCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcblxuICB3YWxrTm9kZXMocm9vdCwgZnVuY3Rpb24gKGRvbSkge1xuICAgIHZhciB0eXBlID0gZG9tLm5vZGVUeXBlO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciB0YWdJbXBsO1xuXG4gICAgaWYgKCFtdXN0SW5jbHVkZVJvb3QgJiYgZG9tID09PSByb290KSB7IHJldHVybiB9XG5cbiAgICAvLyB0ZXh0IG5vZGVcbiAgICBpZiAodHlwZSA9PT0gMyAmJiBkb20ucGFyZW50Tm9kZS50YWdOYW1lICE9PSAnU1RZTEUnICYmIHRtcGwuaGFzRXhwcihkb20ubm9kZVZhbHVlKSlcbiAgICAgIHsgZXhwcmVzc2lvbnMucHVzaCh7ZG9tOiBkb20sIGV4cHI6IGRvbS5ub2RlVmFsdWV9KTsgfVxuXG4gICAgaWYgKHR5cGUgIT09IDEpIHsgcmV0dXJuIH1cblxuICAgIHZhciBpc1ZpcnR1YWwgPSBkb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuXG4gICAgLy8gbG9vcC4gZWFjaCBkb2VzIGl0J3Mgb3duIHRoaW5nIChmb3Igbm93KVxuICAgIGlmIChhdHRyID0gZ2V0QXR0cmlidXRlKGRvbSwgTE9PUF9ESVJFQ1RJVkUpKSB7XG4gICAgICBpZihpc1ZpcnR1YWwpIHsgc2V0QXR0cmlidXRlKGRvbSwgJ2xvb3BWaXJ0dWFsJywgdHJ1ZSk7IH0gLy8gaWdub3JlIGhlcmUsIGhhbmRsZWQgaW4gX2VhY2hcbiAgICAgIGV4cHJlc3Npb25zLnB1c2goX2VhY2goZG9tLCB0aGlzJDEsIGF0dHIpKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIGlmLWF0dHJzIGJlY29tZSB0aGUgbmV3IHBhcmVudC4gQW55IGZvbGxvd2luZyBleHByZXNzaW9ucyAoZWl0aGVyIG9uIHRoZSBjdXJyZW50XG4gICAgLy8gZWxlbWVudCwgb3IgYmVsb3cgaXQpIGJlY29tZSBjaGlsZHJlbiBvZiB0aGlzIGV4cHJlc3Npb24uXG4gICAgaWYgKGF0dHIgPSBnZXRBdHRyaWJ1dGUoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpKSB7XG4gICAgICBleHByZXNzaW9ucy5wdXNoKGNyZWF0ZUlmRGlyZWN0aXZlKGRvbSwgdGhpcyQxLCBhdHRyKSk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoYXR0ciA9IGdldEF0dHJpYnV0ZShkb20sIElTX0RJUkVDVElWRSkpIHtcbiAgICAgIGlmICh0bXBsLmhhc0V4cHIoYXR0cikpIHtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh7XG4gICAgICAgICAgaXNSdGFnOiB0cnVlLFxuICAgICAgICAgIGV4cHI6IGF0dHIsXG4gICAgICAgICAgZG9tOiBkb20sXG4gICAgICAgICAgYXR0cnM6IFtdLnNsaWNlLmNhbGwoZG9tLmF0dHJpYnV0ZXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaXMgYSB0YWcsIHN0b3AgdHJhdmVyc2luZyBoZXJlLlxuICAgIC8vIHdlIGlnbm9yZSB0aGUgcm9vdCwgc2luY2UgcGFyc2VFeHByZXNzaW9ucyBpcyBjYWxsZWQgd2hpbGUgd2UncmUgbW91bnRpbmcgdGhhdCByb290XG4gICAgdGFnSW1wbCA9IGdldChkb20pO1xuXG4gICAgaWYoaXNWaXJ0dWFsKSB7XG4gICAgICBpZihnZXRBdHRyaWJ1dGUoZG9tLCAndmlydHVhbGl6ZWQnKSkge2RvbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRvbSk7IH0gLy8gdGFnIGNyZWF0ZWQsIHJlbW92ZSBmcm9tIGRvbVxuICAgICAgaWYoIXRhZ0ltcGwgJiYgIWdldEF0dHJpYnV0ZShkb20sICd2aXJ0dWFsaXplZCcpICYmICFnZXRBdHRyaWJ1dGUoZG9tLCAnbG9vcFZpcnR1YWwnKSkgIC8vIG9rIHRvIGNyZWF0ZSB2aXJ0dWFsIHRhZ1xuICAgICAgICB7IHRhZ0ltcGwgPSB7IHRtcGw6IGRvbS5vdXRlckhUTUwgfTsgfVxuICAgIH1cblxuICAgIGlmICh0YWdJbXBsICYmIChkb20gIT09IHJvb3QgfHwgbXVzdEluY2x1ZGVSb290KSkge1xuICAgICAgaWYoaXNWaXJ0dWFsKSB7IC8vIGhhbmRsZWQgaW4gdXBkYXRlXG4gICAgICAgIGlmIChnZXRBdHRyaWJ1dGUoZG9tLCBJU19ESVJFQ1RJVkUpKVxuICAgICAgICAgIHsgd2FybigoXCJWaXJ0dWFsIHRhZ3Mgc2hvdWxkbid0IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgXFxcIlwiICsgSVNfRElSRUNUSVZFICsgXCJcXFwiIGF0dHJpYnV0ZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9yaW90L3Jpb3QvaXNzdWVzLzI1MTFcIikpOyB9XG4gICAgICAgIC8vIGNhbiBub3QgcmVtb3ZlIGF0dHJpYnV0ZSBsaWtlIGRpcmVjdGl2ZXNcbiAgICAgICAgLy8gc28gZmxhZyBmb3IgcmVtb3ZhbCBhZnRlciBjcmVhdGlvbiB0byBwcmV2ZW50IG1heGltdW0gc3RhY2sgZXJyb3JcbiAgICAgICAgc2V0QXR0cmlidXRlKGRvbSwgJ3ZpcnR1YWxpemVkJywgdHJ1ZSk7XG4gICAgICAgIHZhciB0YWcgPSBjcmVhdGVUYWcoXG4gICAgICAgICAge3RtcGw6IGRvbS5vdXRlckhUTUx9LFxuICAgICAgICAgIHtyb290OiBkb20sIHBhcmVudDogdGhpcyQxfSxcbiAgICAgICAgICBkb20uaW5uZXJIVE1MXG4gICAgICAgICk7XG5cbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh0YWcpOyAvLyBubyByZXR1cm4sIGFub255bW91cyB0YWcsIGtlZXAgcGFyc2luZ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChcbiAgICAgICAgICBpbml0Q2hpbGQoXG4gICAgICAgICAgICB0YWdJbXBsLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb290OiBkb20sXG4gICAgICAgICAgICAgIHBhcmVudDogdGhpcyQxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tLmlubmVySFRNTCxcbiAgICAgICAgICAgIHRoaXMkMVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXR0cmlidXRlIGV4cHJlc3Npb25zXG4gICAgcGFyc2VBdHRyaWJ1dGVzLmFwcGx5KHRoaXMkMSwgW2RvbSwgZG9tLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChhdHRyLCBleHByKSB7XG4gICAgICBpZiAoIWV4cHIpIHsgcmV0dXJuIH1cbiAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcik7XG4gICAgfV0pO1xuICB9KTtcblxuICByZXR1cm4gZXhwcmVzc2lvbnNcbn1cblxuLyoqXG4gKiBDYWxscyBgZm5gIGZvciBldmVyeSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC4gSWYgdGhhdCBhdHRyIGhhcyBhbiBleHByZXNzaW9uLFxuICogaXQgaXMgYWxzbyBwYXNzZWQgdG8gZm4uXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSBkb20gLSBkb20gbm9kZSB0byBwYXJzZVxuICogQHBhcmFtICAgeyBBcnJheSB9IGF0dHJzIC0gYXJyYXkgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgdG8gZXhlYyBvbiBhbnkgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyhkb20sIGF0dHJzLCBmbikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBlYWNoKGF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgIGlmICghYXR0cikgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdmFyIG5hbWUgPSBhdHRyLm5hbWU7XG4gICAgdmFyIGJvb2wgPSBpc0Jvb2xBdHRyKG5hbWUpO1xuICAgIHZhciBleHByO1xuXG4gICAgaWYgKGNvbnRhaW5zKFJFRl9ESVJFQ1RJVkVTLCBuYW1lKSAmJiBkb20udGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBZSUVMRF9UQUcpIHtcbiAgICAgIGV4cHIgPSAgY3JlYXRlUmVmRGlyZWN0aXZlKGRvbSwgdGhpcyQxLCBuYW1lLCBhdHRyLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRtcGwuaGFzRXhwcihhdHRyLnZhbHVlKSkge1xuICAgICAgZXhwciA9IHtkb206IGRvbSwgZXhwcjogYXR0ci52YWx1ZSwgYXR0cjogbmFtZSwgYm9vbDogYm9vbH07XG4gICAgfVxuXG4gICAgZm4oYXR0ciwgZXhwcik7XG4gIH0pO1xufVxuXG4vKipcbiAqIE1hbmFnZSB0aGUgbW91bnQgc3RhdGUgb2YgYSB0YWcgdHJpZ2dlcmluZyBhbHNvIHRoZSBvYnNlcnZhYmxlIGV2ZW50c1xuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0geyBCb29sZWFuIH0gdmFsdWUgLSAuLm9mIHRoZSBpc01vdW50ZWQgZmxhZ1xuICovXG5mdW5jdGlvbiBzZXRNb3VudFN0YXRlKHZhbHVlKSB7XG4gIHZhciByZWYgPSB0aGlzLl9fO1xuICB2YXIgaXNBbm9ueW1vdXMgPSByZWYuaXNBbm9ueW1vdXM7XG5cbiAgZGVmaW5lKHRoaXMsICdpc01vdW50ZWQnLCB2YWx1ZSk7XG5cbiAgaWYgKCFpc0Fub255bW91cykge1xuICAgIGlmICh2YWx1ZSkgeyB0aGlzLnRyaWdnZXIoJ21vdW50Jyk7IH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudHJpZ2dlcigndW5tb3VudCcpO1xuICAgICAgdGhpcy5vZmYoJyonKTtcbiAgICAgIHRoaXMuX18ud2FzQ3JlYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1vdW50IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICogQHJldHVybnMgeyBUYWcgfSB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50TW91bnQodGFnJCQxLCBkb20sIGV4cHJlc3Npb25zLCBvcHRzKSB7XG4gIHZhciBfXyA9IHRhZyQkMS5fXztcbiAgdmFyIHJvb3QgPSBfXy5yb290O1xuICByb290Ll90YWcgPSB0YWckJDE7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHRhZyBqdXN0IGNyZWF0ZWRcblxuICAvLyBSZWFkIGFsbCB0aGUgYXR0cnMgb24gdGhpcyBpbnN0YW5jZS4gVGhpcyBnaXZlIHVzIHRoZSBpbmZvIHdlIG5lZWQgZm9yIHVwZGF0ZU9wdHNcbiAgcGFyc2VBdHRyaWJ1dGVzLmFwcGx5KF9fLnBhcmVudCwgW3Jvb3QsIHJvb3QuYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHIsIGV4cHIpIHtcbiAgICBpZiAoIV9fLmlzQW5vbnltb3VzICYmIFJlZkV4cHIuaXNQcm90b3R5cGVPZihleHByKSkgeyBleHByLnRhZyA9IHRhZyQkMTsgfVxuICAgIGF0dHIuZXhwciA9IGV4cHI7XG4gICAgX18uaW5zdEF0dHJzLnB1c2goYXR0cik7XG4gIH1dKTtcblxuICAvLyB1cGRhdGUgdGhlIHJvb3QgYWRkaW5nIGN1c3RvbSBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIHRoZSBjb21waWxlclxuICB3YWxrQXR0cmlidXRlcyhfXy5pbXBsLmF0dHJzLCBmdW5jdGlvbiAoaywgdikgeyBfXy5pbXBsQXR0cnMucHVzaCh7bmFtZTogaywgdmFsdWU6IHZ9KTsgfSk7XG4gIHBhcnNlQXR0cmlidXRlcy5hcHBseSh0YWckJDEsIFtyb290LCBfXy5pbXBsQXR0cnMsIGZ1bmN0aW9uIChhdHRyLCBleHByKSB7XG4gICAgaWYgKGV4cHIpIHsgZXhwcmVzc2lvbnMucHVzaChleHByKTsgfVxuICAgIGVsc2UgeyBzZXRBdHRyaWJ1dGUocm9vdCwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTsgfVxuICB9XSk7XG5cbiAgLy8gaW5pdGlhbGlhdGlvblxuICB1cGRhdGVPcHRzLmFwcGx5KHRhZyQkMSwgW19fLmlzTG9vcCwgX18ucGFyZW50LCBfXy5pc0Fub255bW91cywgb3B0cywgX18uaW5zdEF0dHJzXSk7XG5cbiAgLy8gYWRkIGdsb2JhbCBtaXhpbnNcbiAgdmFyIGdsb2JhbE1peGluID0gbWl4aW4oR0xPQkFMX01JWElOKTtcblxuICBpZiAoZ2xvYmFsTWl4aW4gJiYgIV9fLnNraXBBbm9ueW1vdXMpIHtcbiAgICBmb3IgKHZhciBpIGluIGdsb2JhbE1peGluKSB7XG4gICAgICBpZiAoZ2xvYmFsTWl4aW4uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdGFnJCQxLm1peGluKGdsb2JhbE1peGluW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoX18uaW1wbC5mbikgeyBfXy5pbXBsLmZuLmNhbGwodGFnJCQxLCBvcHRzKTsgfVxuXG4gIGlmICghX18uc2tpcEFub255bW91cykgeyB0YWckJDEudHJpZ2dlcignYmVmb3JlLW1vdW50Jyk7IH1cblxuICAvLyBwYXJzZSBsYXlvdXQgYWZ0ZXIgaW5pdC4gZm4gbWF5IGNhbGN1bGF0ZSBhcmdzIGZvciBuZXN0ZWQgY3VzdG9tIHRhZ3NcbiAgZWFjaChwYXJzZUV4cHJlc3Npb25zLmFwcGx5KHRhZyQkMSwgW2RvbSwgX18uaXNBbm9ueW1vdXNdKSwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGV4cHJlc3Npb25zLnB1c2goZSk7IH0pO1xuXG4gIHRhZyQkMS51cGRhdGUoX18uaXRlbSk7XG5cbiAgaWYgKCFfXy5pc0Fub255bW91cyAmJiAhX18uaXNJbmxpbmUpIHtcbiAgICB3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIHsgcm9vdC5hcHBlbmRDaGlsZChkb20uZmlyc3RDaGlsZCk7IH1cbiAgfVxuXG4gIGRlZmluZSh0YWckJDEsICdyb290Jywgcm9vdCk7XG5cbiAgLy8gaWYgd2UgbmVlZCB0byB3YWl0IHRoYXQgdGhlIHBhcmVudCBcIm1vdW50XCIgb3IgXCJ1cGRhdGVkXCIgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgaWYgKCFfXy5za2lwQW5vbnltb3VzICYmIHRhZyQkMS5wYXJlbnQpIHtcbiAgICB2YXIgcCA9IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudCh0YWckJDEucGFyZW50KTtcbiAgICBwLm9uZSghcC5pc01vdW50ZWQgPyAnbW91bnQnIDogJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRNb3VudFN0YXRlLmNhbGwodGFnJCQxLCB0cnVlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UgaXQncyBub3QgYSBjaGlsZCB0YWcgd2UgY2FuIHRyaWdnZXIgaXRzIG1vdW50IGV2ZW50XG4gICAgc2V0TW91bnRTdGF0ZS5jYWxsKHRhZyQkMSwgdHJ1ZSk7XG4gIH1cblxuICB0YWckJDEuX18ud2FzQ3JlYXRlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHRhZyQkMVxufVxuXG4vKipcbiAqIFVubW91bnQgdGhlIHRhZyBpbnN0YW5jZVxuICogQHBhcmFtIHsgQm9vbGVhbiB9IG11c3RLZWVwUm9vdCAtIGlmIGl0J3MgdHJ1ZSB0aGUgcm9vdCBub2RlIHdpbGwgbm90IGJlIHJlbW92ZWRcbiAqIEByZXR1cm5zIHsgVGFnIH0gdGhlIGN1cnJlbnQgdGFnIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHRhZ1VubW91bnQodGFnLCBtdXN0S2VlcFJvb3QsIGV4cHJlc3Npb25zKSB7XG4gIHZhciBfXyA9IHRhZy5fXztcbiAgdmFyIHJvb3QgPSBfXy5yb290O1xuICB2YXIgdGFnSW5kZXggPSBfX1RBR1NfQ0FDSEUuaW5kZXhPZih0YWcpO1xuICB2YXIgcCA9IHJvb3QucGFyZW50Tm9kZTtcblxuICBpZiAoIV9fLnNraXBBbm9ueW1vdXMpIHsgdGFnLnRyaWdnZXIoJ2JlZm9yZS11bm1vdW50Jyk7IH1cblxuICAvLyBjbGVhciBhbGwgYXR0cmlidXRlcyBjb21pbmcgZnJvbSB0aGUgbW91bnRlZCB0YWdcbiAgd2Fsa0F0dHJpYnV0ZXMoX18uaW1wbC5hdHRycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoc3RhcnRzV2l0aChuYW1lLCBBVFRSU19QUkVGSVgpKVxuICAgICAgeyBuYW1lID0gbmFtZS5zbGljZShBVFRSU19QUkVGSVgubGVuZ3RoKTsgfVxuXG4gICAgcmVtb3ZlQXR0cmlidXRlKHJvb3QsIG5hbWUpO1xuICB9KTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgdGFnLl9fLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChkb20pIHtcbiAgICBPYmplY3Qua2V5cyhkb21bUklPVF9FVkVOVFNfS0VZXSkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRvbVtSSU9UX0VWRU5UU19LRVldW2V2ZW50TmFtZV0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyByZW1vdmUgdGFnIGluc3RhbmNlIGZyb20gdGhlIGdsb2JhbCB0YWdzIGNhY2hlIGNvbGxlY3Rpb25cbiAgaWYgKHRhZ0luZGV4ICE9PSAtMSkgeyBfX1RBR1NfQ0FDSEUuc3BsaWNlKHRhZ0luZGV4LCAxKTsgfVxuXG4gIC8vIGNsZWFuIHVwIHRoZSBwYXJlbnQgdGFncyBvYmplY3RcbiAgaWYgKF9fLnBhcmVudCAmJiAhX18uaXNBbm9ueW1vdXMpIHtcbiAgICB2YXIgcHRhZyA9IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudChfXy5wYXJlbnQpO1xuXG4gICAgaWYgKF9fLmlzVmlydHVhbCkge1xuICAgICAgT2JqZWN0XG4gICAgICAgIC5rZXlzKHRhZy50YWdzKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkgeyByZXR1cm4gYXJyYXlpc2hSZW1vdmUocHRhZy50YWdzLCB0YWdOYW1lLCB0YWcudGFnc1t0YWdOYW1lXSk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheWlzaFJlbW92ZShwdGFnLnRhZ3MsIF9fLnRhZ05hbWUsIHRhZyk7XG4gICAgfVxuICB9XG5cbiAgLy8gdW5tb3VudCBhbGwgdGhlIHZpcnR1YWwgZGlyZWN0aXZlc1xuICBpZiAodGFnLl9fLnZpcnRzKSB7XG4gICAgZWFjaCh0YWcuX18udmlydHMsIGZ1bmN0aW9uICh2KSB7XG4gICAgICBpZiAodi5wYXJlbnROb2RlKSB7IHYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2KTsgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gYWxsb3cgZXhwcmVzc2lvbnMgdG8gdW5tb3VudCB0aGVtc2VsdmVzXG4gIHVubW91bnRBbGwoZXhwcmVzc2lvbnMpO1xuICBlYWNoKF9fLmluc3RBdHRycywgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEuZXhwciAmJiBhLmV4cHIudW5tb3VudCAmJiBhLmV4cHIudW5tb3VudCgpOyB9KTtcblxuICAvLyBjbGVhciB0aGUgdGFnIGh0bWwgaWYgaXQncyBuZWNlc3NhcnlcbiAgaWYgKG11c3RLZWVwUm9vdCkgeyBzZXRJbm5lckhUTUwocm9vdCwgJycpOyB9XG4gIC8vIG90aGVyd2lzZSBkZXRhY2ggdGhlIHJvb3QgdGFnIGZyb20gdGhlIERPTVxuICBlbHNlIGlmIChwKSB7IHAucmVtb3ZlQ2hpbGQocm9vdCk7IH1cblxuICAvLyBjdXN0b20gaW50ZXJuYWwgdW5tb3VudCBmdW5jdGlvbiB0byBhdm9pZCByZWx5aW5nIG9uIHRoZSBvYnNlcnZhYmxlXG4gIGlmIChfXy5vblVubW91bnQpIHsgX18ub25Vbm1vdW50KCk7IH1cblxuICAvLyB3ZWlyZCBmaXggZm9yIGEgd2VpcmQgZWRnZSBjYXNlICMyNDA5IGFuZCAjMjQzNlxuICAvLyBzb21lIHVzZXJzIG1pZ2h0IHVzZSB5b3VyIHNvZnR3YXJlIG5vdCBhcyB5b3UndmUgZXhwZWN0ZWRcbiAgLy8gc28gSSBuZWVkIHRvIGFkZCB0aGVzZSBkaXJ0eSBoYWNrcyB0byBtaXRpZ2F0ZSB1bmV4cGVjdGVkIGlzc3Vlc1xuICBpZiAoIXRhZy5pc01vdW50ZWQpIHsgc2V0TW91bnRTdGF0ZS5jYWxsKHRhZywgdHJ1ZSk7IH1cblxuICBzZXRNb3VudFN0YXRlLmNhbGwodGFnLCBmYWxzZSk7XG5cbiAgZGVsZXRlIHJvb3QuX3RhZztcblxuICByZXR1cm4gdGFnXG59XG5cbi8qKlxuICogVGFnIGNyZWF0aW9uIGZhY3RvcnkgZnVuY3Rpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsgT2JqZWN0IH0gaW1wbCAtIGl0IGNvbnRhaW5zIHRoZSB0YWcgdGVtcGxhdGUsIGFuZCBsb2dpY1xuICogQHBhcmFtIHsgT2JqZWN0IH0gY29uZiAtIHRhZyBvcHRpb25zXG4gKiBAcGFyYW0geyBTdHJpbmcgfSBpbm5lckhUTUwgLSBodG1sIHRoYXQgZXZlbnR1YWxseSB3ZSBuZWVkIHRvIGluamVjdCBpbiB0aGUgdGFnXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRhZyhpbXBsLCBjb25mLCBpbm5lckhUTUwpIHtcbiAgaWYgKCBpbXBsID09PSB2b2lkIDAgKSBpbXBsID0ge307XG4gIGlmICggY29uZiA9PT0gdm9pZCAwICkgY29uZiA9IHt9O1xuXG4gIHZhciB0YWcgPSBjb25mLmNvbnRleHQgfHwge307XG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBjb25mLm9wdHMpO1xuICB2YXIgcGFyZW50ID0gY29uZi5wYXJlbnQ7XG4gIHZhciBpc0xvb3AgPSBjb25mLmlzTG9vcDtcbiAgdmFyIGlzQW5vbnltb3VzID0gISFjb25mLmlzQW5vbnltb3VzO1xuICB2YXIgc2tpcEFub255bW91cyA9IHNldHRpbmdzLnNraXBBbm9ueW1vdXNUYWdzICYmIGlzQW5vbnltb3VzO1xuICB2YXIgaXRlbSA9IGNvbmYuaXRlbTtcbiAgLy8gYXZhaWxhYmxlIG9ubHkgZm9yIHRoZSBsb29wZWQgbm9kZXNcbiAgdmFyIGluZGV4ID0gY29uZi5pbmRleDtcbiAgLy8gQWxsIGF0dHJpYnV0ZXMgb24gdGhlIFRhZyB3aGVuIGl0J3MgZmlyc3QgcGFyc2VkXG4gIHZhciBpbnN0QXR0cnMgPSBbXTtcbiAgLy8gZXhwcmVzc2lvbnMgb24gdGhpcyB0eXBlIG9mIFRhZ1xuICB2YXIgaW1wbEF0dHJzID0gW107XG4gIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICB2YXIgcm9vdCA9IGNvbmYucm9vdDtcbiAgdmFyIHRhZ05hbWUgPSBjb25mLnRhZ05hbWUgfHwgZ2V0TmFtZShyb290KTtcbiAgdmFyIGlzVmlydHVhbCA9IHRhZ05hbWUgPT09ICd2aXJ0dWFsJztcbiAgdmFyIGlzSW5saW5lID0gIWlzVmlydHVhbCAmJiAhaW1wbC50bXBsO1xuICB2YXIgZG9tO1xuXG4gIC8vIG1ha2UgdGhpcyB0YWcgb2JzZXJ2YWJsZVxuICBpZiAoIXNraXBBbm9ueW1vdXMpIHsgb2JzZXJ2YWJsZSh0YWcpOyB9XG4gIC8vIG9ubHkgY2FsbCB1bm1vdW50IGlmIHdlIGhhdmUgYSB2YWxpZCBfX1RBR19JTVBMIChoYXMgbmFtZSBwcm9wZXJ0eSlcbiAgaWYgKGltcGwubmFtZSAmJiByb290Ll90YWcpIHsgcm9vdC5fdGFnLnVubW91bnQodHJ1ZSk7IH1cblxuICAvLyBub3QgeWV0IG1vdW50ZWRcbiAgZGVmaW5lKHRhZywgJ2lzTW91bnRlZCcsIGZhbHNlKTtcblxuICBkZWZpbmUodGFnLCAnX18nLCB7XG4gICAgaW1wbDogaW1wbCxcbiAgICByb290OiByb290LFxuICAgIHNraXBBbm9ueW1vdXM6IHNraXBBbm9ueW1vdXMsXG4gICAgaW1wbEF0dHJzOiBpbXBsQXR0cnMsXG4gICAgaXNBbm9ueW1vdXM6IGlzQW5vbnltb3VzLFxuICAgIGluc3RBdHRyczogaW5zdEF0dHJzLFxuICAgIGlubmVySFRNTDogaW5uZXJIVE1MLFxuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGlzTG9vcDogaXNMb29wLFxuICAgIGlzSW5saW5lOiBpc0lubGluZSxcbiAgICBpdGVtOiBpdGVtLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIC8vIHRhZ3MgaGF2aW5nIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIGl0IHdvdWxkIGJlIGJldHRlciB0byB1c2Ugd2VhayBtYXBzIGhlcmUgYnV0IHdlIGNhbiBub3QgaW50cm9kdWNlIGJyZWFraW5nIGNoYW5nZXMgbm93XG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICAvLyB0aGVzZSB2YXJzIHdpbGwgYmUgbmVlZGVkIG9ubHkgZm9yIHRoZSB2aXJ0dWFsIHRhZ3NcbiAgICB2aXJ0czogW10sXG4gICAgd2FzQ3JlYXRlZDogZmFsc2UsXG4gICAgdGFpbDogbnVsbCxcbiAgICBoZWFkOiBudWxsXG4gIH0pO1xuXG4gIC8vIGNyZWF0ZSBhIHVuaXF1ZSBpZCB0byB0aGlzIHRhZ1xuICAvLyBpdCBjb3VsZCBiZSBoYW5keSB0byB1c2UgaXQgYWxzbyB0byBpbXByb3ZlIHRoZSB2aXJ0dWFsIGRvbSByZW5kZXJpbmcgc3BlZWRcbiAgZGVmaW5lKHRhZywgJ19yaW90X2lkJywgdWlkKCkpOyAvLyBiYXNlIDEgYWxsb3dzIHRlc3QgIXQuX3Jpb3RfaWRcbiAgZGVmaW5lKHRhZywgJ3Jvb3QnLCByb290KTtcbiAgZXh0ZW5kKHRhZywgeyBvcHRzOiBvcHRzIH0sIGl0ZW0pO1xuICAvLyBwcm90ZWN0IHRoZSBcInRhZ3NcIiBhbmQgXCJyZWZzXCIgcHJvcGVydHkgZnJvbSBiZWluZyBvdmVycmlkZGVuXG4gIGRlZmluZSh0YWcsICdwYXJlbnQnLCBwYXJlbnQgfHwgbnVsbCk7XG4gIGRlZmluZSh0YWcsICd0YWdzJywge30pO1xuICBkZWZpbmUodGFnLCAncmVmcycsIHt9KTtcblxuICBpZiAoaXNJbmxpbmUgfHwgaXNMb29wICYmIGlzQW5vbnltb3VzKSB7XG4gICAgZG9tID0gcm9vdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzVmlydHVhbCkgeyByb290LmlubmVySFRNTCA9ICcnOyB9XG4gICAgZG9tID0gbWtkb20oaW1wbC50bXBsLCBpbm5lckhUTUwsIGlzU3ZnKHJvb3QpKTtcbiAgfVxuXG4gIGRlZmluZSh0YWcsICd1cGRhdGUnLCBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gY29tcG9uZW50VXBkYXRlKHRhZywgZGF0YSwgZXhwcmVzc2lvbnMpOyB9KTtcbiAgZGVmaW5lKHRhZywgJ21peGluJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaXhpbnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgbWl4aW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gY29tcG9uZW50TWl4aW4uYXBwbHkodm9pZCAwLCBbIHRhZyBdLmNvbmNhdCggbWl4aW5zICkpO1xuICB9KTtcbiAgZGVmaW5lKHRhZywgJ21vdW50JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9uZW50TW91bnQodGFnLCBkb20sIGV4cHJlc3Npb25zLCBvcHRzKTsgfSk7XG4gIGRlZmluZSh0YWcsICd1bm1vdW50JywgZnVuY3Rpb24gKG11c3RLZWVwUm9vdCkgeyByZXR1cm4gdGFnVW5tb3VudCh0YWcsIG11c3RLZWVwUm9vdCwgZXhwcmVzc2lvbnMpOyB9KTtcblxuICByZXR1cm4gdGFnXG59XG5cbi8qKlxuICogTW91bnQgYSB0YWcgY3JlYXRpbmcgbmV3IFRhZyBpbnN0YW5jZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSByb290IC0gZG9tIG5vZGUgd2hlcmUgdGhlIHRhZyB3aWxsIGJlIG1vdW50ZWRcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGFnTmFtZSAtIG5hbWUgb2YgdGhlIHJpb3QgdGFnIHdlIHdhbnQgdG8gbW91bnRcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgVGFnIGluc3RhbmNlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIG9wdGlvbmFsIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGNsYXNzICggdXNlZCBpbiByaW90LlRhZyApXG4gKiBAcmV0dXJucyB7IFRhZyB9IGEgbmV3IFRhZyBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBtb3VudCQxKHJvb3QsIHRhZ05hbWUsIG9wdHMsIGN0eCkge1xuICB2YXIgaW1wbCA9IF9fVEFHX0lNUExbdGFnTmFtZV07XG4gIHZhciBpbXBsQ2xhc3MgPSBfX1RBR19JTVBMW3RhZ05hbWVdLmNsYXNzO1xuICB2YXIgY29udGV4dCA9IGN0eCB8fCAoaW1wbENsYXNzID8gY3JlYXRlKGltcGxDbGFzcy5wcm90b3R5cGUpIDoge30pO1xuICAvLyBjYWNoZSB0aGUgaW5uZXIgSFRNTCB0byBmaXggIzg1NVxuICB2YXIgaW5uZXJIVE1MID0gcm9vdC5faW5uZXJIVE1MID0gcm9vdC5faW5uZXJIVE1MIHx8IHJvb3QuaW5uZXJIVE1MO1xuICB2YXIgY29uZiA9IGV4dGVuZCh7IHJvb3Q6IHJvb3QsIG9wdHM6IG9wdHMsIGNvbnRleHQ6IGNvbnRleHQgfSwgeyBwYXJlbnQ6IG9wdHMgPyBvcHRzLnBhcmVudCA6IG51bGwgfSk7XG4gIHZhciB0YWc7XG5cbiAgaWYgKGltcGwgJiYgcm9vdCkgeyB0YWcgPSBjcmVhdGVUYWcoaW1wbCwgY29uZiwgaW5uZXJIVE1MKTsgfVxuXG4gIGlmICh0YWcgJiYgdGFnLm1vdW50KSB7XG4gICAgdGFnLm1vdW50KHRydWUpO1xuICAgIC8vIGFkZCB0aGlzIHRhZyB0byB0aGUgdmlydHVhbERvbSB2YXJpYWJsZVxuICAgIGlmICghY29udGFpbnMoX19UQUdTX0NBQ0hFLCB0YWcpKSB7IF9fVEFHU19DQUNIRS5wdXNoKHRhZyk7IH1cbiAgfVxuXG4gIHJldHVybiB0YWdcbn1cblxuXG5cbnZhciB0YWdzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFycmF5aXNoQWRkOiBhcnJheWlzaEFkZCxcblx0Z2V0VGFnTmFtZTogZ2V0TmFtZSxcblx0aW5oZXJpdFBhcmVudFByb3BzOiBpbmhlcml0UGFyZW50UHJvcHMsXG5cdG1vdW50VG86IG1vdW50JDEsXG5cdHNlbGVjdFRhZ3M6IHF1ZXJ5LFxuXHRhcnJheWlzaFJlbW92ZTogYXJyYXlpc2hSZW1vdmUsXG5cdGdldFRhZzogZ2V0LFxuXHRpbml0Q2hpbGRUYWc6IGluaXRDaGlsZCxcblx0bW92ZUNoaWxkVGFnOiBtb3ZlQ2hpbGQsXG5cdG1ha2VSZXBsYWNlVmlydHVhbDogbWFrZVJlcGxhY2VWaXJ0dWFsLFxuXHRnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnRUYWc6IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudCxcblx0bWFrZVZpcnR1YWw6IG1ha2VWaXJ0dWFsLFxuXHRtb3ZlVmlydHVhbDogbW92ZVZpcnR1YWwsXG5cdHVubW91bnRBbGw6IHVubW91bnRBbGwsXG5cdGNyZWF0ZUlmRGlyZWN0aXZlOiBjcmVhdGVJZkRpcmVjdGl2ZSxcblx0Y3JlYXRlUmVmRGlyZWN0aXZlOiBjcmVhdGVSZWZEaXJlY3RpdmVcbn0pO1xuXG4vKipcbiAqIFJpb3QgcHVibGljIGFwaVxuICovXG52YXIgc2V0dGluZ3MkMSA9IHNldHRpbmdzO1xudmFyIHV0aWwgPSB7XG4gIHRtcGw6IHRtcGwsXG4gIGJyYWNrZXRzOiBicmFja2V0cyxcbiAgc3R5bGVNYW5hZ2VyOiBzdHlsZU1hbmFnZXIsXG4gIHZkb206IF9fVEFHU19DQUNIRSxcbiAgc3R5bGVOb2RlOiBzdHlsZU1hbmFnZXIuc3R5bGVOb2RlLFxuICAvLyBleHBvcnQgdGhlIHJpb3QgaW50ZXJuYWwgdXRpbHMgYXMgd2VsbFxuICBkb206IGRvbSxcbiAgY2hlY2s6IGNoZWNrLFxuICBtaXNjOiBtaXNjLFxuICB0YWdzOiB0YWdzXG59O1xuXG4vLyBleHBvcnQgdGhlIGNvcmUgcHJvcHMvbWV0aG9kc1xudmFyIFRhZyQxID0gVGFnO1xudmFyIHRhZyQxID0gdGFnO1xudmFyIHRhZzIkMSA9IHRhZzI7XG52YXIgbW91bnQkMiA9IG1vdW50O1xudmFyIG1peGluJDEgPSBtaXhpbjtcbnZhciB1cGRhdGUkMiA9IHVwZGF0ZSQxO1xudmFyIHVucmVnaXN0ZXIkMSA9IHVucmVnaXN0ZXI7XG52YXIgdmVyc2lvbiQxID0gdmVyc2lvbjtcbnZhciBvYnNlcnZhYmxlJDIgPSBvYnNlcnZhYmxlO1xuXG52YXIgcmlvdCQxID0gZXh0ZW5kKHt9LCBjb3JlLCB7XG4gIG9ic2VydmFibGU6IG9ic2VydmFibGUsXG4gIHNldHRpbmdzOiBzZXR0aW5ncyQxLFxuICB1dGlsOiB1dGlsLFxufSlcblxuZXhwb3J0cy5zZXR0aW5ncyA9IHNldHRpbmdzJDE7XG5leHBvcnRzLnV0aWwgPSB1dGlsO1xuZXhwb3J0cy5UYWcgPSBUYWckMTtcbmV4cG9ydHMudGFnID0gdGFnJDE7XG5leHBvcnRzLnRhZzIgPSB0YWcyJDE7XG5leHBvcnRzLm1vdW50ID0gbW91bnQkMjtcbmV4cG9ydHMubWl4aW4gPSBtaXhpbiQxO1xuZXhwb3J0cy51cGRhdGUgPSB1cGRhdGUkMjtcbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXIkMTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb24kMTtcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGUkMjtcbmV4cG9ydHMuZGVmYXVsdCA9IHJpb3QkMTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Jpb3QvcmlvdC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},1:function(module,exports){eval('/* Umbrella JS 2.10.0 umbrellajs.com */\nfunction ajax(a,b,c,d){c=c||function(){},b=b||{},b.body=b.body||{},b.method=(b.method||"GET").toUpperCase(),b.headers=b.headers||{},b.headers["X-Requested-With"]=b.headers["X-Requested-With"]||"XMLHttpRequest","undefined"!=typeof window.FormData&&b.body instanceof window.FormData||(b.headers["Content-Type"]=b.headers["Content-Type"]||"application/x-www-form-urlencoded"),/json/.test(b.headers["Content-Type"])&&(b.body=JSON.stringify(b.body)),"object"!=typeof b.body||b.body instanceof window.FormData||(b.body=u().param(b.body));var e=new window.XMLHttpRequest;u(e).on("error timeout abort",function(){c(new Error,null,e)}).on("load",function(){var a=/^(4|5)/.test(e.status)?new Error(e.status):null,b=parseJson(e.response)||e.response;return c(a,b,e)}),e.open(b.method,a),e.withCredentials=!0;for(var f in b.headers)e.setRequestHeader(f,b.headers[f]);return d&&d(e),e.send(b.body),e}function parseJson(a){try{var b=JSON.parse(a);if(b&&"object"==typeof b)return b}catch(c){}return!1}var u=function(a,b){return this instanceof u?a instanceof u?a:("string"==typeof a&&(a=this.select(a,b)),a&&a.nodeName&&(a=[a]),void(this.nodes=this.slice(a))):new u(a,b)};u.prototype={get length(){return this.nodes.length}},u.prototype.nodes=[],u.prototype.addClass=function(){return this.eacharg(arguments,function(a,b){a.classList.add(b)})},u.prototype.adjacent=function(a,b,c){return"number"==typeof b&&(b=0===b?[]:new Array(b).join().split(",").map(Number.call,Number)),this.each(function(d,e){var f=document.createDocumentFragment();u(b||{}).map(function(b,c){var f="function"==typeof a?a.call(this,b,c,d,e):a;return"string"==typeof f?this.generate(f):u(f)}).each(function(a){this.isInPage(a)?f.appendChild(u(a).clone().first()):f.appendChild(a)}),c.call(this,d,f)})},u.prototype.after=function(a,b){return this.adjacent(a,b,function(a,b){a.parentNode.insertBefore(b,a.nextSibling)})},u.prototype.ajax=function(a,b){return this.handle("submit",function(c){ajax(u(this).attr("action"),{body:u(this).serialize(),method:u(this).attr("method")},a&&a.bind(this),b&&b.bind(this))})},u.prototype.append=function(a,b){return this.adjacent(a,b,function(a,b){a.appendChild(b)})},u.prototype.args=function(a,b,c){return"function"==typeof a&&(a=a(b,c)),"string"!=typeof a&&(a=this.slice(a).map(this.str(b,c))),a.toString().split(/[\\s,]+/).filter(function(a){return a.length})},u.prototype.array=function(a){a=a;var b=this;return this.nodes.reduce(function(c,d,e){var f;return a?(f=a.call(b,d,e),f||(f=!1),"string"==typeof f&&(f=u(f)),f instanceof u&&(f=f.nodes)):f=d.innerHTML,c.concat(f!==!1?f:[])},[])},u.prototype.attr=function(a,b,c){return c=c?"data-":"",this.pairs(a,b,function(a,b){return a.getAttribute(c+b)},function(a,b,d){a.setAttribute(c+b,d)})},u.prototype.before=function(a,b){return this.adjacent(a,b,function(a,b){a.parentNode.insertBefore(b,a)})},u.prototype.children=function(a){return this.map(function(a){return this.slice(a.children)}).filter(a)},u.prototype.clone=function(){return this.map(function(a,b){var c=a.cloneNode(!0),d=this.getAll(c);return this.getAll(a).each(function(a,b){for(var c in this.mirror)this.mirror[c](a,d.nodes[b])}),c})},u.prototype.getAll=function(a){return u([a].concat(u("*",a).nodes))},u.prototype.mirror={},u.prototype.mirror.events=function(a,b){if(a._e)for(var c in a._e)a._e[c].forEach(function(a){u(b).on(c,a)})},u.prototype.mirror.select=function(a,b){u(a).is("select")&&(b.value=a.value)},u.prototype.mirror.textarea=function(a,b){u(a).is("textarea")&&(b.value=a.value)},u.prototype.closest=function(a){return this.map(function(b){do if(u(b).is(a))return b;while((b=b.parentNode)&&b!==document)})},u.prototype.data=function(a,b){return this.attr(a,b,!0)},u.prototype.each=function(a){return this.nodes.forEach(a.bind(this)),this},u.prototype.eacharg=function(a,b){return this.each(function(c,d){this.args(a,c,d).forEach(function(a){b.call(this,c,a)},this)})},u.prototype.empty=function(){return this.each(function(a){for(;a.firstChild;)a.removeChild(a.firstChild)})},u.prototype.filter=function(a){var b=function(b){return b.matches=b.matches||b.msMatchesSelector||b.webkitMatchesSelector,b.matches(a||"*")};return"function"==typeof a&&(b=a),a instanceof u&&(b=function(b){return a.nodes.indexOf(b)!==-1}),u(this.nodes.filter(b))},u.prototype.find=function(a){return this.map(function(b){return u(a||"*",b)})},u.prototype.first=function(){return this.nodes[0]||!1},u.prototype.generate=function(a){return/^\\s*<t(h|r|d)/.test(a)?u(document.createElement("table")).html(a).children().nodes:/^\\s*</.test(a)?u(document.createElement("div")).html(a).children().nodes:document.createTextNode(a)},u.prototype.handle=function(){var a=this.slice(arguments).map(function(a){return"function"==typeof a?function(b){b.preventDefault(),a.apply(this,arguments)}:a},this);return this.on.apply(this,a)},u.prototype.hasClass=function(){return this.is("."+this.args(arguments).join("."))},u.prototype.html=function(a){return void 0===a?this.first().innerHTML||"":this.each(function(b){b.innerHTML=a})},u.prototype.is=function(a){return this.filter(a).length>0},u.prototype.isInPage=function(a){return a!==document.body&&document.body.contains(a)},u.prototype.last=function(){return this.nodes[this.length-1]||!1},u.prototype.map=function(a){return a?u(this.array(a)).unique():this},u.prototype.not=function(a){return this.filter(function(b){return!u(b).is(a||!0)})},u.prototype.off=function(a){return this.eacharg(a,function(a,b){u(a._e?a._e[b]:[]).each(function(c){a.removeEventListener(b,c)})})},u.prototype.on=function(a,b,c){if("string"==typeof b){var d=b;b=function(a){var b=arguments;u(a.currentTarget).find(d).each(function(d){if(d===a.target||d.contains(a.target)){try{Object.defineProperty(a,"currentTarget",{get:function(){return d}})}catch(e){}c.apply(d,b)}})}}var e=function(a){return b.apply(this,[a].concat(a.detail||[]))};return this.eacharg(a,function(a,b){a.addEventListener(b,e),a._e=a._e||{},a._e[b]=a._e[b]||[],a._e[b].push(e)})},u.prototype.pairs=function(a,b,c,d){if("undefined"!=typeof b){var e=a;a={},a[e]=b}return"object"==typeof a?this.each(function(b){for(var c in a)d(b,c,a[c])}):this.length?c(this.first(),a):""},u.prototype.param=function(a){return Object.keys(a).map(function(b){return this.uri(b)+"="+this.uri(a[b])}.bind(this)).join("&")},u.prototype.parent=function(a){return this.map(function(a){return a.parentNode}).filter(a)},u.prototype.prepend=function(a,b){return this.adjacent(a,b,function(a,b){a.insertBefore(b,a.firstChild)})},u.prototype.remove=function(){return this.each(function(a){a.parentNode&&a.parentNode.removeChild(a)})},u.prototype.removeClass=function(){return this.eacharg(arguments,function(a,b){a.classList.remove(b)})},u.prototype.replace=function(a,b){var c=[];return this.adjacent(a,b,function(a,b){c=c.concat(this.slice(b.children)),a.parentNode.replaceChild(b,a)}),u(c)},u.prototype.scroll=function(){return this.first().scrollIntoView({behavior:"smooth"}),this},u.prototype.select=function(a,b){if(a=a.replace(/^\\s*/,"").replace(/\\s*$/,""),b)return this.select.byCss(a,b);for(var c in this.selectors)if(b=c.split("/"),new RegExp(b[1],b[2]).test(a))return this.selectors[c](a);return this.select.byCss(a)},u.prototype.select.byCss=function(a,b){return(b||document).querySelectorAll(a)},u.prototype.selectors={},u.prototype.selectors[/^\\.[\\w\\-]+$/]=function(a){return document.getElementsByClassName(a.substring(1))},u.prototype.selectors[/^\\w+$/]=function(a){return document.getElementsByTagName(a)},u.prototype.selectors[/^\\#[\\w\\-]+$/]=function(a){return document.getElementById(a.substring(1))},u.prototype.selectors[/^</]=function(a){return u().generate(a)},u.prototype.serialize=function(){var a=this;return this.slice(this.first().elements).reduce(function(b,c){return!c.name||c.disabled||"file"===c.type?b:/(checkbox|radio)/.test(c.type)&&!c.checked?b:"select-multiple"===c.type?(u(c.options).each(function(d){d.selected&&(b+="&"+a.uri(c.name)+"="+a.uri(d.value))}),b):b+"&"+a.uri(c.name)+"="+a.uri(c.value)},"").slice(1)},u.prototype.siblings=function(a){return this.parent().children(a).not(this)},u.prototype.size=function(){return this.first().getBoundingClientRect()},u.prototype.slice=function(a){return a&&0!==a.length&&"string"!=typeof a&&"[object Function]"!==a.toString()?a.length?[].slice.call(a.nodes||a):[a]:[]},u.prototype.str=function(a,b){return function(c){return"function"==typeof c?c.call(this,a,b):c.toString()}},u.prototype.text=function(a){return void 0===a?this.first().textContent||"":this.each(function(b){b.textContent=a})},u.prototype.toggleClass=function(a,b){return!!b===b?this[b?"addClass":"removeClass"](a):this.eacharg(a,function(a,b){a.classList.toggle(b)})},u.prototype.trigger=function(a){var b=this.slice(arguments).slice(1);return this.eacharg(a,function(a,c){var d,e={bubbles:!0,cancelable:!0,detail:b};try{d=new window.CustomEvent(c,e)}catch(f){d=document.createEvent("CustomEvent"),d.initCustomEvent(c,!0,!0,b)}a.dispatchEvent(d)})},u.prototype.unique=function(){return u(this.nodes.reduce(function(a,b){var c=null!==b&&void 0!==b&&b!==!1;return c&&a.indexOf(b)===-1?a.concat(b):a},[]))},u.prototype.uri=function(a){return encodeURIComponent(a).replace(/!/g,"%21").replace(/\'/g,"%27").replace(/\\(/g,"%28").replace(/\\)/g,"%29").replace(/\\*/g,"%2A").replace(/%20/g,"+")},u.prototype.wrap=function(a){function b(a){for(;a.firstElementChild;)a=a.firstElementChild;return u(a)}return this.map(function(c){return u(a).each(function(a){b(a).append(c.cloneNode(!0)),c.parentNode.replaceChild(a,c)})})},"object"==typeof module&&module.exports&&(module.exports={u:u,ajax:ajax});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW1icmVsbGFqcy91bWJyZWxsYS5taW4uanM/ZmE4MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHVCQUF1QixpQkFBaUIsUUFBUSxrQkFBa0IsaUVBQWlFLGlaQUFpWixnQ0FBZ0MseUNBQXlDLG9CQUFvQix1QkFBdUIsMkZBQTJGLGdCQUFnQiwwQ0FBMEMsMERBQTBELGdDQUFnQyxzQkFBc0IsSUFBSSxvQkFBb0Isa0NBQWtDLFVBQVUsU0FBUyxvQkFBb0IsdUpBQXVKLGFBQWEsYUFBYSwwQkFBMEIsc0RBQXNELDRDQUE0QyxtQkFBbUIsRUFBRSxzQ0FBc0Msc0hBQXNILHdDQUF3QyxPQUFPLG9CQUFvQixrREFBa0QsK0NBQStDLG1CQUFtQixzRUFBc0UsbUJBQW1CLEVBQUUsaUNBQWlDLHVDQUF1QywyQ0FBMkMsRUFBRSxnQ0FBZ0Msd0NBQXdDLDZCQUE2Qix1REFBdUQsa0NBQWtDLEVBQUUsa0NBQWtDLHVDQUF1QyxpQkFBaUIsRUFBRSxrQ0FBa0MsZ0pBQWdKLGdCQUFnQixFQUFFLCtCQUErQixJQUFJLFdBQVcseUNBQXlDLE1BQU0sa0lBQWtJLEtBQUssa0NBQWtDLG1EQUFtRCwyQkFBMkIsaUJBQWlCLHNCQUFzQixFQUFFLGtDQUFrQyx1Q0FBdUMsK0JBQStCLEVBQUUsa0NBQWtDLDRCQUE0Qiw4QkFBOEIsWUFBWSw4QkFBOEIsOEJBQThCLHVDQUF1Qyx5Q0FBeUMsc0RBQXNELElBQUksRUFBRSxnQ0FBZ0MscUNBQXFDLHNCQUFzQix5Q0FBeUMsc0RBQXNELGFBQWEsRUFBRSx5Q0FBeUMscUNBQXFDLDJDQUEyQyx1Q0FBdUMsaUNBQWlDLDRCQUE0QiwwQkFBMEIsc0NBQXNDLEVBQUUsZ0NBQWdDLHlCQUF5Qiw4QkFBOEIsNkNBQTZDLG1DQUFtQywrQkFBK0IscUNBQXFDLGlCQUFpQixPQUFPLEVBQUUsOEJBQThCLDZCQUE2QixLQUFLLGFBQWEsNkJBQTZCLEVBQUUsZ0NBQWdDLGtCQUFrQiw0RkFBNEYsaUVBQWlFLCtCQUErQiwwQkFBMEIsOEJBQThCLDRCQUE0QixtQkFBbUIsRUFBRSw4QkFBOEIseUJBQXlCLGtDQUFrQywrTEFBK0wsK0JBQStCLDRDQUE0Qyx1Q0FBdUMsMkNBQTJDLEdBQUcsT0FBTyw2QkFBNkIsaUNBQWlDLG1EQUFtRCw4QkFBOEIsbUVBQW1FLGNBQWMsRUFBRSw0QkFBNEIsK0JBQStCLGtDQUFrQyxvREFBb0QsNkJBQTZCLHFDQUFxQyw2QkFBNkIsd0NBQXdDLDZCQUE2QiwrQkFBK0Isc0JBQXNCLEVBQUUsNkJBQTZCLG9DQUFvQyxvQ0FBb0MsMkJBQTJCLEVBQUUsRUFBRSxnQ0FBZ0MsdUJBQXVCLFFBQVEsY0FBYyxnQkFBZ0IsNENBQTRDLHVDQUF1QyxJQUFJLHlDQUF5QyxlQUFlLFVBQVUsRUFBRSxVQUFVLGNBQWMsR0FBRyxrQkFBa0IsK0NBQStDLG9DQUFvQyxxQ0FBcUMscUNBQXFDLEVBQUUscUNBQXFDLDBCQUEwQixRQUFRLElBQUksUUFBUSwrQ0FBK0MsMkJBQTJCLG1DQUFtQywrQkFBK0Isc0NBQXNDLHNDQUFzQyx1QkFBdUIsZ0NBQWdDLDRCQUE0QixvQkFBb0IsWUFBWSxtQ0FBbUMsdUNBQXVDLCtCQUErQixFQUFFLCtCQUErQiw2QkFBNkIsMENBQTBDLEVBQUUsb0NBQW9DLDRDQUE0QyxzQkFBc0IsRUFBRSxtQ0FBbUMsU0FBUyx1Q0FBdUMsa0VBQWtFLE9BQU8sK0JBQStCLG9DQUFvQyxrQkFBa0IsT0FBTyxrQ0FBa0MsNkVBQTZFLHdHQUF3Ryw0QkFBNEIsd0NBQXdDLHdDQUF3Qyx5QkFBeUIsa0RBQWtELHVEQUF1RCw0Q0FBNEMsd0NBQXdDLGtEQUFrRCwrQ0FBK0MseUNBQXlDLHVCQUF1QixrQ0FBa0MsV0FBVyw4REFBOEQscUpBQXFKLHNEQUFzRCw0Q0FBNEMsY0FBYyxrQ0FBa0MsMkNBQTJDLDZCQUE2Qiw0Q0FBNEMsK0JBQStCLHlIQUF5SCwrQkFBK0IsbUJBQW1CLDBEQUEwRCw4QkFBOEIscUVBQXFFLGdCQUFnQixFQUFFLHVDQUF1QywrRUFBK0Usc0JBQXNCLEVBQUUsaUNBQWlDLHFDQUFxQyxvQ0FBb0MsU0FBUyxtQ0FBbUMsSUFBSSw4QkFBOEIsU0FBUyxtRUFBbUUsbUJBQW1CLEVBQUUsK0JBQStCLHlDQUF5QyxtQ0FBbUMsMENBQTBDLE1BQU0sNkJBQTZCLHdKQUF3Siw4QkFBOEIsY0FBYyxLQUFLLG9CQUFvQix1QkFBdUIsWUFBWSw0QkFBNEIsNkJBQTZCLDREQUE0RCxFQUFFLEVBQUUsMkRBQTJELGNBQWMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIFVtYnJlbGxhIEpTIDIuMTAuMCB1bWJyZWxsYWpzLmNvbSAqL1xuZnVuY3Rpb24gYWpheChhLGIsYyxkKXtjPWN8fGZ1bmN0aW9uKCl7fSxiPWJ8fHt9LGIuYm9keT1iLmJvZHl8fHt9LGIubWV0aG9kPShiLm1ldGhvZHx8XCJHRVRcIikudG9VcHBlckNhc2UoKSxiLmhlYWRlcnM9Yi5oZWFkZXJzfHx7fSxiLmhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPWIuaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl18fFwiWE1MSHR0cFJlcXVlc3RcIixcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93LkZvcm1EYXRhJiZiLmJvZHkgaW5zdGFuY2VvZiB3aW5kb3cuRm9ybURhdGF8fChiLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl09Yi5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdfHxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSwvanNvbi8udGVzdChiLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pJiYoYi5ib2R5PUpTT04uc3RyaW5naWZ5KGIuYm9keSkpLFwib2JqZWN0XCIhPXR5cGVvZiBiLmJvZHl8fGIuYm9keSBpbnN0YW5jZW9mIHdpbmRvdy5Gb3JtRGF0YXx8KGIuYm9keT11KCkucGFyYW0oYi5ib2R5KSk7dmFyIGU9bmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDt1KGUpLm9uKFwiZXJyb3IgdGltZW91dCBhYm9ydFwiLGZ1bmN0aW9uKCl7YyhuZXcgRXJyb3IsbnVsbCxlKX0pLm9uKFwibG9hZFwiLGZ1bmN0aW9uKCl7dmFyIGE9L14oNHw1KS8udGVzdChlLnN0YXR1cyk/bmV3IEVycm9yKGUuc3RhdHVzKTpudWxsLGI9cGFyc2VKc29uKGUucmVzcG9uc2UpfHxlLnJlc3BvbnNlO3JldHVybiBjKGEsYixlKX0pLGUub3BlbihiLm1ldGhvZCxhKSxlLndpdGhDcmVkZW50aWFscz0hMDtmb3IodmFyIGYgaW4gYi5oZWFkZXJzKWUuc2V0UmVxdWVzdEhlYWRlcihmLGIuaGVhZGVyc1tmXSk7cmV0dXJuIGQmJmQoZSksZS5zZW5kKGIuYm9keSksZX1mdW5jdGlvbiBwYXJzZUpzb24oYSl7dHJ5e3ZhciBiPUpTT04ucGFyc2UoYSk7aWYoYiYmXCJvYmplY3RcIj09dHlwZW9mIGIpcmV0dXJuIGJ9Y2F0Y2goYyl7fXJldHVybiExfXZhciB1PWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiB1P2EgaW5zdGFuY2VvZiB1P2E6KFwic3RyaW5nXCI9PXR5cGVvZiBhJiYoYT10aGlzLnNlbGVjdChhLGIpKSxhJiZhLm5vZGVOYW1lJiYoYT1bYV0pLHZvaWQodGhpcy5ub2Rlcz10aGlzLnNsaWNlKGEpKSk6bmV3IHUoYSxiKX07dS5wcm90b3R5cGU9e2dldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGh9fSx1LnByb3RvdHlwZS5ub2Rlcz1bXSx1LnByb3RvdHlwZS5hZGRDbGFzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2hhcmcoYXJndW1lbnRzLGZ1bmN0aW9uKGEsYil7YS5jbGFzc0xpc3QuYWRkKGIpfSl9LHUucHJvdG90eXBlLmFkamFjZW50PWZ1bmN0aW9uKGEsYixjKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYiYmKGI9MD09PWI/W106bmV3IEFycmF5KGIpLmpvaW4oKS5zcGxpdChcIixcIikubWFwKE51bWJlci5jYWxsLE51bWJlcikpLHRoaXMuZWFjaChmdW5jdGlvbihkLGUpe3ZhciBmPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt1KGJ8fHt9KS5tYXAoZnVuY3Rpb24oYixjKXt2YXIgZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2EuY2FsbCh0aGlzLGIsYyxkLGUpOmE7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGY/dGhpcy5nZW5lcmF0ZShmKTp1KGYpfSkuZWFjaChmdW5jdGlvbihhKXt0aGlzLmlzSW5QYWdlKGEpP2YuYXBwZW5kQ2hpbGQodShhKS5jbG9uZSgpLmZpcnN0KCkpOmYuYXBwZW5kQ2hpbGQoYSl9KSxjLmNhbGwodGhpcyxkLGYpfSl9LHUucHJvdG90eXBlLmFmdGVyPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuYWRqYWNlbnQoYSxiLGZ1bmN0aW9uKGEsYil7YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGEubmV4dFNpYmxpbmcpfSl9LHUucHJvdG90eXBlLmFqYXg9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5oYW5kbGUoXCJzdWJtaXRcIixmdW5jdGlvbihjKXthamF4KHUodGhpcykuYXR0cihcImFjdGlvblwiKSx7Ym9keTp1KHRoaXMpLnNlcmlhbGl6ZSgpLG1ldGhvZDp1KHRoaXMpLmF0dHIoXCJtZXRob2RcIil9LGEmJmEuYmluZCh0aGlzKSxiJiZiLmJpbmQodGhpcykpfSl9LHUucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLmFkamFjZW50KGEsYixmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9KX0sdS5wcm90b3R5cGUuYXJncz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYSYmKGE9YShiLGMpKSxcInN0cmluZ1wiIT10eXBlb2YgYSYmKGE9dGhpcy5zbGljZShhKS5tYXAodGhpcy5zdHIoYixjKSkpLGEudG9TdHJpbmcoKS5zcGxpdCgvW1xccyxdKy8pLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYS5sZW5ndGh9KX0sdS5wcm90b3R5cGUuYXJyYXk9ZnVuY3Rpb24oYSl7YT1hO3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKGZ1bmN0aW9uKGMsZCxlKXt2YXIgZjtyZXR1cm4gYT8oZj1hLmNhbGwoYixkLGUpLGZ8fChmPSExKSxcInN0cmluZ1wiPT10eXBlb2YgZiYmKGY9dShmKSksZiBpbnN0YW5jZW9mIHUmJihmPWYubm9kZXMpKTpmPWQuaW5uZXJIVE1MLGMuY29uY2F0KGYhPT0hMT9mOltdKX0sW10pfSx1LnByb3RvdHlwZS5hdHRyPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYz1jP1wiZGF0YS1cIjpcIlwiLHRoaXMucGFpcnMoYSxiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZ2V0QXR0cmlidXRlKGMrYil9LGZ1bmN0aW9uKGEsYixkKXthLnNldEF0dHJpYnV0ZShjK2IsZCl9KX0sdS5wcm90b3R5cGUuYmVmb3JlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuYWRqYWNlbnQoYSxiLGZ1bmN0aW9uKGEsYil7YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGEpfSl9LHUucHJvdG90eXBlLmNoaWxkcmVuPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zbGljZShhLmNoaWxkcmVuKX0pLmZpbHRlcihhKX0sdS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmNsb25lTm9kZSghMCksZD10aGlzLmdldEFsbChjKTtyZXR1cm4gdGhpcy5nZXRBbGwoYSkuZWFjaChmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyBpbiB0aGlzLm1pcnJvcil0aGlzLm1pcnJvcltjXShhLGQubm9kZXNbYl0pfSksY30pfSx1LnByb3RvdHlwZS5nZXRBbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIHUoW2FdLmNvbmNhdCh1KFwiKlwiLGEpLm5vZGVzKSl9LHUucHJvdG90eXBlLm1pcnJvcj17fSx1LnByb3RvdHlwZS5taXJyb3IuZXZlbnRzPWZ1bmN0aW9uKGEsYil7aWYoYS5fZSlmb3IodmFyIGMgaW4gYS5fZSlhLl9lW2NdLmZvckVhY2goZnVuY3Rpb24oYSl7dShiKS5vbihjLGEpfSl9LHUucHJvdG90eXBlLm1pcnJvci5zZWxlY3Q9ZnVuY3Rpb24oYSxiKXt1KGEpLmlzKFwic2VsZWN0XCIpJiYoYi52YWx1ZT1hLnZhbHVlKX0sdS5wcm90b3R5cGUubWlycm9yLnRleHRhcmVhPWZ1bmN0aW9uKGEsYil7dShhKS5pcyhcInRleHRhcmVhXCIpJiYoYi52YWx1ZT1hLnZhbHVlKX0sdS5wcm90b3R5cGUuY2xvc2VzdD1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oYil7ZG8gaWYodShiKS5pcyhhKSlyZXR1cm4gYjt3aGlsZSgoYj1iLnBhcmVudE5vZGUpJiZiIT09ZG9jdW1lbnQpfSl9LHUucHJvdG90eXBlLmRhdGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hdHRyKGEsYiwhMCl9LHUucHJvdG90eXBlLmVhY2g9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubm9kZXMuZm9yRWFjaChhLmJpbmQodGhpcykpLHRoaXN9LHUucHJvdG90eXBlLmVhY2hhcmc9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGMsZCl7dGhpcy5hcmdzKGEsYyxkKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2IuY2FsbCh0aGlzLGMsYSl9LHRoaXMpfSl9LHUucHJvdG90eXBlLmVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihhKXtmb3IoO2EuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpfSl9LHUucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihiKXtyZXR1cm4gYi5tYXRjaGVzPWIubWF0Y2hlc3x8Yi5tc01hdGNoZXNTZWxlY3Rvcnx8Yi53ZWJraXRNYXRjaGVzU2VsZWN0b3IsYi5tYXRjaGVzKGF8fFwiKlwiKX07cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYSYmKGI9YSksYSBpbnN0YW5jZW9mIHUmJihiPWZ1bmN0aW9uKGIpe3JldHVybiBhLm5vZGVzLmluZGV4T2YoYikhPT0tMX0pLHUodGhpcy5ub2Rlcy5maWx0ZXIoYikpfSx1LnByb3RvdHlwZS5maW5kPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbihiKXtyZXR1cm4gdShhfHxcIipcIixiKX0pfSx1LnByb3RvdHlwZS5maXJzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzWzBdfHwhMX0sdS5wcm90b3R5cGUuZ2VuZXJhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuL15cXHMqPHQoaHxyfGQpLy50ZXN0KGEpP3UoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpKS5odG1sKGEpLmNoaWxkcmVuKCkubm9kZXM6L15cXHMqPC8udGVzdChhKT91KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLmh0bWwoYSkuY2hpbGRyZW4oKS5ub2Rlczpkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKX0sdS5wcm90b3R5cGUuaGFuZGxlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zbGljZShhcmd1bWVudHMpLm1hcChmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2Z1bmN0aW9uKGIpe2IucHJldmVudERlZmF1bHQoKSxhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX06YX0sdGhpcyk7cmV0dXJuIHRoaXMub24uYXBwbHkodGhpcyxhKX0sdS5wcm90b3R5cGUuaGFzQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pcyhcIi5cIit0aGlzLmFyZ3MoYXJndW1lbnRzKS5qb2luKFwiLlwiKSl9LHUucHJvdG90eXBlLmh0bWw9ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWE/dGhpcy5maXJzdCgpLmlubmVySFRNTHx8XCJcIjp0aGlzLmVhY2goZnVuY3Rpb24oYil7Yi5pbm5lckhUTUw9YX0pfSx1LnByb3RvdHlwZS5pcz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5maWx0ZXIoYSkubGVuZ3RoPjB9LHUucHJvdG90eXBlLmlzSW5QYWdlPWZ1bmN0aW9uKGEpe3JldHVybiBhIT09ZG9jdW1lbnQuYm9keSYmZG9jdW1lbnQuYm9keS5jb250YWlucyhhKX0sdS5wcm90b3R5cGUubGFzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzW3RoaXMubGVuZ3RoLTFdfHwhMX0sdS5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKGEpe3JldHVybiBhP3UodGhpcy5hcnJheShhKSkudW5pcXVlKCk6dGhpc30sdS5wcm90b3R5cGUubm90PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4hdShiKS5pcyhhfHwhMCl9KX0sdS5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2hhcmcoYSxmdW5jdGlvbihhLGIpe3UoYS5fZT9hLl9lW2JdOltdKS5lYWNoKGZ1bmN0aW9uKGMpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihiLGMpfSl9KX0sdS5wcm90b3R5cGUub249ZnVuY3Rpb24oYSxiLGMpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBiKXt2YXIgZD1iO2I9ZnVuY3Rpb24oYSl7dmFyIGI9YXJndW1lbnRzO3UoYS5jdXJyZW50VGFyZ2V0KS5maW5kKGQpLmVhY2goZnVuY3Rpb24oZCl7aWYoZD09PWEudGFyZ2V0fHxkLmNvbnRhaW5zKGEudGFyZ2V0KSl7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiY3VycmVudFRhcmdldFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZH19KX1jYXRjaChlKXt9Yy5hcHBseShkLGIpfX0pfX12YXIgZT1mdW5jdGlvbihhKXtyZXR1cm4gYi5hcHBseSh0aGlzLFthXS5jb25jYXQoYS5kZXRhaWx8fFtdKSl9O3JldHVybiB0aGlzLmVhY2hhcmcoYSxmdW5jdGlvbihhLGIpe2EuYWRkRXZlbnRMaXN0ZW5lcihiLGUpLGEuX2U9YS5fZXx8e30sYS5fZVtiXT1hLl9lW2JdfHxbXSxhLl9lW2JdLnB1c2goZSl9KX0sdS5wcm90b3R5cGUucGFpcnM9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGIpe3ZhciBlPWE7YT17fSxhW2VdPWJ9cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGE/dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe2Zvcih2YXIgYyBpbiBhKWQoYixjLGFbY10pfSk6dGhpcy5sZW5ndGg/Yyh0aGlzLmZpcnN0KCksYSk6XCJcIn0sdS5wcm90b3R5cGUucGFyYW09ZnVuY3Rpb24oYSl7cmV0dXJuIE9iamVjdC5rZXlzKGEpLm1hcChmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy51cmkoYikrXCI9XCIrdGhpcy51cmkoYVtiXSl9LmJpbmQodGhpcykpLmpvaW4oXCImXCIpfSx1LnByb3RvdHlwZS5wYXJlbnQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLnBhcmVudE5vZGV9KS5maWx0ZXIoYSl9LHUucHJvdG90eXBlLnByZXBlbmQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5hZGphY2VudChhLGIsZnVuY3Rpb24oYSxiKXthLmluc2VydEJlZm9yZShiLGEuZmlyc3RDaGlsZCl9KX0sdS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihhKXthLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKX0pfSx1LnByb3RvdHlwZS5yZW1vdmVDbGFzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVhY2hhcmcoYXJndW1lbnRzLGZ1bmN0aW9uKGEsYil7YS5jbGFzc0xpc3QucmVtb3ZlKGIpfSl9LHUucHJvdG90eXBlLnJlcGxhY2U9ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXTtyZXR1cm4gdGhpcy5hZGphY2VudChhLGIsZnVuY3Rpb24oYSxiKXtjPWMuY29uY2F0KHRoaXMuc2xpY2UoYi5jaGlsZHJlbikpLGEucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYixhKX0pLHUoYyl9LHUucHJvdG90eXBlLnNjcm9sbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZpcnN0KCkuc2Nyb2xsSW50b1ZpZXcoe2JlaGF2aW9yOlwic21vb3RoXCJ9KSx0aGlzfSx1LnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24oYSxiKXtpZihhPWEucmVwbGFjZSgvXlxccyovLFwiXCIpLnJlcGxhY2UoL1xccyokLyxcIlwiKSxiKXJldHVybiB0aGlzLnNlbGVjdC5ieUNzcyhhLGIpO2Zvcih2YXIgYyBpbiB0aGlzLnNlbGVjdG9ycylpZihiPWMuc3BsaXQoXCIvXCIpLG5ldyBSZWdFeHAoYlsxXSxiWzJdKS50ZXN0KGEpKXJldHVybiB0aGlzLnNlbGVjdG9yc1tjXShhKTtyZXR1cm4gdGhpcy5zZWxlY3QuYnlDc3MoYSl9LHUucHJvdG90eXBlLnNlbGVjdC5ieUNzcz1mdW5jdGlvbihhLGIpe3JldHVybihifHxkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChhKX0sdS5wcm90b3R5cGUuc2VsZWN0b3JzPXt9LHUucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcLltcXHdcXC1dKyQvXT1mdW5jdGlvbihhKXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhLnN1YnN0cmluZygxKSl9LHUucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcdyskL109ZnVuY3Rpb24oYSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpfSx1LnByb3RvdHlwZS5zZWxlY3RvcnNbL15cXCNbXFx3XFwtXSskL109ZnVuY3Rpb24oYSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEuc3Vic3RyaW5nKDEpKX0sdS5wcm90b3R5cGUuc2VsZWN0b3JzWy9ePC9dPWZ1bmN0aW9uKGEpe3JldHVybiB1KCkuZ2VuZXJhdGUoYSl9LHUucHJvdG90eXBlLnNlcmlhbGl6ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuc2xpY2UodGhpcy5maXJzdCgpLmVsZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24oYixjKXtyZXR1cm4hYy5uYW1lfHxjLmRpc2FibGVkfHxcImZpbGVcIj09PWMudHlwZT9iOi8oY2hlY2tib3h8cmFkaW8pLy50ZXN0KGMudHlwZSkmJiFjLmNoZWNrZWQ/YjpcInNlbGVjdC1tdWx0aXBsZVwiPT09Yy50eXBlPyh1KGMub3B0aW9ucykuZWFjaChmdW5jdGlvbihkKXtkLnNlbGVjdGVkJiYoYis9XCImXCIrYS51cmkoYy5uYW1lKStcIj1cIithLnVyaShkLnZhbHVlKSl9KSxiKTpiK1wiJlwiK2EudXJpKGMubmFtZSkrXCI9XCIrYS51cmkoYy52YWx1ZSl9LFwiXCIpLnNsaWNlKDEpfSx1LnByb3RvdHlwZS5zaWJsaW5ncz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbihhKS5ub3QodGhpcyl9LHUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maXJzdCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpfSx1LnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihhKXtyZXR1cm4gYSYmMCE9PWEubGVuZ3RoJiZcInN0cmluZ1wiIT10eXBlb2YgYSYmXCJbb2JqZWN0IEZ1bmN0aW9uXVwiIT09YS50b1N0cmluZygpP2EubGVuZ3RoP1tdLnNsaWNlLmNhbGwoYS5ub2Rlc3x8YSk6W2FdOltdfSx1LnByb3RvdHlwZS5zdHI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYz9jLmNhbGwodGhpcyxhLGIpOmMudG9TdHJpbmcoKX19LHUucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWE/dGhpcy5maXJzdCgpLnRleHRDb250ZW50fHxcIlwiOnRoaXMuZWFjaChmdW5jdGlvbihiKXtiLnRleHRDb250ZW50PWF9KX0sdS5wcm90b3R5cGUudG9nZ2xlQ2xhc3M9ZnVuY3Rpb24oYSxiKXtyZXR1cm4hIWI9PT1iP3RoaXNbYj9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShhKTp0aGlzLmVhY2hhcmcoYSxmdW5jdGlvbihhLGIpe2EuY2xhc3NMaXN0LnRvZ2dsZShiKX0pfSx1LnByb3RvdHlwZS50cmlnZ2VyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2xpY2UoYXJndW1lbnRzKS5zbGljZSgxKTtyZXR1cm4gdGhpcy5lYWNoYXJnKGEsZnVuY3Rpb24oYSxjKXt2YXIgZCxlPXtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsZGV0YWlsOmJ9O3RyeXtkPW5ldyB3aW5kb3cuQ3VzdG9tRXZlbnQoYyxlKX1jYXRjaChmKXtkPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIiksZC5pbml0Q3VzdG9tRXZlbnQoYywhMCwhMCxiKX1hLmRpc3BhdGNoRXZlbnQoZCl9KX0sdS5wcm90b3R5cGUudW5pcXVlPWZ1bmN0aW9uKCl7cmV0dXJuIHUodGhpcy5ub2Rlcy5yZWR1Y2UoZnVuY3Rpb24oYSxiKXt2YXIgYz1udWxsIT09YiYmdm9pZCAwIT09YiYmYiE9PSExO3JldHVybiBjJiZhLmluZGV4T2YoYik9PT0tMT9hLmNvbmNhdChiKTphfSxbXSkpfSx1LnByb3RvdHlwZS51cmk9ZnVuY3Rpb24oYSl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChhKS5yZXBsYWNlKC8hL2csXCIlMjFcIikucmVwbGFjZSgvJy9nLFwiJTI3XCIpLnJlcGxhY2UoL1xcKC9nLFwiJTI4XCIpLnJlcGxhY2UoL1xcKS9nLFwiJTI5XCIpLnJlcGxhY2UoL1xcKi9nLFwiJTJBXCIpLnJlcGxhY2UoLyUyMC9nLFwiK1wiKX0sdS5wcm90b3R5cGUud3JhcD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2Zvcig7YS5maXJzdEVsZW1lbnRDaGlsZDspYT1hLmZpcnN0RWxlbWVudENoaWxkO3JldHVybiB1KGEpfXJldHVybiB0aGlzLm1hcChmdW5jdGlvbihjKXtyZXR1cm4gdShhKS5lYWNoKGZ1bmN0aW9uKGEpe2IoYSkuYXBwZW5kKGMuY2xvbmVOb2RlKCEwKSksYy5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChhLGMpfSl9KX0sXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHMmJihtb2R1bGUuZXhwb3J0cz17dTp1LGFqYXg6YWpheH0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3VtYnJlbGxhanMvdW1icmVsbGEubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},2:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * validate v1.1.0: A lightweight form validation script that augments native HTML5 form validation elements and attributes.\n * (c) 2017 Chris Ferdinandi\n * MIT License\n * http://github.com/cferdinandi/validate\n */\n\n(function (root, factory) {\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory(root)),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if ( typeof exports === 'object' ) {\n\t\tmodule.exports = factory(root);\n\t} else {\n\t\troot.validate = factory(root);\n\t}\n})(typeof global !== 'undefined' ? global : this.window || this.global, (function (root) {\n\n\t'use strict';\n\n\t//\n\t// Variables\n\t//\n\n\tvar validate = {}; // Object for public APIs\n\tvar supports = 'querySelector' in document && 'addEventListener' in root; // Feature test\n\tvar settings;\n\n\t// Default settings\n\tvar defaults = {\n\n\t\t// Classes and Selectors\n\t\tselector: '[data-validate]',\n\t\tfieldClass: 'error',\n\t\terrorClass: 'error-message',\n\n\t\t// Messages\n\t\tmessageValueMissing: 'Please fill out this field.',\n\t\tmessageValueMissingSelect: 'Please select a value.',\n\t\tmessageValueMissingSelectMulti: 'Please select at least one value.',\n\t\tmessageTypeMismatchEmail: 'Please enter an email address.',\n\t\tmessageTypeMismatchURL: 'Please enter a URL.',\n\t\tmessageTooShort: 'Please lengthen this text to {minLength} characters or more. You are currently using {length} characters.',\n\t\tmessageTooLong: 'Please shorten this text to no more than {maxLength} characters. You are currently using {length} characters.',\n\t\tmessagePatternMismatch: 'Please match the requested format.',\n\t\tmessageBadInput: 'Please enter a number.',\n\t\tmessageStepMismatch: 'Please select a valid value.',\n\t\tmessageRangeOverflow: 'Please select a value that is no more than {max}.',\n\t\tmessageRangeUnderflow: 'Please select a value that is no less than {min}.',\n\t\tmessageGeneric: 'The value you entered for this field is invalid.',\n\n\t\t// Form Submission\n\t\tdisableSubmit: false,\n\t\tonSubmit: function () {},\n\n\t\t// Callbacks\n\t\tbeforeShowError: function () {},\n\t\tafterShowError: function () {},\n\t\tbeforeRemoveError: function () {},\n\t\tafterRemoveError: function () {},\n\n\t};\n\n\n\t//\n\t// Methods\n\t//\n\n\t// Element.matches() polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches =\n\t\t\tElement.prototype.matchesSelector ||\n\t\t\tElement.prototype.mozMatchesSelector ||\n\t\t\tElement.prototype.msMatchesSelector ||\n\t\t\tElement.prototype.oMatchesSelector ||\n\t\t\tElement.prototype.webkitMatchesSelector ||\n\t\t\tfunction(s) {\n\t\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s),\n\t\t\t\t\ti = matches.length;\n\t\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\t\treturn i > -1;\n\t\t\t};\n\t}\n\n\t/**\n\t * Merge two or more objects. Returns a new object.\n\t * @private\n\t * @param {Boolean}  deep     If true, do a deep (or recursive) merge [optional]\n\t * @param {Object}   objects  The objects to merge together\n\t * @returns {Object}          Merged values of defaults and options\n\t */\n\tvar extend = function () {\n\n\t\t// Variables\n\t\tvar extended = {};\n\t\tvar deep = false;\n\t\tvar i = 0;\n\t\tvar length = arguments.length;\n\n\t\t// Check if a deep merge\n\t\tif ( Object.prototype.toString.call( arguments[0] ) === '[object Boolean]' ) {\n\t\t\tdeep = arguments[0];\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge the object into the extended object\n\t\tvar merge = function (obj) {\n\t\t\tfor ( var prop in obj ) {\n\t\t\t\tif ( Object.prototype.hasOwnProperty.call( obj, prop ) ) {\n\t\t\t\t\t// If deep merge and property is an object, merge properties\n\t\t\t\t\tif ( deep && Object.prototype.toString.call(obj[prop]) === '[object Object]' ) {\n\t\t\t\t\t\textended[prop] = extend( true, extended[prop], obj[prop] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\textended[prop] = obj[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Loop through each object and conduct a merge\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tvar obj = arguments[i];\n\t\t\tmerge(obj);\n\t\t}\n\n\t\treturn extended;\n\n\t};\n\n\t/**\n\t * Get the closest matching element up the DOM tree.\n\t * @private\n\t * @param  {Element} elem     Starting element\n\t * @param  {String}  selector Selector to match against\n\t * @return {Boolean|Element}  Returns null if not match found\n\t */\n\tvar getClosest = function ( elem, selector ) {\n\t\tfor ( ; elem && elem !== document; elem = elem.parentNode ) {\n\t\t\tif ( elem.matches( selector ) ) return elem;\n\t\t}\n\t\treturn null;\n\t};\n\n\t/**\n\t * Validate a form field\n\t * @public\n\t * @param  {Node}    field   The field to validate\n\t * @param  {Object}  options User options\n\t * @return {String}          The error message\n\t */\n\tvalidate.hasError = function (field, options) {\n\n\t\t// Merge user options with existing settings or defaults\n\t\tvar localSettings = extend(settings || defaults, options || {});\n\n\t\t// Don't validate submits, buttons, file and reset inputs, and disabled fields\n\t\tif (field.disabled || field.type === 'file' || field.type === 'reset' || field.type === 'submit' || field.type === 'button') return;\n\n\t\t// Get validity\n\t\tvar validity = field.validity;\n\n\t\t// If valid, return null\n\t\tif (validity.valid) return;\n\n\t\t// If field is required and empty\n\t\tif (validity.valueMissing) {\n\t\t\t\n\t\t\tif (field.type === 'select-multiple') return localSettings.messageValueMissingSelectMulti;\n\n\t\t\tif (field.type === 'select-one') return localSettings.messageValueMissingSelect;\n\n\t\t\treturn localSettings.messageValueMissing;\n\t\t}\n\n\t\t// If not the right type\n\t\tif (validity.typeMismatch) {\n\n\t\t\t// Email\n\t\t\tif (field.type === 'email') return localSettings.messageTypeMismatchEmail;\n\n\t\t\t// URL\n\t\t\tif (field.type === 'url') return localSettings.messageTypeMismatchURL;\n\n\t\t}\n\n\t\t// If too short\n\t\tif (validity.tooShort) return localSettings.messageTooShort.replace('{minLength}', field.getAttribute('minLength')).replace('{length}', field.value.length);\n\n\t\t// If too long\n\t\tif (validity.tooLong) return localSettings.messageTooLong.replace('{minLength}', field.getAttribute('maxLength')).replace('{length}', field.value.length);\n\n\t\t// If number input isn't a number\n\t\tif (validity.badInput) return localSettings.messageBadInput;\n\n\t\t// If a number value doesn't match the step interval\n\t\tif (validity.stepMismatch) return localSettings.messageStepMismatch;\n\n\t\t// If a number field is over the max\n\t\tif (validity.rangeOverflow) return localSettings.messageRangeOverflow.replace('{max}', field.getAttribute('max'));\n\n\t\t// If a number field is below the min\n\t\tif (validity.rangeUnderflow) return localSettings.messageRangeUnderflow.replace('{min}', field.getAttribute('min'));\n\n\t\t// If pattern doesn't match\n\t\tif (validity.patternMismatch) {\n\n\t\t\t// If pattern info is included, return custom error\n\t\t\tif (field.hasAttribute('title')) return field.getAttribute('title');\n\n\t\t\t// Otherwise, generic error\n\t\t\treturn localSettings.messagePatternMismatch;\n\n\t\t}\n\n\t\t// If all else fails, return a generic catchall error\n\t\treturn localSettings.messageGeneric;\n\n\t};\n\n\t/**\n\t * Show an error message on a field\n\t * @public\n\t * @param  {Node}   field   The field to show an error message for\n\t * @param  {String} error   The error message to show\n\t * @param  {Object} options User options\n\t */\n\tvalidate.showError = function (field, error, options) {\n\n\t\t// Merge user options with existing settings or defaults\n\t\tvar localSettings = extend(settings || defaults, options || {});\n\n\t\t// Before show error callback\n\t\tlocalSettings.beforeShowError(field, error);\n\n\t\t// Add error class to field\n\t\tfield.classList.add(localSettings.fieldClass);\n\n\t\t// If the field is a radio button and part of a group, error all and get the last item in the group\n\t\tif (field.type === 'radio' && field.name) {\n\t\t\tvar group = document.getElementsByName(field.name);\n\t\t\tif (group.length > 0) {\n\t\t\t\tfor (var i = 0; i < group.length; i++) {\n\t\t\t\t\tif (group[i].form !== field.form) continue; // Only check fields in current form\n\t\t\t\t\tgroup[i].classList.add(localSettings.fieldClass);\n\t\t\t\t}\n\t\t\t\tfield = group[group.length - 1];\n\t\t\t}\n\t\t}\n\n\t\t// Get field id or name\n\t\tvar id = field.id || field.name;\n\t\tif (!id) return;\n\n\t\t// Check if error message field already exists\n\t\t// If not, create one\n\t\tvar message = field.form.querySelector('.' + localSettings.errorClass + '#error-for-' + id );\n\t\tif (!message) {\n\t\t\tmessage = document.createElement('div');\n\t\t\tmessage.className = localSettings.errorClass;\n\t\t\tmessage.id = 'error-for-' + id;\n\n\t\t\t// If the field is a radio button or checkbox, insert error after the label\n\t\t\tvar label;\n\t\t\tif (field.type === 'radio' || field.type ==='checkbox') {\n\t\t\t\tlabel = field.form.querySelector('label[for=\"' + id + '\"]') || getClosest(field, 'label');\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.parentNode.insertBefore( message, label.nextSibling );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise, insert it after the field\n\t\t\tif (!label) {\n\t\t\t\tfield.parentNode.insertBefore( message, field.nextSibling );\n\t\t\t}\n\t\t}\n\n\t\t// Add ARIA role to the field\n\t\tfield.setAttribute('aria-describedby', 'error-for-' + id);\n\n\t\t// Update error message\n\t\tmessage.innerHTML = error;\n\n\t\t// Remove any existing styles hiding the error message\n\t\tmessage.style.display = '';\n\t\tmessage.style.visibility = '';\n\n\t\t// After show error callback\n\t\tlocalSettings.afterShowError(field, error);\n\n\t};\n\n\t/**\n\t * Remove an error message from a field\n\t * @public\n\t * @param  {Node}   field   The field to remove the error from\n\t * @param  {Object} options User options\n\t */\n\tvalidate.removeError = function (field, options) {\n\n\t\t// Merge user options with existing settings or defaults\n\t\tvar localSettings = extend(settings || defaults, options || {});\n\n\t\t// Before remove error callback\n\t\tlocalSettings.beforeRemoveError(field);\n\n\t\t// Remove ARIA role from the field\n\t\tfield.removeAttribute('aria-describedby');\n\n\t\t// Remove error class to field\n\t\tfield.classList.remove(localSettings.fieldClass);\n\n\t\t// If the field is a radio button and part of a group, remove error from all and get the last item in the group\n\t\tif (field.type === 'radio' && field.name) {\n\t\t\tvar group = document.getElementsByName(field.name);\n\t\t\tif (group.length > 0) {\n\t\t\t\tfor (var i = 0; i < group.length; i++) {\n\t\t\t\t\tif (group[i].form !== field.form) continue; // Only check fields in current form\n\t\t\t\t\tgroup[i].classList.remove(localSettings.fieldClass);\n\t\t\t\t}\n\t\t\t\tfield = group[group.length - 1];\n\t\t\t}\n\t\t}\n\n\t\t// Get field id or name\n\t\tvar id = field.id || field.name;\n\t\tif (!id) return;\n\n\t\t// Check if an error message is in the DOM\n\t\tvar message = field.form.querySelector('.' + localSettings.errorClass + '#error-for-' + id + '');\n\t\tif (!message) return;\n\n\t\t// If so, hide it\n\t\tmessage.innerHTML = '';\n\t\tmessage.style.display = 'none';\n\t\tmessage.style.visibility = 'hidden';\n\n\t\t// After remove error callback\n\t\tlocalSettings.afterRemoveError(field);\n\n\t};\n\n\t/**\n\t * Add the `novalidate` attribute to all forms\n\t * @private\n\t * @param {Boolean} remove  If true, remove the `novalidate` attribute\n\t */\n\tvar addNoValidate = function (remove) {\n\t\tvar forms = document.querySelectorAll(settings.selector);\n\t\tfor (var i = 0; i < forms.length; i++) {\n\t\t\tif (remove) {\n\t\t\t\tforms[i].removeAttribute('novalidate');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tforms[i].setAttribute('novalidate', true);\n\t\t}\n\t};\n\n\t/**\n\t * Check field validity when it loses focus\n\t * @private\n\t * @param  {Event} event The blur event\n\t */\n\tvar blurHandler = function (event) {\n\n\t\t// Only run if the field is in a form to be validated\n\t\tif (!event.target.form || !event.target.form.matches(settings.selector)) return;\n\n\t\t// Validate the field\n\t\tvar error = validate.hasError(event.target);\n\n\t\t// If there's an error, show it\n\t\tif (error) {\n\t\t\tvalidate.showError(event.target, error);\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, remove any errors that exist\n\t\tvalidate.removeError(event.target);\n\n\t};\n\n\t/**\n\t * Check radio and checkbox field validity when clicked\n\t * @private\n\t * @param  {Event} event The click event\n\t */\n\tvar clickHandler = function (event) {\n\n\t\t// Only run if the field is in a form to be validated\n\t\tif (!event.target.form || !event.target.form.matches(settings.selector)) return;\n\n\t\t// Only run if the field is a checkbox or radio\n\t\tvar type = event.target.getAttribute('type');\n\t\tif (!(type === 'checkbox' || type === 'radio')) return;\n\n\t\t// Validate the field\n\t\tvar error = validate.hasError(event.target);\n\n\t\t// If there's an error, show it\n\t\tif (error) {\n\t\t\tvalidate.showError(event.target, error);\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, remove any errors that exist\n\t\tvalidate.removeError(event.target);\n\n\t};\n\n\t/**\n\t * Check all fields on submit\n\t * @private\n\t * @param  {Event} event  The submit event\n\t */\n\tvar submitHandler = function (event) {\n\n\t\t// Only run on forms flagged for validation\n\t\tif (!event.target.matches(settings.selector)) return;\n\n\t\t// Get all of the form elements\n\t\tvar fields = event.target.elements;\n\n\t\t// Validate each field\n\t\t// Store the first field with an error to a variable so we can bring it into focus later\n\t\tvar hasErrors;\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvar error = validate.hasError(fields[i]);\n\t\t\tif (error) {\n\t\t\t\tvalidate.showError(fields[i], error);\n\t\t\t\tif (!hasErrors) {\n\t\t\t\t\thasErrors = fields[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Prevent form from submitting if there are errors or submission is disabled\n\t\tif (hasErrors || settings.disableSubmit) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\t// If there are errrors, focus on first element with error\n\t\tif (hasErrors) {\n\t\t\thasErrors.focus();\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, submit the form\n\t\tsettings.onSubmit(event.target, fields);\n\n\t};\n\n\t/**\n\t * Destroy the current initialization.\n\t * @public\n\t */\n\tvalidate.destroy = function () {\n\n\t\t// If plugin isn't already initialized, stop\n\t\tif ( !settings ) return;\n\n\t\t// Remove event listeners\n\t\tdocument.removeEventListener('blur', blurHandler, false);\n\t\tdocument.removeEventListener('click', clickHandler, true);\n\t\tdocument.removeEventListener('submit', submitHandler, false);\n\n\t\t// Remove all errors\n\t\tvar fields = document.querySelectorAll(settings.errorClass);\n\t\tfor (var i = 0; i < fields.length; i++) {\n\t\t\tvalidate.removeError(fields[i]);\n\t\t}\n\n\t\t// Remove `novalidate` from forms\n\t\taddNoValidate(true);\n\n\t\t// Reset variables\n\t\tsettings = null;\n\n\t};\n\n\t/**\n\t * Initialize Validate\n\t * @public\n\t * @param {Object} options User settings\n\t */\n\tvalidate.init = function (options) {\n\n\t\t// feature test\n\t\tif (!supports) return;\n\n\t\t// Destroy any existing initializations\n\t\tvalidate.destroy();\n\n\t\t// Merge user options with defaults\n\t\tsettings = extend(defaults, options || {});\n\n\t\t// Add the `novalidate` attribute to all forms\n\t\taddNoValidate();\n\n\t\t// Event listeners\n\t\tdocument.addEventListener('blur', blurHandler, true);\n\t\tdocument.addEventListener('click', clickHandler, true);\n\t\tdocument.addEventListener('submit', submitHandler, false);\n\n\t};\n\n\n\t//\n\t// Public APIs\n\t//\n\n\treturn validate;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUvZGlzdC9qcy92YWxpZGF0ZS5qcz82MDBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI4Q0FBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFVBQVUsOENBQThDLE9BQU87QUFDakgsNkRBQTZELFVBQVUsc0NBQXNDLE9BQU87QUFDcEg7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekUsc0VBQXNFLElBQUk7QUFDMUU7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQyxrQ0FBa0M7O0FBRWxDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFB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QUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEciLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdmFsaWRhdGUgdjEuMS4wOiBBIGxpZ2h0d2VpZ2h0IGZvcm0gdmFsaWRhdGlvbiBzY3JpcHQgdGhhdCBhdWdtZW50cyBuYXRpdmUgSFRNTDUgZm9ybSB2YWxpZGF0aW9uIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzLlxuICogKGMpIDIwMTcgQ2hyaXMgRmVyZGluYW5kaVxuICogTUlUIExpY2Vuc2VcbiAqIGh0dHA6Ly9naXRodWIuY29tL2NmZXJkaW5hbmRpL3ZhbGlkYXRlXG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdGRlZmluZShbXSwgZmFjdG9yeShyb290KSk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG5cdH0gZWxzZSB7XG5cdFx0cm9vdC52YWxpZGF0ZSA9IGZhY3Rvcnkocm9vdCk7XG5cdH1cbn0pKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdGhpcy53aW5kb3cgfHwgdGhpcy5nbG9iYWwsIChmdW5jdGlvbiAocm9vdCkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvL1xuXHQvLyBWYXJpYWJsZXNcblx0Ly9cblxuXHR2YXIgdmFsaWRhdGUgPSB7fTsgLy8gT2JqZWN0IGZvciBwdWJsaWMgQVBJc1xuXHR2YXIgc3VwcG9ydHMgPSAncXVlcnlTZWxlY3RvcicgaW4gZG9jdW1lbnQgJiYgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHJvb3Q7IC8vIEZlYXR1cmUgdGVzdFxuXHR2YXIgc2V0dGluZ3M7XG5cblx0Ly8gRGVmYXVsdCBzZXR0aW5nc1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cblx0XHQvLyBDbGFzc2VzIGFuZCBTZWxlY3RvcnNcblx0XHRzZWxlY3RvcjogJ1tkYXRhLXZhbGlkYXRlXScsXG5cdFx0ZmllbGRDbGFzczogJ2Vycm9yJyxcblx0XHRlcnJvckNsYXNzOiAnZXJyb3ItbWVzc2FnZScsXG5cblx0XHQvLyBNZXNzYWdlc1xuXHRcdG1lc3NhZ2VWYWx1ZU1pc3Npbmc6ICdQbGVhc2UgZmlsbCBvdXQgdGhpcyBmaWVsZC4nLFxuXHRcdG1lc3NhZ2VWYWx1ZU1pc3NpbmdTZWxlY3Q6ICdQbGVhc2Ugc2VsZWN0IGEgdmFsdWUuJyxcblx0XHRtZXNzYWdlVmFsdWVNaXNzaW5nU2VsZWN0TXVsdGk6ICdQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSB2YWx1ZS4nLFxuXHRcdG1lc3NhZ2VUeXBlTWlzbWF0Y2hFbWFpbDogJ1BsZWFzZSBlbnRlciBhbiBlbWFpbCBhZGRyZXNzLicsXG5cdFx0bWVzc2FnZVR5cGVNaXNtYXRjaFVSTDogJ1BsZWFzZSBlbnRlciBhIFVSTC4nLFxuXHRcdG1lc3NhZ2VUb29TaG9ydDogJ1BsZWFzZSBsZW5ndGhlbiB0aGlzIHRleHQgdG8ge21pbkxlbmd0aH0gY2hhcmFjdGVycyBvciBtb3JlLiBZb3UgYXJlIGN1cnJlbnRseSB1c2luZyB7bGVuZ3RofSBjaGFyYWN0ZXJzLicsXG5cdFx0bWVzc2FnZVRvb0xvbmc6ICdQbGVhc2Ugc2hvcnRlbiB0aGlzIHRleHQgdG8gbm8gbW9yZSB0aGFuIHttYXhMZW5ndGh9IGNoYXJhY3RlcnMuIFlvdSBhcmUgY3VycmVudGx5IHVzaW5nIHtsZW5ndGh9IGNoYXJhY3RlcnMuJyxcblx0XHRtZXNzYWdlUGF0dGVybk1pc21hdGNoOiAnUGxlYXNlIG1hdGNoIHRoZSByZXF1ZXN0ZWQgZm9ybWF0LicsXG5cdFx0bWVzc2FnZUJhZElucHV0OiAnUGxlYXNlIGVudGVyIGEgbnVtYmVyLicsXG5cdFx0bWVzc2FnZVN0ZXBNaXNtYXRjaDogJ1BsZWFzZSBzZWxlY3QgYSB2YWxpZCB2YWx1ZS4nLFxuXHRcdG1lc3NhZ2VSYW5nZU92ZXJmbG93OiAnUGxlYXNlIHNlbGVjdCBhIHZhbHVlIHRoYXQgaXMgbm8gbW9yZSB0aGFuIHttYXh9LicsXG5cdFx0bWVzc2FnZVJhbmdlVW5kZXJmbG93OiAnUGxlYXNlIHNlbGVjdCBhIHZhbHVlIHRoYXQgaXMgbm8gbGVzcyB0aGFuIHttaW59LicsXG5cdFx0bWVzc2FnZUdlbmVyaWM6ICdUaGUgdmFsdWUgeW91IGVudGVyZWQgZm9yIHRoaXMgZmllbGQgaXMgaW52YWxpZC4nLFxuXG5cdFx0Ly8gRm9ybSBTdWJtaXNzaW9uXG5cdFx0ZGlzYWJsZVN1Ym1pdDogZmFsc2UsXG5cdFx0b25TdWJtaXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0YmVmb3JlU2hvd0Vycm9yOiBmdW5jdGlvbiAoKSB7fSxcblx0XHRhZnRlclNob3dFcnJvcjogZnVuY3Rpb24gKCkge30sXG5cdFx0YmVmb3JlUmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICgpIHt9LFxuXHRcdGFmdGVyUmVtb3ZlRXJyb3I6IGZ1bmN0aW9uICgpIHt9LFxuXG5cdH07XG5cblxuXHQvL1xuXHQvLyBNZXRob2RzXG5cdC8vXG5cblx0Ly8gRWxlbWVudC5tYXRjaGVzKCkgcG9seWZpbGxcblx0aWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG5cdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG5cdFx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0RWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0ZnVuY3Rpb24ocykge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSxcblx0XHRcdFx0XHRpID0gbWF0Y2hlcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG5cdFx0XHRcdHJldHVybiBpID4gLTE7XG5cdFx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlIHR3byBvciBtb3JlIG9iamVjdHMuIFJldHVybnMgYSBuZXcgb2JqZWN0LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59ICBkZWVwICAgICBJZiB0cnVlLCBkbyBhIGRlZXAgKG9yIHJlY3Vyc2l2ZSkgbWVyZ2UgW29wdGlvbmFsXVxuXHQgKiBAcGFyYW0ge09iamVjdH0gICBvYmplY3RzICBUaGUgb2JqZWN0cyB0byBtZXJnZSB0b2dldGhlclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgICAgICBNZXJnZWQgdmFsdWVzIG9mIGRlZmF1bHRzIGFuZCBvcHRpb25zXG5cdCAqL1xuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gVmFyaWFibGVzXG5cdFx0dmFyIGV4dGVuZGVkID0ge307XG5cdFx0dmFyIGRlZXAgPSBmYWxzZTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cblx0XHQvLyBDaGVjayBpZiBhIGRlZXAgbWVyZ2Vcblx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggYXJndW1lbnRzWzBdICkgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyApIHtcblx0XHRcdGRlZXAgPSBhcmd1bWVudHNbMF07XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0Ly8gTWVyZ2UgdGhlIG9iamVjdCBpbnRvIHRoZSBleHRlbmRlZCBvYmplY3Rcblx0XHR2YXIgbWVyZ2UgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRmb3IgKCB2YXIgcHJvcCBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBvYmosIHByb3AgKSApIHtcblx0XHRcdFx0XHQvLyBJZiBkZWVwIG1lcmdlIGFuZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QsIG1lcmdlIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAoIGRlZXAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9ialtwcm9wXSkgPT09ICdbb2JqZWN0IE9iamVjdF0nICkge1xuXHRcdFx0XHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBleHRlbmQoIHRydWUsIGV4dGVuZGVkW3Byb3BdLCBvYmpbcHJvcF0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXh0ZW5kZWRbcHJvcF0gPSBvYmpbcHJvcF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIExvb3AgdGhyb3VnaCBlYWNoIG9iamVjdCBhbmQgY29uZHVjdCBhIG1lcmdlXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0bWVyZ2Uob2JqKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXh0ZW5kZWQ7XG5cblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBjbG9zZXN0IG1hdGNoaW5nIGVsZW1lbnQgdXAgdGhlIERPTSB0cmVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0gIHtFbGVtZW50fSBlbGVtICAgICBTdGFydGluZyBlbGVtZW50XG5cdCAqIEBwYXJhbSAge1N0cmluZ30gIHNlbGVjdG9yIFNlbGVjdG9yIHRvIG1hdGNoIGFnYWluc3Rcblx0ICogQHJldHVybiB7Qm9vbGVhbnxFbGVtZW50fSAgUmV0dXJucyBudWxsIGlmIG5vdCBtYXRjaCBmb3VuZFxuXHQgKi9cblx0dmFyIGdldENsb3Nlc3QgPSBmdW5jdGlvbiAoIGVsZW0sIHNlbGVjdG9yICkge1xuXHRcdGZvciAoIDsgZWxlbSAmJiBlbGVtICE9PSBkb2N1bWVudDsgZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICggZWxlbS5tYXRjaGVzKCBzZWxlY3RvciApICkgcmV0dXJuIGVsZW07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSBhIGZvcm0gZmllbGRcblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0gIHtOb2RlfSAgICBmaWVsZCAgIFRoZSBmaWVsZCB0byB2YWxpZGF0ZVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9ICBvcHRpb25zIFVzZXIgb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgIFRoZSBlcnJvciBtZXNzYWdlXG5cdCAqL1xuXHR2YWxpZGF0ZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChmaWVsZCwgb3B0aW9ucykge1xuXG5cdFx0Ly8gTWVyZ2UgdXNlciBvcHRpb25zIHdpdGggZXhpc3Rpbmcgc2V0dGluZ3Mgb3IgZGVmYXVsdHNcblx0XHR2YXIgbG9jYWxTZXR0aW5ncyA9IGV4dGVuZChzZXR0aW5ncyB8fCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cblx0XHQvLyBEb24ndCB2YWxpZGF0ZSBzdWJtaXRzLCBidXR0b25zLCBmaWxlIGFuZCByZXNldCBpbnB1dHMsIGFuZCBkaXNhYmxlZCBmaWVsZHNcblx0XHRpZiAoZmllbGQuZGlzYWJsZWQgfHwgZmllbGQudHlwZSA9PT0gJ2ZpbGUnIHx8IGZpZWxkLnR5cGUgPT09ICdyZXNldCcgfHwgZmllbGQudHlwZSA9PT0gJ3N1Ym1pdCcgfHwgZmllbGQudHlwZSA9PT0gJ2J1dHRvbicpIHJldHVybjtcblxuXHRcdC8vIEdldCB2YWxpZGl0eVxuXHRcdHZhciB2YWxpZGl0eSA9IGZpZWxkLnZhbGlkaXR5O1xuXG5cdFx0Ly8gSWYgdmFsaWQsIHJldHVybiBudWxsXG5cdFx0aWYgKHZhbGlkaXR5LnZhbGlkKSByZXR1cm47XG5cblx0XHQvLyBJZiBmaWVsZCBpcyByZXF1aXJlZCBhbmQgZW1wdHlcblx0XHRpZiAodmFsaWRpdHkudmFsdWVNaXNzaW5nKSB7XG5cdFx0XHRcblx0XHRcdGlmIChmaWVsZC50eXBlID09PSAnc2VsZWN0LW11bHRpcGxlJykgcmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZVZhbHVlTWlzc2luZ1NlbGVjdE11bHRpO1xuXG5cdFx0XHRpZiAoZmllbGQudHlwZSA9PT0gJ3NlbGVjdC1vbmUnKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVmFsdWVNaXNzaW5nU2VsZWN0O1xuXG5cdFx0XHRyZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVmFsdWVNaXNzaW5nO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vdCB0aGUgcmlnaHQgdHlwZVxuXHRcdGlmICh2YWxpZGl0eS50eXBlTWlzbWF0Y2gpIHtcblxuXHRcdFx0Ly8gRW1haWxcblx0XHRcdGlmIChmaWVsZC50eXBlID09PSAnZW1haWwnKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVHlwZU1pc21hdGNoRW1haWw7XG5cblx0XHRcdC8vIFVSTFxuXHRcdFx0aWYgKGZpZWxkLnR5cGUgPT09ICd1cmwnKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVHlwZU1pc21hdGNoVVJMO1xuXG5cdFx0fVxuXG5cdFx0Ly8gSWYgdG9vIHNob3J0XG5cdFx0aWYgKHZhbGlkaXR5LnRvb1Nob3J0KSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVG9vU2hvcnQucmVwbGFjZSgne21pbkxlbmd0aH0nLCBmaWVsZC5nZXRBdHRyaWJ1dGUoJ21pbkxlbmd0aCcpKS5yZXBsYWNlKCd7bGVuZ3RofScsIGZpZWxkLnZhbHVlLmxlbmd0aCk7XG5cblx0XHQvLyBJZiB0b28gbG9uZ1xuXHRcdGlmICh2YWxpZGl0eS50b29Mb25nKSByZXR1cm4gbG9jYWxTZXR0aW5ncy5tZXNzYWdlVG9vTG9uZy5yZXBsYWNlKCd7bWluTGVuZ3RofScsIGZpZWxkLmdldEF0dHJpYnV0ZSgnbWF4TGVuZ3RoJykpLnJlcGxhY2UoJ3tsZW5ndGh9JywgZmllbGQudmFsdWUubGVuZ3RoKTtcblxuXHRcdC8vIElmIG51bWJlciBpbnB1dCBpc24ndCBhIG51bWJlclxuXHRcdGlmICh2YWxpZGl0eS5iYWRJbnB1dCkgcmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZUJhZElucHV0O1xuXG5cdFx0Ly8gSWYgYSBudW1iZXIgdmFsdWUgZG9lc24ndCBtYXRjaCB0aGUgc3RlcCBpbnRlcnZhbFxuXHRcdGlmICh2YWxpZGl0eS5zdGVwTWlzbWF0Y2gpIHJldHVybiBsb2NhbFNldHRpbmdzLm1lc3NhZ2VTdGVwTWlzbWF0Y2g7XG5cblx0XHQvLyBJZiBhIG51bWJlciBmaWVsZCBpcyBvdmVyIHRoZSBtYXhcblx0XHRpZiAodmFsaWRpdHkucmFuZ2VPdmVyZmxvdykgcmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZVJhbmdlT3ZlcmZsb3cucmVwbGFjZSgne21heH0nLCBmaWVsZC5nZXRBdHRyaWJ1dGUoJ21heCcpKTtcblxuXHRcdC8vIElmIGEgbnVtYmVyIGZpZWxkIGlzIGJlbG93IHRoZSBtaW5cblx0XHRpZiAodmFsaWRpdHkucmFuZ2VVbmRlcmZsb3cpIHJldHVybiBsb2NhbFNldHRpbmdzLm1lc3NhZ2VSYW5nZVVuZGVyZmxvdy5yZXBsYWNlKCd7bWlufScsIGZpZWxkLmdldEF0dHJpYnV0ZSgnbWluJykpO1xuXG5cdFx0Ly8gSWYgcGF0dGVybiBkb2Vzbid0IG1hdGNoXG5cdFx0aWYgKHZhbGlkaXR5LnBhdHRlcm5NaXNtYXRjaCkge1xuXG5cdFx0XHQvLyBJZiBwYXR0ZXJuIGluZm8gaXMgaW5jbHVkZWQsIHJldHVybiBjdXN0b20gZXJyb3Jcblx0XHRcdGlmIChmaWVsZC5oYXNBdHRyaWJ1dGUoJ3RpdGxlJykpIHJldHVybiBmaWVsZC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgZ2VuZXJpYyBlcnJvclxuXHRcdFx0cmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZVBhdHRlcm5NaXNtYXRjaDtcblxuXHRcdH1cblxuXHRcdC8vIElmIGFsbCBlbHNlIGZhaWxzLCByZXR1cm4gYSBnZW5lcmljIGNhdGNoYWxsIGVycm9yXG5cdFx0cmV0dXJuIGxvY2FsU2V0dGluZ3MubWVzc2FnZUdlbmVyaWM7XG5cblx0fTtcblxuXHQvKipcblx0ICogU2hvdyBhbiBlcnJvciBtZXNzYWdlIG9uIGEgZmllbGRcblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0gIHtOb2RlfSAgIGZpZWxkICAgVGhlIGZpZWxkIHRvIHNob3cgYW4gZXJyb3IgbWVzc2FnZSBmb3Jcblx0ICogQHBhcmFtICB7U3RyaW5nfSBlcnJvciAgIFRoZSBlcnJvciBtZXNzYWdlIHRvIHNob3dcblx0ICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIFVzZXIgb3B0aW9uc1xuXHQgKi9cblx0dmFsaWRhdGUuc2hvd0Vycm9yID0gZnVuY3Rpb24gKGZpZWxkLCBlcnJvciwgb3B0aW9ucykge1xuXG5cdFx0Ly8gTWVyZ2UgdXNlciBvcHRpb25zIHdpdGggZXhpc3Rpbmcgc2V0dGluZ3Mgb3IgZGVmYXVsdHNcblx0XHR2YXIgbG9jYWxTZXR0aW5ncyA9IGV4dGVuZChzZXR0aW5ncyB8fCBkZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cblx0XHQvLyBCZWZvcmUgc2hvdyBlcnJvciBjYWxsYmFja1xuXHRcdGxvY2FsU2V0dGluZ3MuYmVmb3JlU2hvd0Vycm9yKGZpZWxkLCBlcnJvcik7XG5cblx0XHQvLyBBZGQgZXJyb3IgY2xhc3MgdG8gZmllbGRcblx0XHRmaWVsZC5jbGFzc0xpc3QuYWRkKGxvY2FsU2V0dGluZ3MuZmllbGRDbGFzcyk7XG5cblx0XHQvLyBJZiB0aGUgZmllbGQgaXMgYSByYWRpbyBidXR0b24gYW5kIHBhcnQgb2YgYSBncm91cCwgZXJyb3IgYWxsIGFuZCBnZXQgdGhlIGxhc3QgaXRlbSBpbiB0aGUgZ3JvdXBcblx0XHRpZiAoZmllbGQudHlwZSA9PT0gJ3JhZGlvJyAmJiBmaWVsZC5uYW1lKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShmaWVsZC5uYW1lKTtcblx0XHRcdGlmIChncm91cC5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZ3JvdXBbaV0uZm9ybSAhPT0gZmllbGQuZm9ybSkgY29udGludWU7IC8vIE9ubHkgY2hlY2sgZmllbGRzIGluIGN1cnJlbnQgZm9ybVxuXHRcdFx0XHRcdGdyb3VwW2ldLmNsYXNzTGlzdC5hZGQobG9jYWxTZXR0aW5ncy5maWVsZENsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWVsZCA9IGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEdldCBmaWVsZCBpZCBvciBuYW1lXG5cdFx0dmFyIGlkID0gZmllbGQuaWQgfHwgZmllbGQubmFtZTtcblx0XHRpZiAoIWlkKSByZXR1cm47XG5cblx0XHQvLyBDaGVjayBpZiBlcnJvciBtZXNzYWdlIGZpZWxkIGFscmVhZHkgZXhpc3RzXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0dmFyIG1lc3NhZ2UgPSBmaWVsZC5mb3JtLnF1ZXJ5U2VsZWN0b3IoJy4nICsgbG9jYWxTZXR0aW5ncy5lcnJvckNsYXNzICsgJyNlcnJvci1mb3ItJyArIGlkICk7XG5cdFx0aWYgKCFtZXNzYWdlKSB7XG5cdFx0XHRtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRtZXNzYWdlLmNsYXNzTmFtZSA9IGxvY2FsU2V0dGluZ3MuZXJyb3JDbGFzcztcblx0XHRcdG1lc3NhZ2UuaWQgPSAnZXJyb3ItZm9yLScgKyBpZDtcblxuXHRcdFx0Ly8gSWYgdGhlIGZpZWxkIGlzIGEgcmFkaW8gYnV0dG9uIG9yIGNoZWNrYm94LCBpbnNlcnQgZXJyb3IgYWZ0ZXIgdGhlIGxhYmVsXG5cdFx0XHR2YXIgbGFiZWw7XG5cdFx0XHRpZiAoZmllbGQudHlwZSA9PT0gJ3JhZGlvJyB8fCBmaWVsZC50eXBlID09PSdjaGVja2JveCcpIHtcblx0XHRcdFx0bGFiZWwgPSBmaWVsZC5mb3JtLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsW2Zvcj1cIicgKyBpZCArICdcIl0nKSB8fCBnZXRDbG9zZXN0KGZpZWxkLCAnbGFiZWwnKTtcblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIG1lc3NhZ2UsIGxhYmVsLm5leHRTaWJsaW5nICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgaXQgYWZ0ZXIgdGhlIGZpZWxkXG5cdFx0XHRpZiAoIWxhYmVsKSB7XG5cdFx0XHRcdGZpZWxkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBtZXNzYWdlLCBmaWVsZC5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCBBUklBIHJvbGUgdG8gdGhlIGZpZWxkXG5cdFx0ZmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgJ2Vycm9yLWZvci0nICsgaWQpO1xuXG5cdFx0Ly8gVXBkYXRlIGVycm9yIG1lc3NhZ2Vcblx0XHRtZXNzYWdlLmlubmVySFRNTCA9IGVycm9yO1xuXG5cdFx0Ly8gUmVtb3ZlIGFueSBleGlzdGluZyBzdHlsZXMgaGlkaW5nIHRoZSBlcnJvciBtZXNzYWdlXG5cdFx0bWVzc2FnZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cdFx0bWVzc2FnZS5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG5cblx0XHQvLyBBZnRlciBzaG93IGVycm9yIGNhbGxiYWNrXG5cdFx0bG9jYWxTZXR0aW5ncy5hZnRlclNob3dFcnJvcihmaWVsZCwgZXJyb3IpO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBlcnJvciBtZXNzYWdlIGZyb20gYSBmaWVsZFxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSAge05vZGV9ICAgZmllbGQgICBUaGUgZmllbGQgdG8gcmVtb3ZlIHRoZSBlcnJvciBmcm9tXG5cdCAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyBVc2VyIG9wdGlvbnNcblx0ICovXG5cdHZhbGlkYXRlLnJlbW92ZUVycm9yID0gZnVuY3Rpb24gKGZpZWxkLCBvcHRpb25zKSB7XG5cblx0XHQvLyBNZXJnZSB1c2VyIG9wdGlvbnMgd2l0aCBleGlzdGluZyBzZXR0aW5ncyBvciBkZWZhdWx0c1xuXHRcdHZhciBsb2NhbFNldHRpbmdzID0gZXh0ZW5kKHNldHRpbmdzIHx8IGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuXHRcdC8vIEJlZm9yZSByZW1vdmUgZXJyb3IgY2FsbGJhY2tcblx0XHRsb2NhbFNldHRpbmdzLmJlZm9yZVJlbW92ZUVycm9yKGZpZWxkKTtcblxuXHRcdC8vIFJlbW92ZSBBUklBIHJvbGUgZnJvbSB0aGUgZmllbGRcblx0XHRmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuXHRcdC8vIFJlbW92ZSBlcnJvciBjbGFzcyB0byBmaWVsZFxuXHRcdGZpZWxkLmNsYXNzTGlzdC5yZW1vdmUobG9jYWxTZXR0aW5ncy5maWVsZENsYXNzKTtcblxuXHRcdC8vIElmIHRoZSBmaWVsZCBpcyBhIHJhZGlvIGJ1dHRvbiBhbmQgcGFydCBvZiBhIGdyb3VwLCByZW1vdmUgZXJyb3IgZnJvbSBhbGwgYW5kIGdldCB0aGUgbGFzdCBpdGVtIGluIHRoZSBncm91cFxuXHRcdGlmIChmaWVsZC50eXBlID09PSAncmFkaW8nICYmIGZpZWxkLm5hbWUpIHtcblx0XHRcdHZhciBncm91cCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGZpZWxkLm5hbWUpO1xuXHRcdFx0aWYgKGdyb3VwLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChncm91cFtpXS5mb3JtICE9PSBmaWVsZC5mb3JtKSBjb250aW51ZTsgLy8gT25seSBjaGVjayBmaWVsZHMgaW4gY3VycmVudCBmb3JtXG5cdFx0XHRcdFx0Z3JvdXBbaV0uY2xhc3NMaXN0LnJlbW92ZShsb2NhbFNldHRpbmdzLmZpZWxkQ2xhc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpZWxkID0gZ3JvdXBbZ3JvdXAubGVuZ3RoIC0gMV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGZpZWxkIGlkIG9yIG5hbWVcblx0XHR2YXIgaWQgPSBmaWVsZC5pZCB8fCBmaWVsZC5uYW1lO1xuXHRcdGlmICghaWQpIHJldHVybjtcblxuXHRcdC8vIENoZWNrIGlmIGFuIGVycm9yIG1lc3NhZ2UgaXMgaW4gdGhlIERPTVxuXHRcdHZhciBtZXNzYWdlID0gZmllbGQuZm9ybS5xdWVyeVNlbGVjdG9yKCcuJyArIGxvY2FsU2V0dGluZ3MuZXJyb3JDbGFzcyArICcjZXJyb3ItZm9yLScgKyBpZCArICcnKTtcblx0XHRpZiAoIW1lc3NhZ2UpIHJldHVybjtcblxuXHRcdC8vIElmIHNvLCBoaWRlIGl0XG5cdFx0bWVzc2FnZS5pbm5lckhUTUwgPSAnJztcblx0XHRtZXNzYWdlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0bWVzc2FnZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cblx0XHQvLyBBZnRlciByZW1vdmUgZXJyb3IgY2FsbGJhY2tcblx0XHRsb2NhbFNldHRpbmdzLmFmdGVyUmVtb3ZlRXJyb3IoZmllbGQpO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCB0aGUgYG5vdmFsaWRhdGVgIGF0dHJpYnV0ZSB0byBhbGwgZm9ybXNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtCb29sZWFufSByZW1vdmUgIElmIHRydWUsIHJlbW92ZSB0aGUgYG5vdmFsaWRhdGVgIGF0dHJpYnV0ZVxuXHQgKi9cblx0dmFyIGFkZE5vVmFsaWRhdGUgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG5cdFx0dmFyIGZvcm1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZXR0aW5ncy5zZWxlY3Rvcik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHJlbW92ZSkge1xuXHRcdFx0XHRmb3Jtc1tpXS5yZW1vdmVBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRmb3Jtc1tpXS5zZXRBdHRyaWJ1dGUoJ25vdmFsaWRhdGUnLCB0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGZpZWxkIHZhbGlkaXR5IHdoZW4gaXQgbG9zZXMgZm9jdXNcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IFRoZSBibHVyIGV2ZW50XG5cdCAqL1xuXHR2YXIgYmx1ckhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuXHRcdC8vIE9ubHkgcnVuIGlmIHRoZSBmaWVsZCBpcyBpbiBhIGZvcm0gdG8gYmUgdmFsaWRhdGVkXG5cdFx0aWYgKCFldmVudC50YXJnZXQuZm9ybSB8fCAhZXZlbnQudGFyZ2V0LmZvcm0ubWF0Y2hlcyhzZXR0aW5ncy5zZWxlY3RvcikpIHJldHVybjtcblxuXHRcdC8vIFZhbGlkYXRlIHRoZSBmaWVsZFxuXHRcdHZhciBlcnJvciA9IHZhbGlkYXRlLmhhc0Vycm9yKGV2ZW50LnRhcmdldCk7XG5cblx0XHQvLyBJZiB0aGVyZSdzIGFuIGVycm9yLCBzaG93IGl0XG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR2YWxpZGF0ZS5zaG93RXJyb3IoZXZlbnQudGFyZ2V0LCBlcnJvcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCByZW1vdmUgYW55IGVycm9ycyB0aGF0IGV4aXN0XG5cdFx0dmFsaWRhdGUucmVtb3ZlRXJyb3IoZXZlbnQudGFyZ2V0KTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayByYWRpbyBhbmQgY2hlY2tib3ggZmllbGQgdmFsaWRpdHkgd2hlbiBjbGlja2VkXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAge0V2ZW50fSBldmVudCBUaGUgY2xpY2sgZXZlbnRcblx0ICovXG5cdHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuXHRcdC8vIE9ubHkgcnVuIGlmIHRoZSBmaWVsZCBpcyBpbiBhIGZvcm0gdG8gYmUgdmFsaWRhdGVkXG5cdFx0aWYgKCFldmVudC50YXJnZXQuZm9ybSB8fCAhZXZlbnQudGFyZ2V0LmZvcm0ubWF0Y2hlcyhzZXR0aW5ncy5zZWxlY3RvcikpIHJldHVybjtcblxuXHRcdC8vIE9ubHkgcnVuIGlmIHRoZSBmaWVsZCBpcyBhIGNoZWNrYm94IG9yIHJhZGlvXG5cdFx0dmFyIHR5cGUgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdFx0aWYgKCEodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKSkgcmV0dXJuO1xuXG5cdFx0Ly8gVmFsaWRhdGUgdGhlIGZpZWxkXG5cdFx0dmFyIGVycm9yID0gdmFsaWRhdGUuaGFzRXJyb3IoZXZlbnQudGFyZ2V0KTtcblxuXHRcdC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IsIHNob3cgaXRcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHZhbGlkYXRlLnNob3dFcnJvcihldmVudC50YXJnZXQsIGVycm9yKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIHJlbW92ZSBhbnkgZXJyb3JzIHRoYXQgZXhpc3Rcblx0XHR2YWxpZGF0ZS5yZW1vdmVFcnJvcihldmVudC50YXJnZXQpO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGFsbCBmaWVsZHMgb24gc3VibWl0XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSAge0V2ZW50fSBldmVudCAgVGhlIHN1Ym1pdCBldmVudFxuXHQgKi9cblx0dmFyIHN1Ym1pdEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuXHRcdC8vIE9ubHkgcnVuIG9uIGZvcm1zIGZsYWdnZWQgZm9yIHZhbGlkYXRpb25cblx0XHRpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHNldHRpbmdzLnNlbGVjdG9yKSkgcmV0dXJuO1xuXG5cdFx0Ly8gR2V0IGFsbCBvZiB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdHZhciBmaWVsZHMgPSBldmVudC50YXJnZXQuZWxlbWVudHM7XG5cblx0XHQvLyBWYWxpZGF0ZSBlYWNoIGZpZWxkXG5cdFx0Ly8gU3RvcmUgdGhlIGZpcnN0IGZpZWxkIHdpdGggYW4gZXJyb3IgdG8gYSB2YXJpYWJsZSBzbyB3ZSBjYW4gYnJpbmcgaXQgaW50byBmb2N1cyBsYXRlclxuXHRcdHZhciBoYXNFcnJvcnM7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBlcnJvciA9IHZhbGlkYXRlLmhhc0Vycm9yKGZpZWxkc1tpXSk7XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0dmFsaWRhdGUuc2hvd0Vycm9yKGZpZWxkc1tpXSwgZXJyb3IpO1xuXHRcdFx0XHRpZiAoIWhhc0Vycm9ycykge1xuXHRcdFx0XHRcdGhhc0Vycm9ycyA9IGZpZWxkc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXZlbnQgZm9ybSBmcm9tIHN1Ym1pdHRpbmcgaWYgdGhlcmUgYXJlIGVycm9ycyBvciBzdWJtaXNzaW9uIGlzIGRpc2FibGVkXG5cdFx0aWYgKGhhc0Vycm9ycyB8fCBzZXR0aW5ncy5kaXNhYmxlU3VibWl0KSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBlcnJyb3JzLCBmb2N1cyBvbiBmaXJzdCBlbGVtZW50IHdpdGggZXJyb3Jcblx0XHRpZiAoaGFzRXJyb3JzKSB7XG5cdFx0XHRoYXNFcnJvcnMuZm9jdXMoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIHN1Ym1pdCB0aGUgZm9ybVxuXHRcdHNldHRpbmdzLm9uU3VibWl0KGV2ZW50LnRhcmdldCwgZmllbGRzKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHRoZSBjdXJyZW50IGluaXRpYWxpemF0aW9uLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHR2YWxpZGF0ZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gSWYgcGx1Z2luIGlzbid0IGFscmVhZHkgaW5pdGlhbGl6ZWQsIHN0b3Bcblx0XHRpZiAoICFzZXR0aW5ncyApIHJldHVybjtcblxuXHRcdC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lcnNcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgYmx1ckhhbmRsZXIsIGZhbHNlKTtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlciwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3VibWl0Jywgc3VibWl0SGFuZGxlciwgZmFsc2UpO1xuXG5cdFx0Ly8gUmVtb3ZlIGFsbCBlcnJvcnNcblx0XHR2YXIgZmllbGRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZXR0aW5ncy5lcnJvckNsYXNzKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsaWRhdGUucmVtb3ZlRXJyb3IoZmllbGRzW2ldKTtcblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgYG5vdmFsaWRhdGVgIGZyb20gZm9ybXNcblx0XHRhZGROb1ZhbGlkYXRlKHRydWUpO1xuXG5cdFx0Ly8gUmVzZXQgdmFyaWFibGVzXG5cdFx0c2V0dGluZ3MgPSBudWxsO1xuXG5cdH07XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgVmFsaWRhdGVcblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBVc2VyIHNldHRpbmdzXG5cdCAqL1xuXHR2YWxpZGF0ZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuXHRcdC8vIGZlYXR1cmUgdGVzdFxuXHRcdGlmICghc3VwcG9ydHMpIHJldHVybjtcblxuXHRcdC8vIERlc3Ryb3kgYW55IGV4aXN0aW5nIGluaXRpYWxpemF0aW9uc1xuXHRcdHZhbGlkYXRlLmRlc3Ryb3koKTtcblxuXHRcdC8vIE1lcmdlIHVzZXIgb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG5cdFx0c2V0dGluZ3MgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG5cdFx0Ly8gQWRkIHRoZSBgbm92YWxpZGF0ZWAgYXR0cmlidXRlIHRvIGFsbCBmb3Jtc1xuXHRcdGFkZE5vVmFsaWRhdGUoKTtcblxuXHRcdC8vIEV2ZW50IGxpc3RlbmVyc1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBibHVySGFuZGxlciwgdHJ1ZSk7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0hhbmRsZXIsIHRydWUpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHN1Ym1pdEhhbmRsZXIsIGZhbHNlKTtcblxuXHR9O1xuXG5cblx0Ly9cblx0Ly8gUHVibGljIEFQSXNcblx0Ly9cblxuXHRyZXR1cm4gdmFsaWRhdGU7XG5cbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92YWxpZGF0ZS9kaXN0L2pzL3ZhbGlkYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},25:function(t,n,e){e(1),e(2),e(4),t.exports=e(0)},3:function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},4:function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! smooth-scroll v12.1.5 | (c) 2017 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */\n!(function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return t(e)}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"object"==typeof exports?module.exports=t(e):e.SmoothScroll=t(e)})("undefined"!=typeof global?global:"undefined"!=typeof window?window:this,(function(e){"use strict";var t="querySelector"in document&&"addEventListener"in e&&"requestAnimationFrame"in e&&"closest"in e.Element.prototype,n={ignore:"[data-scroll-ignore]",header:null,speed:500,offset:0,easing:"easeInOutCubic",customEasing:null,before:function(){},after:function(){}},o=function(){for(var e={},t=0,n=arguments.length;t<n;t++){var o=arguments[t];!(function(t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(o)}return e},a=function(t){return parseInt(e.getComputedStyle(t).height,10)},r=function(e){"#"===e.charAt(0)&&(e=e.substr(1));for(var t,n=String(e),o=n.length,a=-1,r="",i=n.charCodeAt(0);++a<o;){if(0===(t=n.charCodeAt(a)))throw new InvalidCharacterError("Invalid character: the input contains U+0000.");t>=1&&t<=31||127==t||0===a&&t>=48&&t<=57||1===a&&t>=48&&t<=57&&45===i?r+="\\\\"+t.toString(16)+" ":r+=t>=128||45===t||95===t||t>=48&&t<=57||t>=65&&t<=90||t>=97&&t<=122?n.charAt(a):"\\\\"+n.charAt(a)}return"#"+r},i=function(e,t){var n;return"easeInQuad"===e.easing&&(n=t*t),"easeOutQuad"===e.easing&&(n=t*(2-t)),"easeInOutQuad"===e.easing&&(n=t<.5?2*t*t:(4-2*t)*t-1),"easeInCubic"===e.easing&&(n=t*t*t),"easeOutCubic"===e.easing&&(n=--t*t*t+1),"easeInOutCubic"===e.easing&&(n=t<.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1),"easeInQuart"===e.easing&&(n=t*t*t*t),"easeOutQuart"===e.easing&&(n=1- --t*t*t*t),"easeInOutQuart"===e.easing&&(n=t<.5?8*t*t*t*t:1-8*--t*t*t*t),"easeInQuint"===e.easing&&(n=t*t*t*t*t),"easeOutQuint"===e.easing&&(n=1+--t*t*t*t*t),"easeInOutQuint"===e.easing&&(n=t<.5?16*t*t*t*t*t:1+16*--t*t*t*t*t),e.customEasing&&(n=e.customEasing(t)),n||t},u=function(){return Math.max(document.body.scrollHeight,document.documentElement.scrollHeight,document.body.offsetHeight,document.documentElement.offsetHeight,document.body.clientHeight,document.documentElement.clientHeight)},c=function(e,t,n){var o=0;if(e.offsetParent)do{o+=e.offsetTop,e=e.offsetParent}while(e);return o=Math.max(o-t-n,0)},s=function(e){return e?a(e)+e.offsetTop:0},l=function(t,n,o){o||(t.focus(),document.activeElement.id!==t.id&&(t.setAttribute("tabindex","-1"),t.focus(),t.style.outline="none"),e.scrollTo(0,n))},f=function(t){return!!("matchMedia"in e&&e.matchMedia("(prefers-reduced-motion)").matches)};return function(a,d){var m,h,g,p,v,b,y,S={};S.cancelScroll=function(){cancelAnimationFrame(y)},S.animateScroll=function(t,a,r){var f=o(m||n,r||{}),d="[object Number]"===Object.prototype.toString.call(t),h=d||!t.tagName?null:t;if(d||h){var g=e.pageYOffset;f.header&&!p&&(p=document.querySelector(f.header)),v||(v=s(p));var b,y,E,I=d?t:c(h,v,parseInt("function"==typeof f.offset?f.offset():f.offset,10)),O=I-g,A=u(),C=0,w=function(n,o){var r=e.pageYOffset;if(n==o||r==o||(g<o&&e.innerHeight+r)>=A)return S.cancelScroll(),l(t,o,d),f.after(t,a),b=null,!0},Q=function(t){b||(b=t),C+=t-b,y=C/parseInt(f.speed,10),y=y>1?1:y,E=g+O*i(f,y),e.scrollTo(0,Math.floor(E)),w(E,I)||(e.requestAnimationFrame(Q),b=t)};0===e.pageYOffset&&e.scrollTo(0,0),f.before(t,a),S.cancelScroll(),e.requestAnimationFrame(Q)}};var E=function(e){h&&(h.id=h.getAttribute("data-scroll-id"),S.animateScroll(h,g),h=null,g=null)},I=function(t){if(!f()&&0===t.button&&!t.metaKey&&!t.ctrlKey&&(g=t.target.closest(a))&&"a"===g.tagName.toLowerCase()&&!t.target.closest(m.ignore)&&g.hostname===e.location.hostname&&g.pathname===e.location.pathname&&/#/.test(g.href)){var n;try{n=r(decodeURIComponent(g.hash))}catch(e){n=r(g.hash)}if("#"===n){t.preventDefault(),h=document.body;var o=h.id?h.id:"smooth-scroll-top";return h.setAttribute("data-scroll-id",o),h.id="",void(e.location.hash.substring(1)===o?E():e.location.hash=o)}h=document.querySelector(n),h&&(h.setAttribute("data-scroll-id",h.id),h.id="",g.hash===e.location.hash&&(t.preventDefault(),E()))}},O=function(e){b||(b=setTimeout((function(){b=null,v=s(p)}),66))};return S.destroy=function(){m&&(document.removeEventListener("click",I,!1),e.removeEventListener("resize",O,!1),S.cancelScroll(),m=null,h=null,g=null,p=null,v=null,b=null,y=null)},S.init=function(a){t&&(S.destroy(),m=o(n,a||{}),p=m.header?document.querySelector(m.header):null,v=s(p),document.addEventListener("click",I,!1),e.addEventListener("hashchange",E,!1),p&&e.addEventListener("resize",O,!1))},S.init(d),S}}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3RoLXNjcm9sbC9kaXN0L2pzL3Ntb290aC1zY3JvbGwubWluLmpzP2RiNjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjhDQUFBO0FBQ0EsZ0JBQWdCLHVGQUE0RCxZQUFZO0FBQUEsc0tBQW9FLHdGQUF3RixhQUFhLDBIQUEwSCwwSEFBMEgsb0JBQW9CLGNBQWMsWUFBWSx3QkFBd0IsSUFBSSxLQUFLLG1CQUFtQixjQUFjLGdEQUFnRCxLQUFLLFNBQVMsZUFBZSxpREFBaUQsZUFBZSxtQ0FBbUMsNkRBQTZELE1BQU0sRUFBRSw0R0FBNEcsbU1BQW1NLFlBQVksaUJBQWlCLE1BQU0sMm1CQUEybUIsY0FBYyxvTkFBb04sbUJBQW1CLFFBQVEscUJBQXFCLGdDQUFnQyxTQUFTLDJCQUEyQixlQUFlLDRCQUE0QixtQkFBbUIsb0lBQW9JLGVBQWUsOEVBQThFLHFCQUFxQix1QkFBdUIsMEJBQTBCLHdCQUF3QixpQ0FBaUMsa0JBQWtCLGlGQUFpRixTQUFTLG9CQUFvQiwrREFBK0Qsb0hBQW9ILG9CQUFvQixpR0FBaUcsZUFBZSxzSUFBc0ksK0ZBQStGLGtCQUFrQiw4RUFBOEUsZUFBZSwwTkFBME4sTUFBTSxJQUFJLGdDQUFnQyxTQUFTLFlBQVksWUFBWSxtQ0FBbUMsb0NBQW9DLCtHQUErRyxtSUFBbUksZUFBZSw2QkFBNkIsY0FBYyxRQUFRLDRCQUE0Qix1SkFBdUosb0JBQW9CLDJCQUEyQiw4S0FBOEssY0FBYyxHIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc21vb3RoLXNjcm9sbCB2MTIuMS41IHwgKGMpIDIwMTcgQ2hyaXMgRmVyZGluYW5kaSB8IE1JVCBMaWNlbnNlIHwgaHR0cDovL2dpdGh1Yi5jb20vY2ZlcmRpbmFuZGkvc21vb3RoLXNjcm9sbCAqL1xuIShmdW5jdGlvbihlLHQpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sKGZ1bmN0aW9uKCl7cmV0dXJuIHQoZSl9KSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9dChlKTplLlNtb290aFNjcm9sbD10KGUpfSkoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dGhpcywoZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9XCJxdWVyeVNlbGVjdG9yXCJpbiBkb2N1bWVudCYmXCJhZGRFdmVudExpc3RlbmVyXCJpbiBlJiZcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiaW4gZSYmXCJjbG9zZXN0XCJpbiBlLkVsZW1lbnQucHJvdG90eXBlLG49e2lnbm9yZTpcIltkYXRhLXNjcm9sbC1pZ25vcmVdXCIsaGVhZGVyOm51bGwsc3BlZWQ6NTAwLG9mZnNldDowLGVhc2luZzpcImVhc2VJbk91dEN1YmljXCIsY3VzdG9tRWFzaW5nOm51bGwsYmVmb3JlOmZ1bmN0aW9uKCl7fSxhZnRlcjpmdW5jdGlvbigpe319LG89ZnVuY3Rpb24oKXtmb3IodmFyIGU9e30sdD0wLG49YXJndW1lbnRzLmxlbmd0aDt0PG47dCsrKXt2YXIgbz1hcmd1bWVudHNbdF07IShmdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gdCl0Lmhhc093blByb3BlcnR5KG4pJiYoZVtuXT10W25dKX0pKG8pfXJldHVybiBlfSxhPWZ1bmN0aW9uKHQpe3JldHVybiBwYXJzZUludChlLmdldENvbXB1dGVkU3R5bGUodCkuaGVpZ2h0LDEwKX0scj1mdW5jdGlvbihlKXtcIiNcIj09PWUuY2hhckF0KDApJiYoZT1lLnN1YnN0cigxKSk7Zm9yKHZhciB0LG49U3RyaW5nKGUpLG89bi5sZW5ndGgsYT0tMSxyPVwiXCIsaT1uLmNoYXJDb2RlQXQoMCk7KythPG87KXtpZigwPT09KHQ9bi5jaGFyQ29kZUF0KGEpKSl0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXI6IHRoZSBpbnB1dCBjb250YWlucyBVKzAwMDAuXCIpO3Q+PTEmJnQ8PTMxfHwxMjc9PXR8fDA9PT1hJiZ0Pj00OCYmdDw9NTd8fDE9PT1hJiZ0Pj00OCYmdDw9NTcmJjQ1PT09aT9yKz1cIlxcXFxcIit0LnRvU3RyaW5nKDE2KStcIiBcIjpyKz10Pj0xMjh8fDQ1PT09dHx8OTU9PT10fHx0Pj00OCYmdDw9NTd8fHQ+PTY1JiZ0PD05MHx8dD49OTcmJnQ8PTEyMj9uLmNoYXJBdChhKTpcIlxcXFxcIituLmNoYXJBdChhKX1yZXR1cm5cIiNcIityfSxpPWZ1bmN0aW9uKGUsdCl7dmFyIG47cmV0dXJuXCJlYXNlSW5RdWFkXCI9PT1lLmVhc2luZyYmKG49dCp0KSxcImVhc2VPdXRRdWFkXCI9PT1lLmVhc2luZyYmKG49dCooMi10KSksXCJlYXNlSW5PdXRRdWFkXCI9PT1lLmVhc2luZyYmKG49dDwuNT8yKnQqdDooNC0yKnQpKnQtMSksXCJlYXNlSW5DdWJpY1wiPT09ZS5lYXNpbmcmJihuPXQqdCp0KSxcImVhc2VPdXRDdWJpY1wiPT09ZS5lYXNpbmcmJihuPS0tdCp0KnQrMSksXCJlYXNlSW5PdXRDdWJpY1wiPT09ZS5lYXNpbmcmJihuPXQ8LjU/NCp0KnQqdDoodC0xKSooMip0LTIpKigyKnQtMikrMSksXCJlYXNlSW5RdWFydFwiPT09ZS5lYXNpbmcmJihuPXQqdCp0KnQpLFwiZWFzZU91dFF1YXJ0XCI9PT1lLmVhc2luZyYmKG49MS0gLS10KnQqdCp0KSxcImVhc2VJbk91dFF1YXJ0XCI9PT1lLmVhc2luZyYmKG49dDwuNT84KnQqdCp0KnQ6MS04Ki0tdCp0KnQqdCksXCJlYXNlSW5RdWludFwiPT09ZS5lYXNpbmcmJihuPXQqdCp0KnQqdCksXCJlYXNlT3V0UXVpbnRcIj09PWUuZWFzaW5nJiYobj0xKy0tdCp0KnQqdCp0KSxcImVhc2VJbk91dFF1aW50XCI9PT1lLmVhc2luZyYmKG49dDwuNT8xNip0KnQqdCp0KnQ6MSsxNiotLXQqdCp0KnQqdCksZS5jdXN0b21FYXNpbmcmJihuPWUuY3VzdG9tRWFzaW5nKHQpKSxufHx0fSx1PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCxkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KX0sYz1mdW5jdGlvbihlLHQsbil7dmFyIG89MDtpZihlLm9mZnNldFBhcmVudClkb3tvKz1lLm9mZnNldFRvcCxlPWUub2Zmc2V0UGFyZW50fXdoaWxlKGUpO3JldHVybiBvPU1hdGgubWF4KG8tdC1uLDApfSxzPWZ1bmN0aW9uKGUpe3JldHVybiBlP2EoZSkrZS5vZmZzZXRUb3A6MH0sbD1mdW5jdGlvbih0LG4sbyl7b3x8KHQuZm9jdXMoKSxkb2N1bWVudC5hY3RpdmVFbGVtZW50LmlkIT09dC5pZCYmKHQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIi0xXCIpLHQuZm9jdXMoKSx0LnN0eWxlLm91dGxpbmU9XCJub25lXCIpLGUuc2Nyb2xsVG8oMCxuKSl9LGY9ZnVuY3Rpb24odCl7cmV0dXJuISEoXCJtYXRjaE1lZGlhXCJpbiBlJiZlLm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIikubWF0Y2hlcyl9O3JldHVybiBmdW5jdGlvbihhLGQpe3ZhciBtLGgsZyxwLHYsYix5LFM9e307Uy5jYW5jZWxTY3JvbGw9ZnVuY3Rpb24oKXtjYW5jZWxBbmltYXRpb25GcmFtZSh5KX0sUy5hbmltYXRlU2Nyb2xsPWZ1bmN0aW9uKHQsYSxyKXt2YXIgZj1vKG18fG4scnx8e30pLGQ9XCJbb2JqZWN0IE51bWJlcl1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxoPWR8fCF0LnRhZ05hbWU/bnVsbDp0O2lmKGR8fGgpe3ZhciBnPWUucGFnZVlPZmZzZXQ7Zi5oZWFkZXImJiFwJiYocD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGYuaGVhZGVyKSksdnx8KHY9cyhwKSk7dmFyIGIseSxFLEk9ZD90OmMoaCx2LHBhcnNlSW50KFwiZnVuY3Rpb25cIj09dHlwZW9mIGYub2Zmc2V0P2Yub2Zmc2V0KCk6Zi5vZmZzZXQsMTApKSxPPUktZyxBPXUoKSxDPTAsdz1mdW5jdGlvbihuLG8pe3ZhciByPWUucGFnZVlPZmZzZXQ7aWYobj09b3x8cj09b3x8KGc8byYmZS5pbm5lckhlaWdodCtyKT49QSlyZXR1cm4gUy5jYW5jZWxTY3JvbGwoKSxsKHQsbyxkKSxmLmFmdGVyKHQsYSksYj1udWxsLCEwfSxRPWZ1bmN0aW9uKHQpe2J8fChiPXQpLEMrPXQtYix5PUMvcGFyc2VJbnQoZi5zcGVlZCwxMCkseT15PjE/MTp5LEU9ZytPKmkoZix5KSxlLnNjcm9sbFRvKDAsTWF0aC5mbG9vcihFKSksdyhFLEkpfHwoZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoUSksYj10KX07MD09PWUucGFnZVlPZmZzZXQmJmUuc2Nyb2xsVG8oMCwwKSxmLmJlZm9yZSh0LGEpLFMuY2FuY2VsU2Nyb2xsKCksZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoUSl9fTt2YXIgRT1mdW5jdGlvbihlKXtoJiYoaC5pZD1oLmdldEF0dHJpYnV0ZShcImRhdGEtc2Nyb2xsLWlkXCIpLFMuYW5pbWF0ZVNjcm9sbChoLGcpLGg9bnVsbCxnPW51bGwpfSxJPWZ1bmN0aW9uKHQpe2lmKCFmKCkmJjA9PT10LmJ1dHRvbiYmIXQubWV0YUtleSYmIXQuY3RybEtleSYmKGc9dC50YXJnZXQuY2xvc2VzdChhKSkmJlwiYVwiPT09Zy50YWdOYW1lLnRvTG93ZXJDYXNlKCkmJiF0LnRhcmdldC5jbG9zZXN0KG0uaWdub3JlKSYmZy5ob3N0bmFtZT09PWUubG9jYXRpb24uaG9zdG5hbWUmJmcucGF0aG5hbWU9PT1lLmxvY2F0aW9uLnBhdGhuYW1lJiYvIy8udGVzdChnLmhyZWYpKXt2YXIgbjt0cnl7bj1yKGRlY29kZVVSSUNvbXBvbmVudChnLmhhc2gpKX1jYXRjaChlKXtuPXIoZy5oYXNoKX1pZihcIiNcIj09PW4pe3QucHJldmVudERlZmF1bHQoKSxoPWRvY3VtZW50LmJvZHk7dmFyIG89aC5pZD9oLmlkOlwic21vb3RoLXNjcm9sbC10b3BcIjtyZXR1cm4gaC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXNjcm9sbC1pZFwiLG8pLGguaWQ9XCJcIix2b2lkKGUubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSk9PT1vP0UoKTplLmxvY2F0aW9uLmhhc2g9byl9aD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKG4pLGgmJihoLnNldEF0dHJpYnV0ZShcImRhdGEtc2Nyb2xsLWlkXCIsaC5pZCksaC5pZD1cIlwiLGcuaGFzaD09PWUubG9jYXRpb24uaGFzaCYmKHQucHJldmVudERlZmF1bHQoKSxFKCkpKX19LE89ZnVuY3Rpb24oZSl7Ynx8KGI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtiPW51bGwsdj1zKHApfSksNjYpKX07cmV0dXJuIFMuZGVzdHJveT1mdW5jdGlvbigpe20mJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIixJLCExKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixPLCExKSxTLmNhbmNlbFNjcm9sbCgpLG09bnVsbCxoPW51bGwsZz1udWxsLHA9bnVsbCx2PW51bGwsYj1udWxsLHk9bnVsbCl9LFMuaW5pdD1mdW5jdGlvbihhKXt0JiYoUy5kZXN0cm95KCksbT1vKG4sYXx8e30pLHA9bS5oZWFkZXI/ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihtLmhlYWRlcik6bnVsbCx2PXMocCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsSSwhMSksZS5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLEUsITEpLHAmJmUuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLE8sITEpKX0sUy5pbml0KGQpLFN9fSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Ntb290aC1zY3JvbGwvZGlzdC9qcy9zbW9vdGgtc2Nyb2xsLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')}});